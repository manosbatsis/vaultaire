
# Corda Accounts Plugin

This plugin provides support for Corda Accounts to Vaultaire's runtime and build-time modules.

## Installation

Add Vaultaire's plugin for Corda Accounts to your Cordapp's Gradle dependencies
using compile, cordapp or cordaCompile to match the core Vaultaire dependency.

```groovy
cordaCompile "com.github.manosbatsis.vaultaire:vaultaire-plugin-accounts:$vaultaire_version"
```
Depending on the above dependency type, you may also need to add the plugin
to your client app and `deployNodes` dependency configuration.

The plugin adds both new and enhanced versions of core component types. It also overrides Vaultaire's
internal configuration options to effectively apply them. These include the default base types extended
by components generated by the annotation processor.

## DTO Enhancements

### VaultaireAccountInfo Annotation

The plugin introduces the `VaultaireAccountInfo` annotation as the means to mark participant
or other properties of a `ContractState` that map to a Corda Account. Supported types include:

- `AbstractParty`
- `AnonymousParty`
- `PublicKey`
- `AccountParty`

Using the annotation for the last one is optional.

### Accounts-Aware DTO Types

The plugin also adds:

- `AccountInfoStateDto` as a convenient model that maps from app-level users
or state properties (as supported by `@VaultaireAccountInfo` above) to Corda Accounts,
i.e. `AccountInfo` states.

- `AccountsAwareStateClientDto` as the equivalent of REST/client-friendly equivalent,.

All the above effectively provide the "lite" DTO strategy with enhanced DTO<->state conversion
and patching utilities, i.e. mainly with support for mapping between the applicable types
(see `@VaultaireAccountInfo`) and `AccountInfoDto`.

As an example, consider the following state:

```kotlin
data class MagazineState(
        val publisher: AccountParty,
        @VaultaireAccountInfo
        val author: PublicKey,
        @VaultaireAccountInfo
        val editor: AbstractParty,
        //...
        override val linearId: UniqueIdentifier = UniqueIdentifier()
) : LinearState, QueryableState {
        override val participants get() = listOf(publisher.party, AbstractParty(author), editor)
        //...
}
```

The generated client DTO for the above:

```kotlin
data class MagazineStateClientDto(
		var publisher: AccountInfoStateClientDto? = null,
		var author: AccountInfoStateClientDto? = null,
		var editor: AccountInfoStateClientDto? = null,
		//...
		var linearId: UniqueIdentifier? = null
) : AccountsAwareStateClientDto<BookContract.MagazineState> {
    //...
}
```


## Query DSL Enhancements

Corda 4.3 added the possibility to map any public key to an external id of type UUID. 
Corda Accounts uses this feature to map an account's key to the account's id.

Thus, using `externalIds` creates query criteria aware of state participants, without 
the need to embed account identifiers within the state itself.

This is now supported by the generated Query DSL for your contract state:
 
```kotlin
val magazineStateQuery = magazineStateQuery {
    // Match participants using the following 
    // AccountInfo identifiers
    externalIds = listOfNotNull(publisher.identifier)
    status = Vault.StateStatus.UNCONSUMED // the default
    // The rest of the query..
    //...
```

## Service Enhancements

The plugin also adds and applies various accounts-aware service types as replacements
of their default equivalents, along with a number of utility methods around accounts. 


```kotlin
// Create an instance of the generated service type,
// passing a ServiceHub, CordaRPCOps, NodeRpcConnection
// or even a custom StateServiceDelegate
val stateService = AccountInfoService(serviceHub)

// Get the account that is already stored locally
// and matching the given [id] if found, null otherwise
val accountOrNull: AccountInfo? = 
        stateService.findStoredAccount(accountId)
        ?: stateService.requestAccount(accountId, accountHost)

// Get the account that is already stored locally
// and matching the given [id] if found, null otherwise
val account: AccountInfo = stateService.getStoredAccount(accountId)

// Find accounts that are already stored locally
// and match the given [criteria]
val accountsPage: Vault.Page<AccountInfo> =
	stateService.findStoredAccounts(queryCriteria)

// Create a public key for the given [accountInfo] */
val anonymousParty = stateService.createPublicKey(accountInfo)
```

 


