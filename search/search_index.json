{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Vaultaire \u00b6 Query DSL and data access utilities for Corda developers. Query DSL \u00b6 Use DSL will make your queries much easier to read and maintain. Each query DSL is automatically (re)generated at build time using annotation processing. Usage example: val queryCriteria : QueryCriteria = booksQuery { and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` \"Corda Books Ltd.\" or { fields . title ` == ` \"A book on Corda\" fields . author ` != ` \"John Doe\" } } orderBy { fields . title sort DESC } }. toCriteria () For more details see Query DSL . RSQL Plugin \u00b6 A plugin with support for RSQL , a URL-friendly query language for dynamic, complex queries and maintenance-free REST endpoints for searching the Vault. For more details see RSQL Support . Accounts Plugin \u00b6 A plugin for adding Corda Accounts support to Vaultaire\u2019s runtime and build-time modules. For more details see Corda Accounts . State Services \u00b6 Vaultaire\u2019s StateService interface provide a simple, consistent API to load, query and track vault states. StateService implementations are usually auto-generated at build time and specific to a single ContractState type. State Services can also decouple you code from ServiceHub and CordaRPCOps amd help increase code reuse between cordapps and their clients. For more details see State Services . State DTOs \u00b6 Maintaining Data Transfer Objects for your contract states can be a mundane, error-prone task. Vaultaire\u2019s annotation processing automates this by (re)generating those DTOs for you. For more info checkout State DTOs Other Utils \u00b6 Vaultaire includes a few other utilities like: REST-friendly pages for query results. Annotation to generate responder flows from commonly used supertypes. For more info checkout Other Utilities Sample Projects \u00b6 For simple examples, checkout the vaultaire-example-contract and vaultaire-example-workflow modules in Vaultaire\u2019s repository on Github. For an extensive Cordapp example including a Spring Boot client checkout the corbeans-yo-cordapp repository.","title":"Overview"},{"location":"#vaultaire","text":"Query DSL and data access utilities for Corda developers.","title":"Vaultaire"},{"location":"#query-dsl","text":"Use DSL will make your queries much easier to read and maintain. Each query DSL is automatically (re)generated at build time using annotation processing. Usage example: val queryCriteria : QueryCriteria = booksQuery { and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` \"Corda Books Ltd.\" or { fields . title ` == ` \"A book on Corda\" fields . author ` != ` \"John Doe\" } } orderBy { fields . title sort DESC } }. toCriteria () For more details see Query DSL .","title":"Query DSL"},{"location":"#rsql-plugin","text":"A plugin with support for RSQL , a URL-friendly query language for dynamic, complex queries and maintenance-free REST endpoints for searching the Vault. For more details see RSQL Support .","title":"RSQL Plugin"},{"location":"#accounts-plugin","text":"A plugin for adding Corda Accounts support to Vaultaire\u2019s runtime and build-time modules. For more details see Corda Accounts .","title":"Accounts Plugin"},{"location":"#state-services","text":"Vaultaire\u2019s StateService interface provide a simple, consistent API to load, query and track vault states. StateService implementations are usually auto-generated at build time and specific to a single ContractState type. State Services can also decouple you code from ServiceHub and CordaRPCOps amd help increase code reuse between cordapps and their clients. For more details see State Services .","title":"State Services"},{"location":"#state-dtos","text":"Maintaining Data Transfer Objects for your contract states can be a mundane, error-prone task. Vaultaire\u2019s annotation processing automates this by (re)generating those DTOs for you. For more info checkout State DTOs","title":"State DTOs"},{"location":"#other-utils","text":"Vaultaire includes a few other utilities like: REST-friendly pages for query results. Annotation to generate responder flows from commonly used supertypes. For more info checkout Other Utilities","title":"Other Utils"},{"location":"#sample-projects","text":"For simple examples, checkout the vaultaire-example-contract and vaultaire-example-workflow modules in Vaultaire\u2019s repository on Github. For an extensive Cordapp example including a Spring Boot client checkout the corbeans-yo-cordapp repository.","title":"Sample Projects"},{"location":"changelog/","text":"Changelog \u00b6 The following sections describe major changes per version and can be helpful with version upgrades. 0.41 \u00b6 Minor view fixes 0.40 \u00b6 This is a release with BREAKING CHANGES. Annotations have been renamed: Previous Name New Name VaultaireGenerate VaultaireStateUtils VaultaireGenerateForDependency VaultaireStateUtilsMixin VaultaireGenerateDto VaultaireStateDto VaultaireGenerateDtoForDependency VaultaireStateDtoMixin VaultaireFlowInput VaultaireModelDto VaultaireFlowInputForDependency VaultaireModelDtoMixin VaultaireGenerateResponder VaultaireFlowResponder Class and file names of generated state-based DTOs use new suffixes: LiteDto has changed to StateClientDto Dto has changed to StateDto DTO generation strategies have been updated: DEFAULT is now CORDAPP_LOCAL_DTO LITE is now CORDAPP_CLIENT_DTO The default DTO strategy is now CORDAPP_CLIENT_DTO This release also brings new features: VaultaireModelDto and VaultaireModelDtoMixin are now focused in DTO generation for non-state models. The resulting class and file name suffix is ModelClientDto with support for the usual REST or otherwise client-friendly auto-conversion of Corda-specific types. All DTO-generating annotations now have a views: Array<VaultaireView> member, to allow additional classes to be generated, each with a subset of fields from the target state or model type. All DTO-generating annotations now have a nonDataClass: Boolean member, that should be set to true for target state or model types that are NOT data classes. 0.39 \u00b6 Added @VaultaireFlowInput and @VaultaireFlowInputForDependency to support generating REST-friendly DTOs and utils for non-state data classes. 0.38 \u00b6 Minor accounts update 0.37 \u00b6 RSQL support: removed =notnull= and refactored =null= to accept a boolean argument instead, according to the RSQL parser grammar. 0.36 \u00b6 RSQL improvements: Fixed =in= , =out= comparisons. Moved wildcard-based comparisons to dedicated =like= and =unlike= operators. The converterFactory parameter in VaultQueryCriteriaCondition.withRsql is now optional. 0.35 \u00b6 Added plugin for RSQL support. 0.34 \u00b6 Support DTO-only fields with mixins. 0.33 \u00b6 Upgraded to Corda 4.6, Partiture 0.15, Poolboy 0.4. 0.32 \u00b6 Added VaultaireAttachmentService as a utility for attaching Vaultaire\u2019s JAR to a transaction. 0.31 \u00b6 Updated corda-rpc-poolboy dependency. 0.30 \u00b6 Reverted to forcing root state status to criteria as Corda seems to have an issue with StateStatus.ALL . 0.29 \u00b6 Added ResultsPage as a REST-friendly alternative to Vault.Page combined with mapping from StateAndRef to either contract states or DTOs. Removed explicit state status from DSL criteria, applied root criterion last instead. 0.28 \u00b6 Fixed generated DTOs missing @CordaSerializable . (Service) Registry is now more accessible. Fixed service defaults parameter type from SimpleServiceDefaults to interface ServiceDefaults in NodeService, StateService and delegates. Fixed pool-based initialization of services from network service. 0.26-27 \u00b6 Bumped Corda to OS 4.5 Refactored to support RPC connection pooling based on Corda RPC PoolBoy 0.25 \u00b6 Bumped Corda to OS 4.4 Added support for \u201clite\u201d DTO strategy Added Query DSL root externalIds property to support querying the vault by Corda Account(s) 0.24 \u00b6 Added default parameter value false to VaultQueryCriteriaCondition.toCriteria(boolean) , so that aggregates are not ignored by default. 0.23 \u00b6 Fixed corda API design issue, where a secondary VaultCustomQueryCriteria \u2018s implicit/default status of UNCONSUMED (VS null) is applied, overriding the root DSL status 0.22 \u00b6 Bumped kotlin-utils, fixing issue with DTO generation including companion object members of the source type. 0.21 \u00b6 Bumped KotlinPoet, util versions Added @DefaultValue example in the docs 0.20 \u00b6 Added CordaSerializable annotation to generated DTOs Added ignoreProperties to VaultaireGenerateDto and VaultaireGenerateDtoForDependency , useful with derived/backed properties like participants 0.19 \u00b6 Added [NodeRpcConnection] interface and [StateServiceRpcConnectionDelegate] for libraries in need of more flexible [StateServiceDelegate] integration e.g. Corbeans/Spring or other IoC containers 0.18 \u00b6 Bumped deps i.e. Corda to OS 4.3 0.17 \u00b6 Added support for sorting based on standard attributes and aliases of those, i.e. enum values of Sort.CommonStateAttribute , Sort.VaultStateAttribute , Sort.LinearStateAttribute and Sort.FungibleStateAttribute . 0.16 \u00b6 Added copyAnnotationPackages property to VaultaireGenerateDto and VaultaireGenerateDtoForDependency . The property can be used to define a list of base packages for matching annotations to be copied automatically from a source ContractState to it\u2019s generated DTO. This is useful when replication of e.g. Jackson or Bean Validation annotations can be useful. 0.15 \u00b6 Replaced com.github.manosbatsis.vaultaire.dto.Dto and com.github.manosbatsis.vaultaire.util.DtoInsufficientStateMappingException with kotlin-utils equivalents extracted there. You may need to update package/method names in your code if you make use of generated DTOs. 0.14 \u00b6 Vaultaire\u2019s *ForDependency annotations now use the annotated element\u2019s package (suffixed with .generated ) for output. This leaves the original (state) packages exclusive to their modules if needed, avoiding when cordapp package conflicts while testing. 0.13 \u00b6 Add support for final responder flow supertypes in VaultaireGenerateResponder 0.12 \u00b6 Fixed dependency scope for kotlin-utils 0.11 \u00b6 Added VaultaireGenerateDto , VaultaireGenerateDtoForDependency annotations for generating DTOs for contract states Added VaultaireGenerateResponder annotation for generating responder flows extending common supertypes Refactored to extract kotlin-utils 0.10 \u00b6 Added @VaultaireGenerateForDependency to support generation (of DSL, Services etc.) for states contributed to the classpath by project dependencies Enhanced generated subclasses of ExtendedStateService with DSL-aware buildQuery , queryBy and trackBy Fixed typo from VaultaireGenerate.constractStateType to VaultaireGenerate.contractStateType 0.9 \u00b6 0.8 re-release fix 0.8 \u00b6 Allow annotation processing to generate code to another Gradle module or location using the kapt.kotlin.vaultaire.generated kapt argument, see installation docs. 0.7 \u00b6 Fixed, improved and added tests for StateService get/find by id/externalId methods StateService get by id/externalId will throw a StateNotFoundException when no match is found 0.6 \u00b6 Added support for aggregate functions . Added getByExternalId and findByExternalId methods to StateService Added optional Vault.RelevancyStatus parameter to StateService getByLinearId and findByLinearId methods 0.5 \u00b6 Removed param from String.asUniqueIdentifier() 0.4 \u00b6 Fixed handling of nullable fields Added string input signatures for getByLinearId , findByLinearId 0.3 \u00b6 Refactored StateService to an interface 0.2 \u00b6 Renamed VaultQueryDsl annotation to VaultaireGenerate Renamed StateService to BasicStateService , added extended StateService type. The annotation processor will now generate a subclass of StateService per annotated PersistentState 0.1 \u00b6 Initial release","title":"Change Log"},{"location":"changelog/#changelog","text":"The following sections describe major changes per version and can be helpful with version upgrades.","title":"Changelog"},{"location":"changelog/#041","text":"Minor view fixes","title":"0.41"},{"location":"changelog/#040","text":"This is a release with BREAKING CHANGES. Annotations have been renamed: Previous Name New Name VaultaireGenerate VaultaireStateUtils VaultaireGenerateForDependency VaultaireStateUtilsMixin VaultaireGenerateDto VaultaireStateDto VaultaireGenerateDtoForDependency VaultaireStateDtoMixin VaultaireFlowInput VaultaireModelDto VaultaireFlowInputForDependency VaultaireModelDtoMixin VaultaireGenerateResponder VaultaireFlowResponder Class and file names of generated state-based DTOs use new suffixes: LiteDto has changed to StateClientDto Dto has changed to StateDto DTO generation strategies have been updated: DEFAULT is now CORDAPP_LOCAL_DTO LITE is now CORDAPP_CLIENT_DTO The default DTO strategy is now CORDAPP_CLIENT_DTO This release also brings new features: VaultaireModelDto and VaultaireModelDtoMixin are now focused in DTO generation for non-state models. The resulting class and file name suffix is ModelClientDto with support for the usual REST or otherwise client-friendly auto-conversion of Corda-specific types. All DTO-generating annotations now have a views: Array<VaultaireView> member, to allow additional classes to be generated, each with a subset of fields from the target state or model type. All DTO-generating annotations now have a nonDataClass: Boolean member, that should be set to true for target state or model types that are NOT data classes.","title":"0.40"},{"location":"changelog/#039","text":"Added @VaultaireFlowInput and @VaultaireFlowInputForDependency to support generating REST-friendly DTOs and utils for non-state data classes.","title":"0.39"},{"location":"changelog/#038","text":"Minor accounts update","title":"0.38"},{"location":"changelog/#037","text":"RSQL support: removed =notnull= and refactored =null= to accept a boolean argument instead, according to the RSQL parser grammar.","title":"0.37"},{"location":"changelog/#036","text":"RSQL improvements: Fixed =in= , =out= comparisons. Moved wildcard-based comparisons to dedicated =like= and =unlike= operators. The converterFactory parameter in VaultQueryCriteriaCondition.withRsql is now optional.","title":"0.36"},{"location":"changelog/#035","text":"Added plugin for RSQL support.","title":"0.35"},{"location":"changelog/#034","text":"Support DTO-only fields with mixins.","title":"0.34"},{"location":"changelog/#033","text":"Upgraded to Corda 4.6, Partiture 0.15, Poolboy 0.4.","title":"0.33"},{"location":"changelog/#032","text":"Added VaultaireAttachmentService as a utility for attaching Vaultaire\u2019s JAR to a transaction.","title":"0.32"},{"location":"changelog/#031","text":"Updated corda-rpc-poolboy dependency.","title":"0.31"},{"location":"changelog/#030","text":"Reverted to forcing root state status to criteria as Corda seems to have an issue with StateStatus.ALL .","title":"0.30"},{"location":"changelog/#029","text":"Added ResultsPage as a REST-friendly alternative to Vault.Page combined with mapping from StateAndRef to either contract states or DTOs. Removed explicit state status from DSL criteria, applied root criterion last instead.","title":"0.29"},{"location":"changelog/#028","text":"Fixed generated DTOs missing @CordaSerializable . (Service) Registry is now more accessible. Fixed service defaults parameter type from SimpleServiceDefaults to interface ServiceDefaults in NodeService, StateService and delegates. Fixed pool-based initialization of services from network service.","title":"0.28"},{"location":"changelog/#026-27","text":"Bumped Corda to OS 4.5 Refactored to support RPC connection pooling based on Corda RPC PoolBoy","title":"0.26-27"},{"location":"changelog/#025","text":"Bumped Corda to OS 4.4 Added support for \u201clite\u201d DTO strategy Added Query DSL root externalIds property to support querying the vault by Corda Account(s)","title":"0.25"},{"location":"changelog/#024","text":"Added default parameter value false to VaultQueryCriteriaCondition.toCriteria(boolean) , so that aggregates are not ignored by default.","title":"0.24"},{"location":"changelog/#023","text":"Fixed corda API design issue, where a secondary VaultCustomQueryCriteria \u2018s implicit/default status of UNCONSUMED (VS null) is applied, overriding the root DSL status","title":"0.23"},{"location":"changelog/#022","text":"Bumped kotlin-utils, fixing issue with DTO generation including companion object members of the source type.","title":"0.22"},{"location":"changelog/#021","text":"Bumped KotlinPoet, util versions Added @DefaultValue example in the docs","title":"0.21"},{"location":"changelog/#020","text":"Added CordaSerializable annotation to generated DTOs Added ignoreProperties to VaultaireGenerateDto and VaultaireGenerateDtoForDependency , useful with derived/backed properties like participants","title":"0.20"},{"location":"changelog/#019","text":"Added [NodeRpcConnection] interface and [StateServiceRpcConnectionDelegate] for libraries in need of more flexible [StateServiceDelegate] integration e.g. Corbeans/Spring or other IoC containers","title":"0.19"},{"location":"changelog/#018","text":"Bumped deps i.e. Corda to OS 4.3","title":"0.18"},{"location":"changelog/#017","text":"Added support for sorting based on standard attributes and aliases of those, i.e. enum values of Sort.CommonStateAttribute , Sort.VaultStateAttribute , Sort.LinearStateAttribute and Sort.FungibleStateAttribute .","title":"0.17"},{"location":"changelog/#016","text":"Added copyAnnotationPackages property to VaultaireGenerateDto and VaultaireGenerateDtoForDependency . The property can be used to define a list of base packages for matching annotations to be copied automatically from a source ContractState to it\u2019s generated DTO. This is useful when replication of e.g. Jackson or Bean Validation annotations can be useful.","title":"0.16"},{"location":"changelog/#015","text":"Replaced com.github.manosbatsis.vaultaire.dto.Dto and com.github.manosbatsis.vaultaire.util.DtoInsufficientStateMappingException with kotlin-utils equivalents extracted there. You may need to update package/method names in your code if you make use of generated DTOs.","title":"0.15"},{"location":"changelog/#014","text":"Vaultaire\u2019s *ForDependency annotations now use the annotated element\u2019s package (suffixed with .generated ) for output. This leaves the original (state) packages exclusive to their modules if needed, avoiding when cordapp package conflicts while testing.","title":"0.14"},{"location":"changelog/#013","text":"Add support for final responder flow supertypes in VaultaireGenerateResponder","title":"0.13"},{"location":"changelog/#012","text":"Fixed dependency scope for kotlin-utils","title":"0.12"},{"location":"changelog/#011","text":"Added VaultaireGenerateDto , VaultaireGenerateDtoForDependency annotations for generating DTOs for contract states Added VaultaireGenerateResponder annotation for generating responder flows extending common supertypes Refactored to extract kotlin-utils","title":"0.11"},{"location":"changelog/#010","text":"Added @VaultaireGenerateForDependency to support generation (of DSL, Services etc.) for states contributed to the classpath by project dependencies Enhanced generated subclasses of ExtendedStateService with DSL-aware buildQuery , queryBy and trackBy Fixed typo from VaultaireGenerate.constractStateType to VaultaireGenerate.contractStateType","title":"0.10"},{"location":"changelog/#09","text":"0.8 re-release fix","title":"0.9"},{"location":"changelog/#08","text":"Allow annotation processing to generate code to another Gradle module or location using the kapt.kotlin.vaultaire.generated kapt argument, see installation docs.","title":"0.8"},{"location":"changelog/#07","text":"Fixed, improved and added tests for StateService get/find by id/externalId methods StateService get by id/externalId will throw a StateNotFoundException when no match is found","title":"0.7"},{"location":"changelog/#06","text":"Added support for aggregate functions . Added getByExternalId and findByExternalId methods to StateService Added optional Vault.RelevancyStatus parameter to StateService getByLinearId and findByLinearId methods","title":"0.6"},{"location":"changelog/#05","text":"Removed param from String.asUniqueIdentifier()","title":"0.5"},{"location":"changelog/#04","text":"Fixed handling of nullable fields Added string input signatures for getByLinearId , findByLinearId","title":"0.4"},{"location":"changelog/#03","text":"Refactored StateService to an interface","title":"0.3"},{"location":"changelog/#02","text":"Renamed VaultQueryDsl annotation to VaultaireGenerate Renamed StateService to BasicStateService , added extended StateService type. The annotation processor will now generate a subclass of StateService per annotated PersistentState","title":"0.2"},{"location":"changelog/#01","text":"Initial release","title":"0.1"},{"location":"credits/","text":"Credits \u00b6 The following projects where of great help in creating my first DSL: AutoDsl , SqlDsl . Annotation processing is of course based on KotlinPoet . The RSQL module depends on the lovely jirutka/rsql:rsql-parser .","title":"Credits"},{"location":"credits/#credits","text":"The following projects where of great help in creating my first DSL: AutoDsl , SqlDsl . Annotation processing is of course based on KotlinPoet . The RSQL module depends on the lovely jirutka/rsql:rsql-parser .","title":"Credits"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 Answers to common questions. License: Can I use Vaultaire with my project? \u00b6 Yes, Vaultaire can be used as a library/dependency with no side-effect to your project. Vaultaire is distributed under the GNU Lesser General Public License or LGPL, the same license adopted by Corda dependencies like Hibernate. Use with Corda Enterprise \u00b6 To use Vaultaire with Corda Enterprise, you will have to update your build to use the CE release . After switching to the appropriate corda_release_group and corda_release_version in your ext section, you can instruct your build to substitute transitive Corda OS dependencies with their CE equivalents: allprojects { //... configurations { all { //... resolutionStrategy { // ... eachDependency { DependencyResolveDetails details -> // Exclude from substitutions as appropriate, e.g. def exclusions = [ 'corda-finance-contracts' ] // Substitute the rest, assumes `ext.corda_release_group` and `ext.corda_release_version` are set if ( details . requested . group == \"net.corda\" && ! exclusions . contains ( details . requested . name )) { // Force Corda Enterprise details . useTarget group: corda_release_group , name: details . requested . name , version: corda_release_version } } } } } } Note : The above assumes ext.corda_release_group and ext.corda_release_version are already set, e.g. to com.r3.corda and 4.2 respectively.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"Answers to common questions.","title":"Frequently Asked Questions"},{"location":"faq/#license-can-i-use-vaultaire-with-my-project","text":"Yes, Vaultaire can be used as a library/dependency with no side-effect to your project. Vaultaire is distributed under the GNU Lesser General Public License or LGPL, the same license adopted by Corda dependencies like Hibernate.","title":"License: Can I use Vaultaire with my project?"},{"location":"faq/#use-with-corda-enterprise","text":"To use Vaultaire with Corda Enterprise, you will have to update your build to use the CE release . After switching to the appropriate corda_release_group and corda_release_version in your ext section, you can instruct your build to substitute transitive Corda OS dependencies with their CE equivalents: allprojects { //... configurations { all { //... resolutionStrategy { // ... eachDependency { DependencyResolveDetails details -> // Exclude from substitutions as appropriate, e.g. def exclusions = [ 'corda-finance-contracts' ] // Substitute the rest, assumes `ext.corda_release_group` and `ext.corda_release_version` are set if ( details . requested . group == \"net.corda\" && ! exclusions . contains ( details . requested . name )) { // Force Corda Enterprise details . useTarget group: corda_release_group , name: details . requested . name , version: corda_release_version } } } } } } Note : The above assumes ext.corda_release_group and ext.corda_release_version are already set, e.g. to com.r3.corda and 4.2 respectively.","title":"Use with Corda Enterprise"},{"location":"installation/","text":"Installation \u00b6 For Cordapps \u00b6 Step 1: Add to your Cordapp\u2019s Gradle dependencies: // apply the kapt plugin apply plugin: 'kotlin-kapt' // Optional: for IntelliJ users, see also sourceSets bellow apply plugin: \"idea\" dependencies { // Core dependency cordaCompile \"com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version\" // Annotation processing kapt \"com.github.manosbatsis.vaultaire:vaultaire-processor:$vaultaire_version\" // Corda dependencies etc. // ... } Alternatively, you might want to add Vaultaire in the Cordapp\u2019s fat JAR, in which case use compile instead of cordacompile and skip step 2 bellow. Step 2: Add Vaultaire and Kotlin Utils as Cordapps to your deployNodes task: // Use Vaultaire for query DSL, DTOs and services generation cordapp \"com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version\" cordapp ( \"com.github.manosbatsis.kotlin-utils:kotlin-utils-api:$kotlinutils_version\" ) Step 3: You may also want to add the generated sources to your build\u2019s sourceSets // Define an extra sources variable def generatedSourcesDir = project . file ( \"build/generated/source/kaptKotlin/main\" ) // Tell Gradle about the extra source set sourceSets { main { kotlin . srcDirs += generatedSourcesDir } } // Optional: Tell IntelliJ about the extra source set idea { module { sourceDirs += generatedSourcesDir generatedSourceDirs += generatedSourcesDir } } Note that setting kotlin.incremental=true in gradle.properties may break non-clean builds earlier versions of kotlin like 1.2.71 - if you enable incremental then you\u2019ll need to ./gradlew clean when building. For Client Apps \u00b6 The core module can also be useful outside a cordapp, e.g. in a Spring application interacting with Corda nodes via RPC: // Core dependency compile \"com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version\" // Corda dependencies etc. // ...","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#for-cordapps","text":"Step 1: Add to your Cordapp\u2019s Gradle dependencies: // apply the kapt plugin apply plugin: 'kotlin-kapt' // Optional: for IntelliJ users, see also sourceSets bellow apply plugin: \"idea\" dependencies { // Core dependency cordaCompile \"com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version\" // Annotation processing kapt \"com.github.manosbatsis.vaultaire:vaultaire-processor:$vaultaire_version\" // Corda dependencies etc. // ... } Alternatively, you might want to add Vaultaire in the Cordapp\u2019s fat JAR, in which case use compile instead of cordacompile and skip step 2 bellow. Step 2: Add Vaultaire and Kotlin Utils as Cordapps to your deployNodes task: // Use Vaultaire for query DSL, DTOs and services generation cordapp \"com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version\" cordapp ( \"com.github.manosbatsis.kotlin-utils:kotlin-utils-api:$kotlinutils_version\" ) Step 3: You may also want to add the generated sources to your build\u2019s sourceSets // Define an extra sources variable def generatedSourcesDir = project . file ( \"build/generated/source/kaptKotlin/main\" ) // Tell Gradle about the extra source set sourceSets { main { kotlin . srcDirs += generatedSourcesDir } } // Optional: Tell IntelliJ about the extra source set idea { module { sourceDirs += generatedSourcesDir generatedSourceDirs += generatedSourcesDir } } Note that setting kotlin.incremental=true in gradle.properties may break non-clean builds earlier versions of kotlin like 1.2.71 - if you enable incremental then you\u2019ll need to ./gradlew clean when building.","title":"For Cordapps"},{"location":"installation/#for-client-apps","text":"The core module can also be useful outside a cordapp, e.g. in a Spring application interacting with Corda nodes via RPC: // Core dependency compile \"com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version\" // Corda dependencies etc. // ...","title":"For Client Apps"},{"location":"0.x/","text":"Packages \u00b6 Name Summary com.github.manosbatsis.vaultaire.annotation com.github.manosbatsis.vaultaire.dsl.contract com.github.manosbatsis.vaultaire.dsl.query com.github.manosbatsis.vaultaire.dto com.github.manosbatsis.vaultaire.dto.attachment com.github.manosbatsis.vaultaire.dto.info com.github.manosbatsis.vaultaire.registry com.github.manosbatsis.vaultaire.service com.github.manosbatsis.vaultaire.service.dao com.github.manosbatsis.vaultaire.service.node com.github.manosbatsis.vaultaire.util Index \u00b6 All Types","title":"Index"},{"location":"0.x/#packages","text":"Name Summary com.github.manosbatsis.vaultaire.annotation com.github.manosbatsis.vaultaire.dsl.contract com.github.manosbatsis.vaultaire.dsl.query com.github.manosbatsis.vaultaire.dto com.github.manosbatsis.vaultaire.dto.attachment com.github.manosbatsis.vaultaire.dto.info com.github.manosbatsis.vaultaire.registry com.github.manosbatsis.vaultaire.service com.github.manosbatsis.vaultaire.service.dao com.github.manosbatsis.vaultaire.service.node com.github.manosbatsis.vaultaire.util","title":"Packages"},{"location":"0.x/#index","text":"All Types","title":"Index"},{"location":"0.x/alltypes/","text":"All Types \u00b6 Name Summary com.github.manosbatsis.vaultaire.service.node.AbstractNodeServiceHubDelegate ServiceHub -based NodeServiceDelegate implementation com.github.manosbatsis.vaultaire.dto.AccountParty Convenient \u201cparticipant\u201d type that combines a known Corda Account ID with a corresponding anonymous party. com.github.manosbatsis.vaultaire.dsl.query.Aggregates Used to define aggregation criteria com.github.manosbatsis.vaultaire.dsl.query.AndCondition Defines a set of conditions where all items must be matched com.github.manosbatsis.vaultaire.dto.attachment.Attachment Data transfer object representing an attachment to be persisted in the vault com.github.manosbatsis.vaultaire.dto.attachment.AttachmentFile Data transfer object representing an attachment file to be persisted in the vault com.github.manosbatsis.vaultaire.dto.attachment.AttachmentReceipt Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable. com.github.manosbatsis.vaultaire.service.node.BasicNodeService Basic NodeService implementation com.github.manosbatsis.vaultaire.service.dao.BasicStateService Basic StateService implementation, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.dsl.query.CompositeCondition A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. com.github.manosbatsis.vaultaire.dsl.query.Condition Condition interface com.github.manosbatsis.vaultaire.dsl.query.ConditionsCondition A Condition that contains other conditions. Allows for nested and/or condition groups com.github.manosbatsis.vaultaire.dsl.contract.ContractConditions com.github.manosbatsis.vaultaire.service.dao.DefaultExtendedStateService Extends BasicStateService to provide a StateService aware of the target ContractState type\u2019s StatePersistable and Fields . com.github.manosbatsis.vaultaire.util.DummyContract com.github.manosbatsis.vaultaire.dto.info.ExtendedNodeInfo com.github.manosbatsis.vaultaire.service.dao.ExtendedStateService com.github.manosbatsis.vaultaire.annotation.ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type com.github.manosbatsis.vaultaire.util.Fields Extended by Vaultaire\u2019s annotation processing to provide easy access to fields of a StatePersistable type com.github.manosbatsis.vaultaire.util.FieldWrapper com.github.manosbatsis.vaultaire.util.GenericFieldWrapper Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.dto.info.NetworkInfo com.github.manosbatsis.vaultaire.service.node.NodeCordaServiceDelegate Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService com.github.manosbatsis.vaultaire.service.node.NodeService Short-lived helper, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.service.node.NodeServiceDelegate NodeService delegate for vault operations com.github.manosbatsis.vaultaire.service.node.NodeServiceRpcPoolBoyDelegate RPC implementation base com.github.manosbatsis.vaultaire.service.node.NotFoundException com.github.manosbatsis.vaultaire.util.NullableGenericFieldWrapper Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.dsl.query.OrCondition Defines a set of conditions where at least a single item must be matched com.github.manosbatsis.vaultaire.registry.Registry com.github.manosbatsis.vaultaire.util.ResultsPage A wrapper for page results. Typically used as a more REST-friendly alternative to Vault.Page combined with mapping to states or DTOs. com.github.manosbatsis.vaultaire.dsl.query.RootCondition com.github.manosbatsis.vaultaire.service.ServiceDefaults com.github.manosbatsis.vaultaire.service.SimpleServiceDefaults Define option defaults for StateService instances com.github.manosbatsis.vaultaire.dsl.query.SortColumns Used to define Sort.SortColumn s com.github.manosbatsis.vaultaire.service.dao.StateCordaServiceDelegate Implementation of StateServiceDelegate as a CordaService com.github.manosbatsis.vaultaire.service.dao.StateService Short-lived helper, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.service.dao.StateServiceDelegate StateService delegate for vault operations com.github.manosbatsis.vaultaire.service.dao.StateServiceHubDelegate ServiceHub -based StateServiceDelegate implementation com.github.manosbatsis.vaultaire.service.dao.StateServicePoolBoyDelegate com.github.manosbatsis.vaultaire.service.dao.StateServiceRpcConnectionDelegate NodeRpcConnection -based StateServiceDelegate implementation kotlin.String (extensions in package com.github.manosbatsis.vaultaire.util) com.github.manosbatsis.vaultaire.dsl.query.TimeConsumedCondition com.github.manosbatsis.vaultaire.dsl.query.TimeInstantTypeCondition com.github.manosbatsis.vaultaire.dsl.query.TimeRecordedCondition com.github.manosbatsis.vaultaire.util.TypedFieldWrapper Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.annotation.VaultaireAccountInfo Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty . com.github.manosbatsis.vaultaire.service.VaultaireAttachmentService com.github.manosbatsis.vaultaire.dto.VaultaireBaseStateClientDto Base interface for client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched . com.github.manosbatsis.vaultaire.annotation.VaultaireDependencyAnnotationConvention com.github.manosbatsis.vaultaire.dto.VaultaireDto Implemented by DTOs with no support for type conversion com.github.manosbatsis.vaultaire.dto.VaultaireDtoBase com.github.manosbatsis.vaultaire.annotation.VaultaireDtoStrategyKeys com.github.manosbatsis.vaultaire.annotation.VaultaireFlowResponder Generate a responser flow that extends the given type. com.github.manosbatsis.vaultaire.dto.VaultaireModelClientDto Implemented by client, REST-friendly DTOs targeting model classes, i.e. non-ContractState types, with type conversion support using a NodeService for toTargetType and toPatched . com.github.manosbatsis.vaultaire.annotation.VaultaireModelDto Generate a REST-friendly DTO for the annotated input model class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireModelDtoMixin Generate a REST-friendly DTO for the target baseType input model class of a project dependency. com.github.manosbatsis.vaultaire.dto.VaultaireStateClientDto Implemented by client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched . com.github.manosbatsis.vaultaire.annotation.VaultaireStateDto Generate a DTO for the annotated ContractState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireStateDtoMixin Generate a DTO for the ContractState of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireStateUtils Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for the annotated PersistentState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireStateUtilsMixin Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for a target PersistentState and ContractState pair of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireView com.github.manosbatsis.vaultaire.annotation.VaultaireViewField com.github.manosbatsis.vaultaire.annotation.VaultaireViews com.github.manosbatsis.vaultaire.dsl.query.VaultCustomQueryCondition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. com.github.manosbatsis.vaultaire.dsl.query.VaultQueryCriteriaCondition A ConditionsCondition extended by Vaultaire\u2019s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort com.github.manosbatsis.vaultaire.util.ViewField com.github.manosbatsis.vaultaire.dsl.contract.When","title":"Index"},{"location":"0.x/alltypes/#all-types","text":"Name Summary com.github.manosbatsis.vaultaire.service.node.AbstractNodeServiceHubDelegate ServiceHub -based NodeServiceDelegate implementation com.github.manosbatsis.vaultaire.dto.AccountParty Convenient \u201cparticipant\u201d type that combines a known Corda Account ID with a corresponding anonymous party. com.github.manosbatsis.vaultaire.dsl.query.Aggregates Used to define aggregation criteria com.github.manosbatsis.vaultaire.dsl.query.AndCondition Defines a set of conditions where all items must be matched com.github.manosbatsis.vaultaire.dto.attachment.Attachment Data transfer object representing an attachment to be persisted in the vault com.github.manosbatsis.vaultaire.dto.attachment.AttachmentFile Data transfer object representing an attachment file to be persisted in the vault com.github.manosbatsis.vaultaire.dto.attachment.AttachmentReceipt Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable. com.github.manosbatsis.vaultaire.service.node.BasicNodeService Basic NodeService implementation com.github.manosbatsis.vaultaire.service.dao.BasicStateService Basic StateService implementation, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.dsl.query.CompositeCondition A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. com.github.manosbatsis.vaultaire.dsl.query.Condition Condition interface com.github.manosbatsis.vaultaire.dsl.query.ConditionsCondition A Condition that contains other conditions. Allows for nested and/or condition groups com.github.manosbatsis.vaultaire.dsl.contract.ContractConditions com.github.manosbatsis.vaultaire.service.dao.DefaultExtendedStateService Extends BasicStateService to provide a StateService aware of the target ContractState type\u2019s StatePersistable and Fields . com.github.manosbatsis.vaultaire.util.DummyContract com.github.manosbatsis.vaultaire.dto.info.ExtendedNodeInfo com.github.manosbatsis.vaultaire.service.dao.ExtendedStateService com.github.manosbatsis.vaultaire.annotation.ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type com.github.manosbatsis.vaultaire.util.Fields Extended by Vaultaire\u2019s annotation processing to provide easy access to fields of a StatePersistable type com.github.manosbatsis.vaultaire.util.FieldWrapper com.github.manosbatsis.vaultaire.util.GenericFieldWrapper Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.dto.info.NetworkInfo com.github.manosbatsis.vaultaire.service.node.NodeCordaServiceDelegate Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService com.github.manosbatsis.vaultaire.service.node.NodeService Short-lived helper, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.service.node.NodeServiceDelegate NodeService delegate for vault operations com.github.manosbatsis.vaultaire.service.node.NodeServiceRpcPoolBoyDelegate RPC implementation base com.github.manosbatsis.vaultaire.service.node.NotFoundException com.github.manosbatsis.vaultaire.util.NullableGenericFieldWrapper Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.dsl.query.OrCondition Defines a set of conditions where at least a single item must be matched com.github.manosbatsis.vaultaire.registry.Registry com.github.manosbatsis.vaultaire.util.ResultsPage A wrapper for page results. Typically used as a more REST-friendly alternative to Vault.Page combined with mapping to states or DTOs. com.github.manosbatsis.vaultaire.dsl.query.RootCondition com.github.manosbatsis.vaultaire.service.ServiceDefaults com.github.manosbatsis.vaultaire.service.SimpleServiceDefaults Define option defaults for StateService instances com.github.manosbatsis.vaultaire.dsl.query.SortColumns Used to define Sort.SortColumn s com.github.manosbatsis.vaultaire.service.dao.StateCordaServiceDelegate Implementation of StateServiceDelegate as a CordaService com.github.manosbatsis.vaultaire.service.dao.StateService Short-lived helper, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.service.dao.StateServiceDelegate StateService delegate for vault operations com.github.manosbatsis.vaultaire.service.dao.StateServiceHubDelegate ServiceHub -based StateServiceDelegate implementation com.github.manosbatsis.vaultaire.service.dao.StateServicePoolBoyDelegate com.github.manosbatsis.vaultaire.service.dao.StateServiceRpcConnectionDelegate NodeRpcConnection -based StateServiceDelegate implementation kotlin.String (extensions in package com.github.manosbatsis.vaultaire.util) com.github.manosbatsis.vaultaire.dsl.query.TimeConsumedCondition com.github.manosbatsis.vaultaire.dsl.query.TimeInstantTypeCondition com.github.manosbatsis.vaultaire.dsl.query.TimeRecordedCondition com.github.manosbatsis.vaultaire.util.TypedFieldWrapper Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.annotation.VaultaireAccountInfo Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty . com.github.manosbatsis.vaultaire.service.VaultaireAttachmentService com.github.manosbatsis.vaultaire.dto.VaultaireBaseStateClientDto Base interface for client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched . com.github.manosbatsis.vaultaire.annotation.VaultaireDependencyAnnotationConvention com.github.manosbatsis.vaultaire.dto.VaultaireDto Implemented by DTOs with no support for type conversion com.github.manosbatsis.vaultaire.dto.VaultaireDtoBase com.github.manosbatsis.vaultaire.annotation.VaultaireDtoStrategyKeys com.github.manosbatsis.vaultaire.annotation.VaultaireFlowResponder Generate a responser flow that extends the given type. com.github.manosbatsis.vaultaire.dto.VaultaireModelClientDto Implemented by client, REST-friendly DTOs targeting model classes, i.e. non-ContractState types, with type conversion support using a NodeService for toTargetType and toPatched . com.github.manosbatsis.vaultaire.annotation.VaultaireModelDto Generate a REST-friendly DTO for the annotated input model class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireModelDtoMixin Generate a REST-friendly DTO for the target baseType input model class of a project dependency. com.github.manosbatsis.vaultaire.dto.VaultaireStateClientDto Implemented by client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched . com.github.manosbatsis.vaultaire.annotation.VaultaireStateDto Generate a DTO for the annotated ContractState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireStateDtoMixin Generate a DTO for the ContractState of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireStateUtils Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for the annotated PersistentState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireStateUtilsMixin Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for a target PersistentState and ContractState pair of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireView com.github.manosbatsis.vaultaire.annotation.VaultaireViewField com.github.manosbatsis.vaultaire.annotation.VaultaireViews com.github.manosbatsis.vaultaire.dsl.query.VaultCustomQueryCondition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. com.github.manosbatsis.vaultaire.dsl.query.VaultQueryCriteriaCondition A ConditionsCondition extended by Vaultaire\u2019s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort com.github.manosbatsis.vaultaire.util.ViewField com.github.manosbatsis.vaultaire.dsl.contract.When","title":"All Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/","text":"com.github.manosbatsis.vaultaire.annotation Package com.github.manosbatsis.vaultaire.annotation \u00b6 Types \u00b6 Name Summary VaultaireDependencyAnnotationConvention interface VaultaireDependencyAnnotationConvention VaultaireDtoStrategyKeys enum class VaultaireDtoStrategyKeys Annotations \u00b6 Name Summary ExtendedStateServiceBean annotation class ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type VaultaireAccountInfo annotation class VaultaireAccountInfo Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty . VaultaireFlowResponder annotation class VaultaireFlowResponder Generate a responser flow that extends the given type. VaultaireModelDto annotation class VaultaireModelDto Generate a REST-friendly DTO for the annotated input model class or constructor. VaultaireModelDtoMixin annotation class VaultaireModelDtoMixin Generate a REST-friendly DTO for the target baseType input model class of a project dependency. VaultaireStateDto annotation class VaultaireStateDto Generate a DTO for the annotated ContractState class or constructor. VaultaireStateDtoMixin annotation class VaultaireStateDtoMixin Generate a DTO for the ContractState of a project dependency. VaultaireStateUtils annotation class VaultaireStateUtils Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for the annotated PersistentState class or constructor. VaultaireStateUtilsMixin annotation class VaultaireStateUtilsMixin Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for a target PersistentState and ContractState pair of a project dependency. VaultaireView annotation class VaultaireView VaultaireViewField annotation class VaultaireViewField VaultaireViews annotation class VaultaireViews","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/#package-comgithubmanosbatsisvaultaireannotation","text":"","title":"Package com.github.manosbatsis.vaultaire.annotation"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/#types","text":"Name Summary VaultaireDependencyAnnotationConvention interface VaultaireDependencyAnnotationConvention VaultaireDtoStrategyKeys enum class VaultaireDtoStrategyKeys","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/#annotations","text":"Name Summary ExtendedStateServiceBean annotation class ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type VaultaireAccountInfo annotation class VaultaireAccountInfo Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty . VaultaireFlowResponder annotation class VaultaireFlowResponder Generate a responser flow that extends the given type. VaultaireModelDto annotation class VaultaireModelDto Generate a REST-friendly DTO for the annotated input model class or constructor. VaultaireModelDtoMixin annotation class VaultaireModelDtoMixin Generate a REST-friendly DTO for the target baseType input model class of a project dependency. VaultaireStateDto annotation class VaultaireStateDto Generate a DTO for the annotated ContractState class or constructor. VaultaireStateDtoMixin annotation class VaultaireStateDtoMixin Generate a DTO for the ContractState of a project dependency. VaultaireStateUtils annotation class VaultaireStateUtils Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for the annotated PersistentState class or constructor. VaultaireStateUtilsMixin annotation class VaultaireStateUtilsMixin Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for a target PersistentState and ContractState pair of a project dependency. VaultaireView annotation class VaultaireView VaultaireViewField annotation class VaultaireViewField VaultaireViews annotation class VaultaireViews","title":"Annotations"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/","text":"com.github.manosbatsis.vaultaire.annotation / ExtendedStateServiceBean ExtendedStateServiceBean \u00b6 @Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type Constructors \u00b6 Name Summary <init> ExtendedStateServiceBean() Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/#extendedstateservicebean","text":"@Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":"ExtendedStateServiceBean"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/#constructors","text":"Name Summary <init> ExtendedStateServiceBean() Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / ExtendedStateServiceBean / <init> <init> \u00b6 ExtendedStateServiceBean() Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/-init-/#init","text":"ExtendedStateServiceBean() Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-account-info/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireAccountInfo VaultaireAccountInfo \u00b6 @Target([AnnotationTarget.FIELD, AnnotationTarget.PROPERTY]) annotation class VaultaireAccountInfo Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty . Constructors \u00b6 Name Summary <init> VaultaireAccountInfo() Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty .","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-account-info/#vaultaireaccountinfo","text":"@Target([AnnotationTarget.FIELD, AnnotationTarget.PROPERTY]) annotation class VaultaireAccountInfo Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty .","title":"VaultaireAccountInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-account-info/#constructors","text":"Name Summary <init> VaultaireAccountInfo() Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty .","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-account-info/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireAccountInfo / <init> <init> \u00b6 VaultaireAccountInfo() Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty .","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-account-info/-init-/#init","text":"VaultaireAccountInfo() Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty .","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDependencyAnnotationConvention VaultaireDependencyAnnotationConvention \u00b6 interface VaultaireDependencyAnnotationConvention Properties \u00b6 Name Summary contractStateType abstract val contractStateType: KClass<out ContractState> persistentStateType abstract val persistentStateType: KClass<out PersistentState>","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/#vaultairedependencyannotationconvention","text":"interface VaultaireDependencyAnnotationConvention","title":"VaultaireDependencyAnnotationConvention"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/#properties","text":"Name Summary contractStateType abstract val contractStateType: KClass<out ContractState> persistentStateType abstract val persistentStateType: KClass<out PersistentState>","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDependencyAnnotationConvention / contractStateType contractStateType \u00b6 abstract val contractStateType: KClass<out ContractState>","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/contract-state-type/#contractstatetype","text":"abstract val contractStateType: KClass<out ContractState>","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/persistent-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDependencyAnnotationConvention / persistentStateType persistentStateType \u00b6 abstract val persistentStateType: KClass<out PersistentState>","title":"Persistent state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/persistent-state-type/#persistentstatetype","text":"abstract val persistentStateType: KClass<out PersistentState>","title":"persistentStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys VaultaireDtoStrategyKeys \u00b6 enum class VaultaireDtoStrategyKeys Enum Values \u00b6 Name Summary CORDAPP_LOCAL_DTO For ContractState -based DTOs without any type conversions CORDAPP_CLIENT_DTO For ContractState -based DTOs with REST or otherwise client-friendly type conversions Properties \u00b6 Name Summary classNameSuffix val classNameSuffix: String Functions \u00b6 Name Summary toString fun toString(): String Companion Object Functions \u00b6 Name Summary findFromString fun findFromString(s: String): VaultaireDtoStrategyKeys ? getFromString fun getFromString(s: String): VaultaireDtoStrategyKeys","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/#vaultairedtostrategykeys","text":"enum class VaultaireDtoStrategyKeys","title":"VaultaireDtoStrategyKeys"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/#enum-values","text":"Name Summary CORDAPP_LOCAL_DTO For ContractState -based DTOs without any type conversions CORDAPP_CLIENT_DTO For ContractState -based DTOs with REST or otherwise client-friendly type conversions","title":"Enum Values"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/#properties","text":"Name Summary classNameSuffix val classNameSuffix: String","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/#functions","text":"Name Summary toString fun toString(): String","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/#companion-object-functions","text":"Name Summary findFromString fun findFromString(s: String): VaultaireDtoStrategyKeys ? getFromString fun getFromString(s: String): VaultaireDtoStrategyKeys","title":"Companion Object Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-c-o-r-d-a-p-p_-c-l-i-e-n-t_-d-t-o/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys / CORDAPP_CLIENT_DTO CORDAPP_CLIENT_DTO \u00b6 CORDAPP_CLIENT_DTO For ContractState -based DTOs with REST or otherwise client-friendly type conversions Inherited Properties \u00b6 Name Summary classNameSuffix val classNameSuffix: String Inherited Functions \u00b6 Name Summary toString fun toString(): String","title":" c o r d a p p  c l i e n t  d t o"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-c-o-r-d-a-p-p_-c-l-i-e-n-t_-d-t-o/#cordapp_client_dto","text":"CORDAPP_CLIENT_DTO For ContractState -based DTOs with REST or otherwise client-friendly type conversions","title":"CORDAPP_CLIENT_DTO"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-c-o-r-d-a-p-p_-c-l-i-e-n-t_-d-t-o/#inherited-properties","text":"Name Summary classNameSuffix val classNameSuffix: String","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-c-o-r-d-a-p-p_-c-l-i-e-n-t_-d-t-o/#inherited-functions","text":"Name Summary toString fun toString(): String","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-c-o-r-d-a-p-p_-l-o-c-a-l_-d-t-o/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys / CORDAPP_LOCAL_DTO CORDAPP_LOCAL_DTO \u00b6 CORDAPP_LOCAL_DTO For ContractState -based DTOs without any type conversions Inherited Properties \u00b6 Name Summary classNameSuffix val classNameSuffix: String Inherited Functions \u00b6 Name Summary toString fun toString(): String","title":" c o r d a p p  l o c a l  d t o"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-c-o-r-d-a-p-p_-l-o-c-a-l_-d-t-o/#cordapp_local_dto","text":"CORDAPP_LOCAL_DTO For ContractState -based DTOs without any type conversions","title":"CORDAPP_LOCAL_DTO"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-c-o-r-d-a-p-p_-l-o-c-a-l_-d-t-o/#inherited-properties","text":"Name Summary classNameSuffix val classNameSuffix: String","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-c-o-r-d-a-p-p_-l-o-c-a-l_-d-t-o/#inherited-functions","text":"Name Summary toString fun toString(): String","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/class-name-suffix/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys / classNameSuffix classNameSuffix \u00b6 val classNameSuffix: String","title":"Class name suffix"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/class-name-suffix/#classnamesuffix","text":"val classNameSuffix: String","title":"classNameSuffix"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/find-from-string/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys / findFromString findFromString \u00b6 fun findFromString(s: String): VaultaireDtoStrategyKeys ?","title":"Find from string"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/find-from-string/#findfromstring","text":"fun findFromString(s: String): VaultaireDtoStrategyKeys ?","title":"findFromString"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/get-from-string/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys / getFromString getFromString \u00b6 fun getFromString(s: String): VaultaireDtoStrategyKeys","title":"Get from string"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/get-from-string/#getfromstring","text":"fun getFromString(s: String): VaultaireDtoStrategyKeys","title":"getFromString"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/to-string/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys / toString toString \u00b6 fun toString(): String","title":"To string"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/to-string/#tostring","text":"fun toString(): String","title":"toString"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-flow-responder/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireFlowResponder VaultaireFlowResponder \u00b6 @Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireFlowResponder Generate a responser flow that extends the given type. Constructors \u00b6 Name Summary <init> VaultaireFlowResponder(value: KClass<out FlowLogic<*>>, comment: String = \"\") Generate a responser flow that extends the given type. Properties \u00b6 Name Summary comment val comment: String value val value: KClass<out FlowLogic<*>>","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-flow-responder/#vaultaireflowresponder","text":"@Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireFlowResponder Generate a responser flow that extends the given type.","title":"VaultaireFlowResponder"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-flow-responder/#constructors","text":"Name Summary <init> VaultaireFlowResponder(value: KClass<out FlowLogic<*>>, comment: String = \"\") Generate a responser flow that extends the given type.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-flow-responder/#properties","text":"Name Summary comment val comment: String value val value: KClass<out FlowLogic<*>>","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-flow-responder/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireFlowResponder / <init> <init> \u00b6 VaultaireFlowResponder(value: KClass<out FlowLogic<*>>, comment: String = \"\") Generate a responser flow that extends the given type.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-flow-responder/-init-/#init","text":"VaultaireFlowResponder(value: KClass<out FlowLogic<*>>, comment: String = \"\") Generate a responser flow that extends the given type.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-flow-responder/comment/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireFlowResponder / comment comment \u00b6 val comment: String","title":"Comment"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-flow-responder/comment/#comment","text":"val comment: String","title":"comment"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-flow-responder/value/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireFlowResponder / value value \u00b6 val value: KClass<out FlowLogic<*>>","title":"Value"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-flow-responder/value/#value","text":"val value: KClass<out FlowLogic<*>>","title":"value"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDto VaultaireModelDto \u00b6 @Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireModelDto Generate a REST-friendly DTO for the annotated input model class or constructor. Constructors \u00b6 Name Summary <init> VaultaireModelDto(ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a REST-friendly DTO for the annotated input model class or constructor. Properties \u00b6 Name Summary copyAnnotationPackages val copyAnnotationPackages: Array<String> ignoreProperties val ignoreProperties: Array<String> includeParticipants val includeParticipants: Boolean nonDataClass val nonDataClass: Boolean views val views: Array< VaultaireView >","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/#vaultairemodeldto","text":"@Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireModelDto Generate a REST-friendly DTO for the annotated input model class or constructor.","title":"VaultaireModelDto"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/#constructors","text":"Name Summary <init> VaultaireModelDto(ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a REST-friendly DTO for the annotated input model class or constructor.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/#properties","text":"Name Summary copyAnnotationPackages val copyAnnotationPackages: Array<String> ignoreProperties val ignoreProperties: Array<String> includeParticipants val includeParticipants: Boolean nonDataClass val nonDataClass: Boolean views val views: Array< VaultaireView >","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDto / <init> <init> \u00b6 VaultaireModelDto(ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a REST-friendly DTO for the annotated input model class or constructor.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/-init-/#init","text":"VaultaireModelDto(ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a REST-friendly DTO for the annotated input model class or constructor.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/copy-annotation-packages/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDto / copyAnnotationPackages copyAnnotationPackages \u00b6 val copyAnnotationPackages: Array<String>","title":"Copy annotation packages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/copy-annotation-packages/#copyannotationpackages","text":"val copyAnnotationPackages: Array<String>","title":"copyAnnotationPackages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/ignore-properties/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDto / ignoreProperties ignoreProperties \u00b6 val ignoreProperties: Array<String>","title":"Ignore properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/ignore-properties/#ignoreproperties","text":"val ignoreProperties: Array<String>","title":"ignoreProperties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/include-participants/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDto / includeParticipants includeParticipants \u00b6 val includeParticipants: Boolean","title":"Include participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/include-participants/#includeparticipants","text":"val includeParticipants: Boolean","title":"includeParticipants"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/non-data-class/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDto / nonDataClass nonDataClass \u00b6 val nonDataClass: Boolean","title":"Non data class"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/non-data-class/#nondataclass","text":"val nonDataClass: Boolean","title":"nonDataClass"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/views/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDto / views views \u00b6 val views: Array< VaultaireView >","title":"Views"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto/views/#views","text":"val views: Array< VaultaireView >","title":"views"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDtoMixin VaultaireModelDtoMixin \u00b6 @Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireModelDtoMixin Generate a REST-friendly DTO for the target baseType input model class of a project dependency. Constructors \u00b6 Name Summary <init> VaultaireModelDtoMixin(ignoreProperties: Array<String> = [], baseType: KClass<out Any>, copyAnnotationPackages: Array<String> = [], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a REST-friendly DTO for the target baseType input model class of a project dependency. Properties \u00b6 Name Summary baseType val baseType: KClass<out Any> copyAnnotationPackages val copyAnnotationPackages: Array<String> ignoreProperties val ignoreProperties: Array<String> includeParticipants val includeParticipants: Boolean nonDataClass val nonDataClass: Boolean views val views: Array< VaultaireView >","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/#vaultairemodeldtomixin","text":"@Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireModelDtoMixin Generate a REST-friendly DTO for the target baseType input model class of a project dependency.","title":"VaultaireModelDtoMixin"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/#constructors","text":"Name Summary <init> VaultaireModelDtoMixin(ignoreProperties: Array<String> = [], baseType: KClass<out Any>, copyAnnotationPackages: Array<String> = [], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a REST-friendly DTO for the target baseType input model class of a project dependency.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/#properties","text":"Name Summary baseType val baseType: KClass<out Any> copyAnnotationPackages val copyAnnotationPackages: Array<String> ignoreProperties val ignoreProperties: Array<String> includeParticipants val includeParticipants: Boolean nonDataClass val nonDataClass: Boolean views val views: Array< VaultaireView >","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDtoMixin / <init> <init> \u00b6 VaultaireModelDtoMixin(ignoreProperties: Array<String> = [], baseType: KClass<out Any>, copyAnnotationPackages: Array<String> = [], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a REST-friendly DTO for the target baseType input model class of a project dependency.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/-init-/#init","text":"VaultaireModelDtoMixin(ignoreProperties: Array<String> = [], baseType: KClass<out Any>, copyAnnotationPackages: Array<String> = [], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a REST-friendly DTO for the target baseType input model class of a project dependency.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/base-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDtoMixin / baseType baseType \u00b6 val baseType: KClass<out Any>","title":"Base type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/base-type/#basetype","text":"val baseType: KClass<out Any>","title":"baseType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/copy-annotation-packages/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDtoMixin / copyAnnotationPackages copyAnnotationPackages \u00b6 val copyAnnotationPackages: Array<String>","title":"Copy annotation packages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/copy-annotation-packages/#copyannotationpackages","text":"val copyAnnotationPackages: Array<String>","title":"copyAnnotationPackages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/ignore-properties/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDtoMixin / ignoreProperties ignoreProperties \u00b6 val ignoreProperties: Array<String>","title":"Ignore properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/ignore-properties/#ignoreproperties","text":"val ignoreProperties: Array<String>","title":"ignoreProperties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/include-participants/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDtoMixin / includeParticipants includeParticipants \u00b6 val includeParticipants: Boolean","title":"Include participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/include-participants/#includeparticipants","text":"val includeParticipants: Boolean","title":"includeParticipants"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/non-data-class/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDtoMixin / nonDataClass nonDataClass \u00b6 val nonDataClass: Boolean","title":"Non data class"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/non-data-class/#nondataclass","text":"val nonDataClass: Boolean","title":"nonDataClass"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/views/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireModelDtoMixin / views views \u00b6 val views: Array< VaultaireView >","title":"Views"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-model-dto-mixin/views/#views","text":"val views: Array< VaultaireView >","title":"views"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDto VaultaireStateDto \u00b6 @Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireStateDto Generate a DTO for the annotated ContractState class or constructor. Constructors \u00b6 Name Summary <init> VaultaireStateDto(ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], strategies: Array< VaultaireDtoStrategyKeys > = [VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a DTO for the annotated ContractState class or constructor. Properties \u00b6 Name Summary copyAnnotationPackages val copyAnnotationPackages: Array<String> ignoreProperties val ignoreProperties: Array<String> includeParticipants val includeParticipants: Boolean nonDataClass val nonDataClass: Boolean strategies val strategies: Array< VaultaireDtoStrategyKeys > views val views: Array< VaultaireView >","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/#vaultairestatedto","text":"@Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireStateDto Generate a DTO for the annotated ContractState class or constructor.","title":"VaultaireStateDto"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/#constructors","text":"Name Summary <init> VaultaireStateDto(ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], strategies: Array< VaultaireDtoStrategyKeys > = [VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a DTO for the annotated ContractState class or constructor.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/#properties","text":"Name Summary copyAnnotationPackages val copyAnnotationPackages: Array<String> ignoreProperties val ignoreProperties: Array<String> includeParticipants val includeParticipants: Boolean nonDataClass val nonDataClass: Boolean strategies val strategies: Array< VaultaireDtoStrategyKeys > views val views: Array< VaultaireView >","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDto / <init> <init> \u00b6 VaultaireStateDto(ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], strategies: Array< VaultaireDtoStrategyKeys > = [VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a DTO for the annotated ContractState class or constructor.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/-init-/#init","text":"VaultaireStateDto(ignoreProperties: Array<String> = [], copyAnnotationPackages: Array<String> = [], strategies: Array< VaultaireDtoStrategyKeys > = [VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a DTO for the annotated ContractState class or constructor.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/copy-annotation-packages/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDto / copyAnnotationPackages copyAnnotationPackages \u00b6 val copyAnnotationPackages: Array<String>","title":"Copy annotation packages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/copy-annotation-packages/#copyannotationpackages","text":"val copyAnnotationPackages: Array<String>","title":"copyAnnotationPackages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/ignore-properties/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDto / ignoreProperties ignoreProperties \u00b6 val ignoreProperties: Array<String>","title":"Ignore properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/ignore-properties/#ignoreproperties","text":"val ignoreProperties: Array<String>","title":"ignoreProperties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/include-participants/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDto / includeParticipants includeParticipants \u00b6 val includeParticipants: Boolean","title":"Include participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/include-participants/#includeparticipants","text":"val includeParticipants: Boolean","title":"includeParticipants"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/non-data-class/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDto / nonDataClass nonDataClass \u00b6 val nonDataClass: Boolean","title":"Non data class"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/non-data-class/#nondataclass","text":"val nonDataClass: Boolean","title":"nonDataClass"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/strategies/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDto / strategies strategies \u00b6 val strategies: Array< VaultaireDtoStrategyKeys >","title":"Strategies"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/strategies/#strategies","text":"val strategies: Array< VaultaireDtoStrategyKeys >","title":"strategies"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/views/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDto / views views \u00b6 val views: Array< VaultaireView >","title":"Views"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto/views/#views","text":"val views: Array< VaultaireView >","title":"views"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDtoMixin VaultaireStateDtoMixin \u00b6 @Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireStateDtoMixin Generate a DTO for the ContractState of a project dependency. Constructors \u00b6 Name Summary <init> VaultaireStateDtoMixin(ignoreProperties: Array<String> = [], contractStateType: KClass<out ContractState>, persistentStateType: KClass<out PersistentState>, copyAnnotationPackages: Array<String> = [], strategies: Array< VaultaireDtoStrategyKeys > = [VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a DTO for the ContractState of a project dependency. Properties \u00b6 Name Summary contractStateType val contractStateType: KClass<out ContractState> copyAnnotationPackages val copyAnnotationPackages: Array<String> ignoreProperties val ignoreProperties: Array<String> includeParticipants val includeParticipants: Boolean nonDataClass val nonDataClass: Boolean persistentStateType val persistentStateType: KClass<out PersistentState> strategies val strategies: Array< VaultaireDtoStrategyKeys > views val views: Array< VaultaireView >","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/#vaultairestatedtomixin","text":"@Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireStateDtoMixin Generate a DTO for the ContractState of a project dependency.","title":"VaultaireStateDtoMixin"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/#constructors","text":"Name Summary <init> VaultaireStateDtoMixin(ignoreProperties: Array<String> = [], contractStateType: KClass<out ContractState>, persistentStateType: KClass<out PersistentState>, copyAnnotationPackages: Array<String> = [], strategies: Array< VaultaireDtoStrategyKeys > = [VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a DTO for the ContractState of a project dependency.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/#properties","text":"Name Summary contractStateType val contractStateType: KClass<out ContractState> copyAnnotationPackages val copyAnnotationPackages: Array<String> ignoreProperties val ignoreProperties: Array<String> includeParticipants val includeParticipants: Boolean nonDataClass val nonDataClass: Boolean persistentStateType val persistentStateType: KClass<out PersistentState> strategies val strategies: Array< VaultaireDtoStrategyKeys > views val views: Array< VaultaireView >","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDtoMixin / <init> <init> \u00b6 VaultaireStateDtoMixin(ignoreProperties: Array<String> = [], contractStateType: KClass<out ContractState>, persistentStateType: KClass<out PersistentState>, copyAnnotationPackages: Array<String> = [], strategies: Array< VaultaireDtoStrategyKeys > = [VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a DTO for the ContractState of a project dependency.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/-init-/#init","text":"VaultaireStateDtoMixin(ignoreProperties: Array<String> = [], contractStateType: KClass<out ContractState>, persistentStateType: KClass<out PersistentState>, copyAnnotationPackages: Array<String> = [], strategies: Array< VaultaireDtoStrategyKeys > = [VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO], views: Array< VaultaireView > = [], includeParticipants: Boolean = false, nonDataClass: Boolean = false) Generate a DTO for the ContractState of a project dependency.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDtoMixin / contractStateType contractStateType \u00b6 val contractStateType: KClass<out ContractState>","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/contract-state-type/#contractstatetype","text":"val contractStateType: KClass<out ContractState>","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/copy-annotation-packages/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDtoMixin / copyAnnotationPackages copyAnnotationPackages \u00b6 val copyAnnotationPackages: Array<String>","title":"Copy annotation packages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/copy-annotation-packages/#copyannotationpackages","text":"val copyAnnotationPackages: Array<String>","title":"copyAnnotationPackages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/ignore-properties/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDtoMixin / ignoreProperties ignoreProperties \u00b6 val ignoreProperties: Array<String>","title":"Ignore properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/ignore-properties/#ignoreproperties","text":"val ignoreProperties: Array<String>","title":"ignoreProperties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/include-participants/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDtoMixin / includeParticipants includeParticipants \u00b6 val includeParticipants: Boolean","title":"Include participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/include-participants/#includeparticipants","text":"val includeParticipants: Boolean","title":"includeParticipants"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/non-data-class/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDtoMixin / nonDataClass nonDataClass \u00b6 val nonDataClass: Boolean","title":"Non data class"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/non-data-class/#nondataclass","text":"val nonDataClass: Boolean","title":"nonDataClass"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/persistent-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDtoMixin / persistentStateType persistentStateType \u00b6 val persistentStateType: KClass<out PersistentState>","title":"Persistent state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/persistent-state-type/#persistentstatetype","text":"val persistentStateType: KClass<out PersistentState>","title":"persistentStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/strategies/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDtoMixin / strategies strategies \u00b6 val strategies: Array< VaultaireDtoStrategyKeys >","title":"Strategies"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/strategies/#strategies","text":"val strategies: Array< VaultaireDtoStrategyKeys >","title":"strategies"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/views/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateDtoMixin / views views \u00b6 val views: Array< VaultaireView >","title":"Views"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-dto-mixin/views/#views","text":"val views: Array< VaultaireView >","title":"views"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateUtils VaultaireStateUtils \u00b6 @Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireStateUtils Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for the annotated PersistentState class or constructor. Constructors \u00b6 Name Summary <init> VaultaireStateUtils(name: String = \"\", contractStateType: KClass<out ContractState>) Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for the annotated PersistentState class or constructor. Properties \u00b6 Name Summary contractStateType val contractStateType: KClass<out ContractState> name val name: String","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils/#vaultairestateutils","text":"@Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireStateUtils Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for the annotated PersistentState class or constructor.","title":"VaultaireStateUtils"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils/#constructors","text":"Name Summary <init> VaultaireStateUtils(name: String = \"\", contractStateType: KClass<out ContractState>) Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for the annotated PersistentState class or constructor.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils/#properties","text":"Name Summary contractStateType val contractStateType: KClass<out ContractState> name val name: String","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateUtils / <init> <init> \u00b6 VaultaireStateUtils(name: String = \"\", contractStateType: KClass<out ContractState>) Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for the annotated PersistentState class or constructor.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils/-init-/#init","text":"VaultaireStateUtils(name: String = \"\", contractStateType: KClass<out ContractState>) Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for the annotated PersistentState class or constructor.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateUtils / contractStateType contractStateType \u00b6 val contractStateType: KClass<out ContractState>","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils/contract-state-type/#contractstatetype","text":"val contractStateType: KClass<out ContractState>","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils/name/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateUtils / name name \u00b6 val name: String","title":"Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils/name/#name","text":"val name: String","title":"name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils-mixin/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateUtilsMixin VaultaireStateUtilsMixin \u00b6 @Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireStateUtilsMixin Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for a target PersistentState and ContractState pair of a project dependency. Constructors \u00b6 Name Summary <init> VaultaireStateUtilsMixin(name: String = \"\", contractStateType: KClass<out ContractState>, persistentStateType: KClass<out PersistentState>) Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for a target PersistentState and ContractState pair of a project dependency. Properties \u00b6 Name Summary contractStateType val contractStateType: KClass<out ContractState> name val name: String persistentStateType val persistentStateType: KClass<out PersistentState>","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils-mixin/#vaultairestateutilsmixin","text":"@Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireStateUtilsMixin Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for a target PersistentState and ContractState pair of a project dependency.","title":"VaultaireStateUtilsMixin"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils-mixin/#constructors","text":"Name Summary <init> VaultaireStateUtilsMixin(name: String = \"\", contractStateType: KClass<out ContractState>, persistentStateType: KClass<out PersistentState>) Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for a target PersistentState and ContractState pair of a project dependency.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils-mixin/#properties","text":"Name Summary contractStateType val contractStateType: KClass<out ContractState> name val name: String persistentStateType val persistentStateType: KClass<out PersistentState>","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils-mixin/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateUtilsMixin / <init> <init> \u00b6 VaultaireStateUtilsMixin(name: String = \"\", contractStateType: KClass<out ContractState>, persistentStateType: KClass<out PersistentState>) Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for a target PersistentState and ContractState pair of a project dependency.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils-mixin/-init-/#init","text":"VaultaireStateUtilsMixin(name: String = \"\", contractStateType: KClass<out ContractState>, persistentStateType: KClass<out PersistentState>) Generate state-specific data access utilities, including a Query DSL and ExtendedStateService variants for a target PersistentState and ContractState pair of a project dependency.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils-mixin/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateUtilsMixin / contractStateType contractStateType \u00b6 val contractStateType: KClass<out ContractState>","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils-mixin/contract-state-type/#contractstatetype","text":"val contractStateType: KClass<out ContractState>","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils-mixin/name/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateUtilsMixin / name name \u00b6 val name: String","title":"Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils-mixin/name/#name","text":"val name: String","title":"name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils-mixin/persistent-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireStateUtilsMixin / persistentStateType persistentStateType \u00b6 val persistentStateType: KClass<out PersistentState>","title":"Persistent state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-state-utils-mixin/persistent-state-type/#persistentstatetype","text":"val persistentStateType: KClass<out PersistentState>","title":"persistentStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireView VaultaireView \u00b6 annotation class VaultaireView Constructors \u00b6 Name Summary <init> VaultaireView(name: String, namedFields: Array<String> = [], viewFields: Array< VaultaireViewField > = []) Properties \u00b6 Name Summary name val name: String namedFields val namedFields: Array<String> viewFields val viewFields: Array< VaultaireViewField >","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view/#vaultaireview","text":"annotation class VaultaireView","title":"VaultaireView"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view/#constructors","text":"Name Summary <init> VaultaireView(name: String, namedFields: Array<String> = [], viewFields: Array< VaultaireViewField > = [])","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view/#properties","text":"Name Summary name val name: String namedFields val namedFields: Array<String> viewFields val viewFields: Array< VaultaireViewField >","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireView / <init> <init> \u00b6 VaultaireView(name: String, namedFields: Array<String> = [], viewFields: Array< VaultaireViewField > = [])","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view/-init-/#init","text":"VaultaireView(name: String, namedFields: Array<String> = [], viewFields: Array< VaultaireViewField > = [])","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view/name/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireView / name name \u00b6 val name: String","title":"Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view/name/#name","text":"val name: String","title":"name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view/named-fields/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireView / namedFields namedFields \u00b6 val namedFields: Array<String>","title":"Named fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view/named-fields/#namedfields","text":"val namedFields: Array<String>","title":"namedFields"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view/view-fields/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireView / viewFields viewFields \u00b6 val viewFields: Array< VaultaireViewField >","title":"View fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view/view-fields/#viewfields","text":"val viewFields: Array< VaultaireViewField >","title":"viewFields"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view-field/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireViewField VaultaireViewField \u00b6 annotation class VaultaireViewField Constructors \u00b6 Name Summary <init> VaultaireViewField(name: String, immutable: Boolean = false, nonNull: Boolean = false) Properties \u00b6 Name Summary immutable val immutable: Boolean name val name: String nonNull val nonNull: Boolean","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view-field/#vaultaireviewfield","text":"annotation class VaultaireViewField","title":"VaultaireViewField"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view-field/#constructors","text":"Name Summary <init> VaultaireViewField(name: String, immutable: Boolean = false, nonNull: Boolean = false)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view-field/#properties","text":"Name Summary immutable val immutable: Boolean name val name: String nonNull val nonNull: Boolean","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view-field/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireViewField / <init> <init> \u00b6 VaultaireViewField(name: String, immutable: Boolean = false, nonNull: Boolean = false)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view-field/-init-/#init","text":"VaultaireViewField(name: String, immutable: Boolean = false, nonNull: Boolean = false)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view-field/immutable/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireViewField / immutable immutable \u00b6 val immutable: Boolean","title":"Immutable"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view-field/immutable/#immutable","text":"val immutable: Boolean","title":"immutable"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view-field/name/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireViewField / name name \u00b6 val name: String","title":"Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view-field/name/#name","text":"val name: String","title":"name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view-field/non-null/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireViewField / nonNull nonNull \u00b6 val nonNull: Boolean","title":"Non null"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-view-field/non-null/#nonnull","text":"val nonNull: Boolean","title":"nonNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-views/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireViews VaultaireViews \u00b6 @Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireViews Constructors \u00b6 Name Summary <init> VaultaireViews(value: Array< VaultaireView >, strategies: Array< VaultaireDtoStrategyKeys > = [VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO], nonDataClass: Boolean = false) Properties \u00b6 Name Summary nonDataClass val nonDataClass: Boolean strategies val strategies: Array< VaultaireDtoStrategyKeys > value val value: Array< VaultaireView >","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-views/#vaultaireviews","text":"@Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireViews","title":"VaultaireViews"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-views/#constructors","text":"Name Summary <init> VaultaireViews(value: Array< VaultaireView >, strategies: Array< VaultaireDtoStrategyKeys > = [VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO], nonDataClass: Boolean = false)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-views/#properties","text":"Name Summary nonDataClass val nonDataClass: Boolean strategies val strategies: Array< VaultaireDtoStrategyKeys > value val value: Array< VaultaireView >","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-views/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireViews / <init> <init> \u00b6 VaultaireViews(value: Array< VaultaireView >, strategies: Array< VaultaireDtoStrategyKeys > = [VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO], nonDataClass: Boolean = false)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-views/-init-/#init","text":"VaultaireViews(value: Array< VaultaireView >, strategies: Array< VaultaireDtoStrategyKeys > = [VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO], nonDataClass: Boolean = false)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-views/non-data-class/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireViews / nonDataClass nonDataClass \u00b6 val nonDataClass: Boolean","title":"Non data class"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-views/non-data-class/#nondataclass","text":"val nonDataClass: Boolean","title":"nonDataClass"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-views/strategies/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireViews / strategies strategies \u00b6 val strategies: Array< VaultaireDtoStrategyKeys >","title":"Strategies"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-views/strategies/#strategies","text":"val strategies: Array< VaultaireDtoStrategyKeys >","title":"strategies"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-views/value/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireViews / value value \u00b6 val value: Array< VaultaireView >","title":"Value"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-views/value/#value","text":"val value: Array< VaultaireView >","title":"value"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/","text":"com.github.manosbatsis.vaultaire.dsl.contract Package com.github.manosbatsis.vaultaire.dsl.contract \u00b6 Types \u00b6 Name Summary ContractConditions abstract class ContractConditions When class When","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/#package-comgithubmanosbatsisvaultairedslcontract","text":"","title":"Package com.github.manosbatsis.vaultaire.dsl.contract"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/#types","text":"Name Summary ContractConditions abstract class ContractConditions When class When","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions ContractConditions \u00b6 abstract class ContractConditions Constructors \u00b6 Name Summary <init> ContractConditions(tx: LedgerTransaction) Properties \u00b6 Name Summary commandTypes abstract val commandTypes: Any fields abstract val <T : ContractState> InOutGroup< T , *>.fields: Fields < T > groups abstract val groups: Any roles abstract val roles: Any stateTypeFields abstract val stateTypeFields: Any stateTypes abstract val stateTypes: Any tx val tx: LedgerTransaction","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/#contractconditions","text":"abstract class ContractConditions","title":"ContractConditions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/#constructors","text":"Name Summary <init> ContractConditions(tx: LedgerTransaction)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/#properties","text":"Name Summary commandTypes abstract val commandTypes: Any fields abstract val <T : ContractState> InOutGroup< T , *>.fields: Fields < T > groups abstract val groups: Any roles abstract val roles: Any stateTypeFields abstract val stateTypeFields: Any stateTypes abstract val stateTypes: Any tx val tx: LedgerTransaction","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / <init> <init> \u00b6 ContractConditions(tx: LedgerTransaction)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/-init-/#init","text":"ContractConditions(tx: LedgerTransaction)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/command-types/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / commandTypes commandTypes \u00b6 abstract val commandTypes: Any","title":"Command types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/command-types/#commandtypes","text":"abstract val commandTypes: Any","title":"commandTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/fields/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / fields fields \u00b6 abstract val <T : ContractState> InOutGroup< T , *>.fields: Fields < T >","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/fields/#fields","text":"abstract val <T : ContractState> InOutGroup< T , *>.fields: Fields < T >","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/groups/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / groups groups \u00b6 abstract val groups: Any","title":"Groups"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/groups/#groups","text":"abstract val groups: Any","title":"groups"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/roles/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / roles roles \u00b6 abstract val roles: Any","title":"Roles"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/roles/#roles","text":"abstract val roles: Any","title":"roles"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-type-fields/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / stateTypeFields stateTypeFields \u00b6 abstract val stateTypeFields: Any","title":"State type fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-type-fields/#statetypefields","text":"abstract val stateTypeFields: Any","title":"stateTypeFields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-types/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / stateTypes stateTypes \u00b6 abstract val stateTypes: Any","title":"State types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-types/#statetypes","text":"abstract val stateTypes: Any","title":"stateTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/tx/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / tx tx \u00b6 val tx: LedgerTransaction","title":"Tx"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/tx/#tx","text":"val tx: LedgerTransaction","title":"tx"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/","text":"com.github.manosbatsis.vaultaire.dsl.contract / When When \u00b6 class When Constructors \u00b6 Name Summary <init> When(vararg conditions: Boolean)","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/#when","text":"class When","title":"When"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/#constructors","text":"Name Summary <init> When(vararg conditions: Boolean)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.contract / When / <init> <init> \u00b6 When(vararg conditions: Boolean)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/-init-/#init","text":"When(vararg conditions: Boolean)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/","text":"com.github.manosbatsis.vaultaire.dsl.query Package com.github.manosbatsis.vaultaire.dsl.query \u00b6 Types \u00b6 Name Summary Aggregates class Aggregates<P : StatePersistable> Used to define aggregation criteria AndCondition class AndCondition<P : StatePersistable, out F : Fields < P >> : CompositeCondition < P , F > Defines a set of conditions where all items must be matched CompositeCondition abstract class CompositeCondition<P : StatePersistable, out F : Fields < P >> : ConditionsCondition < P , F > A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Condition interface Condition Condition interface ConditionsCondition abstract class ConditionsCondition<P : StatePersistable, out F : Fields < P >> : Condition A Condition that contains other conditions. Allows for nested and/or condition groups OrCondition class OrCondition<P : StatePersistable, out F : Fields < P >> : CompositeCondition < P , F > Defines a set of conditions where at least a single item must be matched RootCondition interface RootCondition<P : StatePersistable> : Condition SortColumns class SortColumns<P : StatePersistable> Used to define Sort.SortColumn s TimeConsumedCondition class TimeConsumedCondition : TimeInstantTypeCondition TimeInstantTypeCondition abstract class TimeInstantTypeCondition TimeRecordedCondition class TimeRecordedCondition : TimeInstantTypeCondition VaultCustomQueryCondition open class VaultCustomQueryCondition<L : StatePersistable> : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition<P : StatePersistable, out F : Fields < P >> : ConditionsCondition < P , F >, RootCondition < P > A ConditionsCondition extended by Vaultaire\u2019s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/#package-comgithubmanosbatsisvaultairedslquery","text":"","title":"Package com.github.manosbatsis.vaultaire.dsl.query"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/#types","text":"Name Summary Aggregates class Aggregates<P : StatePersistable> Used to define aggregation criteria AndCondition class AndCondition<P : StatePersistable, out F : Fields < P >> : CompositeCondition < P , F > Defines a set of conditions where all items must be matched CompositeCondition abstract class CompositeCondition<P : StatePersistable, out F : Fields < P >> : ConditionsCondition < P , F > A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Condition interface Condition Condition interface ConditionsCondition abstract class ConditionsCondition<P : StatePersistable, out F : Fields < P >> : Condition A Condition that contains other conditions. Allows for nested and/or condition groups OrCondition class OrCondition<P : StatePersistable, out F : Fields < P >> : CompositeCondition < P , F > Defines a set of conditions where at least a single item must be matched RootCondition interface RootCondition<P : StatePersistable> : Condition SortColumns class SortColumns<P : StatePersistable> Used to define Sort.SortColumn s TimeConsumedCondition class TimeConsumedCondition : TimeInstantTypeCondition TimeInstantTypeCondition abstract class TimeInstantTypeCondition TimeRecordedCondition class TimeRecordedCondition : TimeInstantTypeCondition VaultCustomQueryCondition open class VaultCustomQueryCondition<L : StatePersistable> : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition<P : StatePersistable, out F : Fields < P >> : ConditionsCondition < P , F >, RootCondition < P > A ConditionsCondition extended by Vaultaire\u2019s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates Aggregates \u00b6 class Aggregates<P : StatePersistable> Used to define aggregation criteria Constructors \u00b6 Name Summary <init> Aggregates(rootCondition: RootCondition < P >) Used to define aggregation criteria Properties \u00b6 Name Summary rootCondition val rootCondition: RootCondition < P > Functions \u00b6 Name Summary avg fun <S : Comparable< S >> TypedFieldWrapper < P , S >.avg(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean count fun FieldWrapper < P >.count(): Boolean max fun <S : Comparable< S >> TypedFieldWrapper < P , S >.max(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean min fun <S : Comparable< S >> TypedFieldWrapper < P , S >.min(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean sum fun <S : Comparable< S >> TypedFieldWrapper < P , S >.sum(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#aggregates","text":"class Aggregates<P : StatePersistable> Used to define aggregation criteria","title":"Aggregates"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#constructors","text":"Name Summary <init> Aggregates(rootCondition: RootCondition < P >) Used to define aggregation criteria","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#properties","text":"Name Summary rootCondition val rootCondition: RootCondition < P >","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#functions","text":"Name Summary avg fun <S : Comparable< S >> TypedFieldWrapper < P , S >.avg(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean count fun FieldWrapper < P >.count(): Boolean max fun <S : Comparable< S >> TypedFieldWrapper < P , S >.max(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean min fun <S : Comparable< S >> TypedFieldWrapper < P , S >.min(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean sum fun <S : Comparable< S >> TypedFieldWrapper < P , S >.sum(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / <init> <init> \u00b6 Aggregates(rootCondition: RootCondition < P >) Used to define aggregation criteria","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/-init-/#init","text":"Aggregates(rootCondition: RootCondition < P >) Used to define aggregation criteria","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/avg/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / avg avg \u00b6 fun <S : Comparable< S >> TypedFieldWrapper < P , S >.avg(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean","title":"Avg"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/avg/#avg","text":"fun <S : Comparable< S >> TypedFieldWrapper < P , S >.avg(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean","title":"avg"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/count/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / count count \u00b6 fun FieldWrapper < P >.count(): Boolean","title":"Count"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/count/#count","text":"fun FieldWrapper < P >.count(): Boolean","title":"count"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/max/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / max max \u00b6 fun <S : Comparable< S >> TypedFieldWrapper < P , S >.max(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean","title":"Max"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/max/#max","text":"fun <S : Comparable< S >> TypedFieldWrapper < P , S >.max(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean","title":"max"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/min/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / min min \u00b6 fun <S : Comparable< S >> TypedFieldWrapper < P , S >.min(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean","title":"Min"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/min/#min","text":"fun <S : Comparable< S >> TypedFieldWrapper < P , S >.min(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean","title":"min"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/root-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / rootCondition rootCondition \u00b6 val rootCondition: RootCondition < P >","title":"Root condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/root-condition/#rootcondition","text":"val rootCondition: RootCondition < P >","title":"rootCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/sum/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / sum sum \u00b6 fun <S : Comparable< S >> TypedFieldWrapper < P , S >.sum(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean","title":"Sum"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/sum/#sum","text":"fun <S : Comparable< S >> TypedFieldWrapper < P , S >.sum(groupColumns: List< FieldWrapper < P >>? = null, orderBy: Direction? = null): Boolean","title":"sum"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / AndCondition AndCondition \u00b6 class AndCondition<P : StatePersistable, out F : Fields < P >> : CompositeCondition < P , F > Defines a set of conditions where all items must be matched Constructors \u00b6 Name Summary <init> AndCondition(fields: F , rootCondition: RootCondition < P >) Defines a set of conditions where all items must be matched Inherited Properties \u00b6 Name Summary fields open val fields: F The fields of the target StatePersistable type P rootCondition open val rootCondition: RootCondition < P > The root condition Functions \u00b6 Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inherited Functions \u00b6 Name Summary != infix fun <S> TypedFieldWrapper < P , S >.!=(value: S ): Boolean !in fun <S : Comparable< S >> TypedFieldWrapper < P , S >.!in(value: Collection< S >): Boolean == infix fun <S> TypedFieldWrapper < P , S >.==(value: S ): Boolean _equal infix fun FieldWrapper < P >._equal(value: Any): Boolean _like infix fun FieldWrapper < P >._like(value: String): Boolean _notEqual infix fun FieldWrapper < P >._notEqual(value: Any): Boolean _notLike infix fun FieldWrapper < P >._notLike(value: String): Boolean asStringProperty fun FieldWrapper < P >.asStringProperty(): KProperty1< P , String> between fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(from: S , to: S ): Boolean infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(value: Pair< S , S >): Boolean btw infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.btw(value: Pair< S , S >): Boolean equal infix fun <S> TypedFieldWrapper < P , S >.equal(value: S ): Boolean greaterThan infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThan(value: S ): Boolean greaterThanOrEqual infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThanOrEqual(value: S ): Boolean gt infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gt(value: S ): Boolean gte infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gte(value: S ): Boolean in infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.in(value: Collection< S >): Boolean isIn infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.isIn(value: Collection< S >): Boolean isNull fun <S> NullableGenericFieldWrapper < P , S >.isNull(): Boolean lessThan infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThan(value: S ): Boolean lessThanOrEqual infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThanOrEqual(value: S ): Boolean like infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String, exactMatch: Boolean = true): Unit lt infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lt(value: S ): Boolean lte infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lte(value: S ): Boolean notEqual infix fun <S> TypedFieldWrapper < P , S >.notEqual(value: S ): Boolean notIn infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.notIn(value: Collection< S >): Boolean notLike infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String, exactMatch: Boolean = true): Unit notNull fun <S> NullableGenericFieldWrapper < P , S >.notNull(): Boolean","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#andcondition","text":"class AndCondition<P : StatePersistable, out F : Fields < P >> : CompositeCondition < P , F > Defines a set of conditions where all items must be matched","title":"AndCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#constructors","text":"Name Summary <init> AndCondition(fields: F , rootCondition: RootCondition < P >) Defines a set of conditions where all items must be matched","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#inherited-properties","text":"Name Summary fields open val fields: F The fields of the target StatePersistable type P rootCondition open val rootCondition: RootCondition < P > The root condition","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#functions","text":"Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#inherited-functions","text":"Name Summary != infix fun <S> TypedFieldWrapper < P , S >.!=(value: S ): Boolean !in fun <S : Comparable< S >> TypedFieldWrapper < P , S >.!in(value: Collection< S >): Boolean == infix fun <S> TypedFieldWrapper < P , S >.==(value: S ): Boolean _equal infix fun FieldWrapper < P >._equal(value: Any): Boolean _like infix fun FieldWrapper < P >._like(value: String): Boolean _notEqual infix fun FieldWrapper < P >._notEqual(value: Any): Boolean _notLike infix fun FieldWrapper < P >._notLike(value: String): Boolean asStringProperty fun FieldWrapper < P >.asStringProperty(): KProperty1< P , String> between fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(from: S , to: S ): Boolean infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(value: Pair< S , S >): Boolean btw infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.btw(value: Pair< S , S >): Boolean equal infix fun <S> TypedFieldWrapper < P , S >.equal(value: S ): Boolean greaterThan infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThan(value: S ): Boolean greaterThanOrEqual infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThanOrEqual(value: S ): Boolean gt infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gt(value: S ): Boolean gte infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gte(value: S ): Boolean in infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.in(value: Collection< S >): Boolean isIn infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.isIn(value: Collection< S >): Boolean isNull fun <S> NullableGenericFieldWrapper < P , S >.isNull(): Boolean lessThan infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThan(value: S ): Boolean lessThanOrEqual infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThanOrEqual(value: S ): Boolean like infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String, exactMatch: Boolean = true): Unit lt infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lt(value: S ): Boolean lte infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lte(value: S ): Boolean notEqual infix fun <S> TypedFieldWrapper < P , S >.notEqual(value: S ): Boolean notIn infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.notIn(value: Collection< S >): Boolean notLike infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String, exactMatch: Boolean = true): Unit notNull fun <S> NullableGenericFieldWrapper < P , S >.notNull(): Boolean","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / AndCondition / <init> <init> \u00b6 AndCondition(fields: F , rootCondition: RootCondition < P >) Defines a set of conditions where all items must be matched","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/-init-/#init","text":"AndCondition(fields: F , rootCondition: RootCondition < P >) Defines a set of conditions where all items must be matched","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / AndCondition / toCriteria toCriteria \u00b6 fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/to-criteria/#tocriteria","text":"fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition CompositeCondition \u00b6 abstract class CompositeCondition<P : StatePersistable, out F : Fields < P >> : ConditionsCondition < P , F > A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Constructors \u00b6 Name Summary <init> CompositeCondition(fields: F , rootCondition: RootCondition < P >) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Properties \u00b6 Name Summary fields open val fields: F The fields of the target StatePersistable type P rootCondition open val rootCondition: RootCondition < P > The root condition Functions \u00b6 Name Summary != infix fun <S> TypedFieldWrapper < P , S >.!=(value: S ): Boolean !in fun <S : Comparable< S >> TypedFieldWrapper < P , S >.!in(value: Collection< S >): Boolean == infix fun <S> TypedFieldWrapper < P , S >.==(value: S ): Boolean _equal infix fun FieldWrapper < P >._equal(value: Any): Boolean _like infix fun FieldWrapper < P >._like(value: String): Boolean _notEqual infix fun FieldWrapper < P >._notEqual(value: Any): Boolean _notLike infix fun FieldWrapper < P >._notLike(value: String): Boolean asStringProperty fun FieldWrapper < P >.asStringProperty(): KProperty1< P , String> between fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(from: S , to: S ): Boolean infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(value: Pair< S , S >): Boolean btw infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.btw(value: Pair< S , S >): Boolean equal infix fun <S> TypedFieldWrapper < P , S >.equal(value: S ): Boolean greaterThan infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThan(value: S ): Boolean greaterThanOrEqual infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThanOrEqual(value: S ): Boolean gt infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gt(value: S ): Boolean gte infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gte(value: S ): Boolean in infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.in(value: Collection< S >): Boolean isIn infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.isIn(value: Collection< S >): Boolean isNull fun <S> NullableGenericFieldWrapper < P , S >.isNull(): Boolean lessThan infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThan(value: S ): Boolean lessThanOrEqual infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThanOrEqual(value: S ): Boolean like infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String, exactMatch: Boolean = true): Unit lt infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lt(value: S ): Boolean lte infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lte(value: S ): Boolean notEqual infix fun <S> TypedFieldWrapper < P , S >.notEqual(value: S ): Boolean notIn infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.notIn(value: Collection< S >): Boolean notLike infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String, exactMatch: Boolean = true): Unit notNull fun <S> NullableGenericFieldWrapper < P , S >.notNull(): Boolean Inherited Functions \u00b6 Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition < P , F >.() -> Unit): Unit or fun or(initializer: CompositeCondition < P , F >.() -> Unit): Unit Inheritors \u00b6 Name Summary AndCondition class AndCondition<P : StatePersistable, out F : Fields < P >> : CompositeCondition < P , F > Defines a set of conditions where all items must be matched OrCondition class OrCondition<P : StatePersistable, out F : Fields < P >> : CompositeCondition < P , F > Defines a set of conditions where at least a single item must be matched","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#compositecondition","text":"abstract class CompositeCondition<P : StatePersistable, out F : Fields < P >> : ConditionsCondition < P , F > A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":"CompositeCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#constructors","text":"Name Summary <init> CompositeCondition(fields: F , rootCondition: RootCondition < P >) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#properties","text":"Name Summary fields open val fields: F The fields of the target StatePersistable type P rootCondition open val rootCondition: RootCondition < P > The root condition","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#functions","text":"Name Summary != infix fun <S> TypedFieldWrapper < P , S >.!=(value: S ): Boolean !in fun <S : Comparable< S >> TypedFieldWrapper < P , S >.!in(value: Collection< S >): Boolean == infix fun <S> TypedFieldWrapper < P , S >.==(value: S ): Boolean _equal infix fun FieldWrapper < P >._equal(value: Any): Boolean _like infix fun FieldWrapper < P >._like(value: String): Boolean _notEqual infix fun FieldWrapper < P >._notEqual(value: Any): Boolean _notLike infix fun FieldWrapper < P >._notLike(value: String): Boolean asStringProperty fun FieldWrapper < P >.asStringProperty(): KProperty1< P , String> between fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(from: S , to: S ): Boolean infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(value: Pair< S , S >): Boolean btw infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.btw(value: Pair< S , S >): Boolean equal infix fun <S> TypedFieldWrapper < P , S >.equal(value: S ): Boolean greaterThan infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThan(value: S ): Boolean greaterThanOrEqual infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThanOrEqual(value: S ): Boolean gt infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gt(value: S ): Boolean gte infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gte(value: S ): Boolean in infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.in(value: Collection< S >): Boolean isIn infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.isIn(value: Collection< S >): Boolean isNull fun <S> NullableGenericFieldWrapper < P , S >.isNull(): Boolean lessThan infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThan(value: S ): Boolean lessThanOrEqual infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThanOrEqual(value: S ): Boolean like infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String, exactMatch: Boolean = true): Unit lt infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lt(value: S ): Boolean lte infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lte(value: S ): Boolean notEqual infix fun <S> TypedFieldWrapper < P , S >.notEqual(value: S ): Boolean notIn infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.notIn(value: Collection< S >): Boolean notLike infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String, exactMatch: Boolean = true): Unit notNull fun <S> NullableGenericFieldWrapper < P , S >.notNull(): Boolean","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#inherited-functions","text":"Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition < P , F >.() -> Unit): Unit or fun or(initializer: CompositeCondition < P , F >.() -> Unit): Unit","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#inheritors","text":"Name Summary AndCondition class AndCondition<P : StatePersistable, out F : Fields < P >> : CompositeCondition < P , F > Defines a set of conditions where all items must be matched OrCondition class OrCondition<P : StatePersistable, out F : Fields < P >> : CompositeCondition < P , F > Defines a set of conditions where at least a single item must be matched","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/%21%3D/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / != != \u00b6 infix fun <S> TypedFieldWrapper < P , S >.!=(value: S ): Boolean","title":"!="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/%21%3D/#_1","text":"infix fun <S> TypedFieldWrapper < P , S >.!=(value: S ): Boolean","title":"!="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/%21in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / !in !in \u00b6 fun <S : Comparable< S >> TypedFieldWrapper < P , S >.!in(value: Collection< S >): Boolean","title":"!in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/%21in/#in","text":"fun <S : Comparable< S >> TypedFieldWrapper < P , S >.!in(value: Collection< S >): Boolean","title":"!in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / <init> <init> \u00b6 CompositeCondition(fields: F , rootCondition: RootCondition < P >) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/-init-/#init","text":"CompositeCondition(fields: F , rootCondition: RootCondition < P >) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/%3D%3D/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / == == \u00b6 infix fun <S> TypedFieldWrapper < P , S >.==(value: S ): Boolean","title":"=="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/%3D%3D/#_1","text":"infix fun <S> TypedFieldWrapper < P , S >.==(value: S ): Boolean","title":"=="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _equal _equal \u00b6 infix fun FieldWrapper < P >._equal(value: Any): Boolean","title":" equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_equal/#_equal","text":"infix fun FieldWrapper < P >._equal(value: Any): Boolean","title":"_equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _like _like \u00b6 infix fun FieldWrapper < P >._like(value: String): Boolean","title":" like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_like/#_like","text":"infix fun FieldWrapper < P >._like(value: String): Boolean","title":"_like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _notEqual _notEqual \u00b6 infix fun FieldWrapper < P >._notEqual(value: Any): Boolean","title":" not equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-equal/#_notequal","text":"infix fun FieldWrapper < P >._notEqual(value: Any): Boolean","title":"_notEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _notLike _notLike \u00b6 infix fun FieldWrapper < P >._notLike(value: String): Boolean","title":" not like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-like/#_notlike","text":"infix fun FieldWrapper < P >._notLike(value: String): Boolean","title":"_notLike"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/as-string-property/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / asStringProperty asStringProperty \u00b6 protected fun FieldWrapper < P >.asStringProperty(): KProperty1< P , String>","title":"As string property"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/as-string-property/#asstringproperty","text":"protected fun FieldWrapper < P >.asStringProperty(): KProperty1< P , String>","title":"asStringProperty"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/between/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / between between \u00b6 fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(from: S , to: S ): Boolean infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(value: Pair< S , S >): Boolean","title":"Between"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/between/#between","text":"fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(from: S , to: S ): Boolean infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(value: Pair< S , S >): Boolean","title":"between"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/btw/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / btw btw \u00b6 infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.btw(value: Pair< S , S >): Boolean","title":"Btw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/btw/#btw","text":"infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.btw(value: Pair< S , S >): Boolean","title":"btw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / equal equal \u00b6 infix fun <S> TypedFieldWrapper < P , S >.equal(value: S ): Boolean","title":"Equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/equal/#equal","text":"infix fun <S> TypedFieldWrapper < P , S >.equal(value: S ): Boolean","title":"equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/fields/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / fields fields \u00b6 open val fields: F Overrides ConditionsCondition.fields The fields of the target StatePersistable type P","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/fields/#fields","text":"open val fields: F Overrides ConditionsCondition.fields The fields of the target StatePersistable type P","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than-or-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / greaterThanOrEqual greaterThanOrEqual \u00b6 infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThanOrEqual(value: S ): Boolean","title":"Greater than or equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than-or-equal/#greaterthanorequal","text":"infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThanOrEqual(value: S ): Boolean","title":"greaterThanOrEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / greaterThan greaterThan \u00b6 infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThan(value: S ): Boolean","title":"Greater than"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than/#greaterthan","text":"infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThan(value: S ): Boolean","title":"greaterThan"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gt/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / gt gt \u00b6 infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gt(value: S ): Boolean","title":"Gt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gt/#gt","text":"infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gt(value: S ): Boolean","title":"gt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gte/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / gte gte \u00b6 infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gte(value: S ): Boolean","title":"Gte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gte/#gte","text":"infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gte(value: S ): Boolean","title":"gte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / in in \u00b6 infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.in(value: Collection< S >): Boolean","title":"In"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/in/#in","text":"infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.in(value: Collection< S >): Boolean","title":"in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / isIn isIn \u00b6 infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.isIn(value: Collection< S >): Boolean","title":"Is in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-in/#isin","text":"infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.isIn(value: Collection< S >): Boolean","title":"isIn"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-null/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / isNull isNull \u00b6 fun <S> NullableGenericFieldWrapper < P , S >.isNull(): Boolean","title":"Is null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-null/#isnull","text":"fun <S> NullableGenericFieldWrapper < P , S >.isNull(): Boolean","title":"isNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than-or-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lessThanOrEqual lessThanOrEqual \u00b6 infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThanOrEqual(value: S ): Boolean","title":"Less than or equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than-or-equal/#lessthanorequal","text":"infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThanOrEqual(value: S ): Boolean","title":"lessThanOrEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lessThan lessThan \u00b6 infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThan(value: S ): Boolean","title":"Less than"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than/#lessthan","text":"infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThan(value: S ): Boolean","title":"lessThan"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / like like \u00b6 infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String, exactMatch: Boolean = true): Unit","title":"Like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/like/#like","text":"infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String, exactMatch: Boolean = true): Unit","title":"like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lt/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lt lt \u00b6 infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lt(value: S ): Boolean","title":"Lt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lt/#lt","text":"infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lt(value: S ): Boolean","title":"lt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lte/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lte lte \u00b6 infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lte(value: S ): Boolean","title":"Lte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lte/#lte","text":"infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lte(value: S ): Boolean","title":"lte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notEqual notEqual \u00b6 infix fun <S> TypedFieldWrapper < P , S >.notEqual(value: S ): Boolean","title":"Not equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-equal/#notequal","text":"infix fun <S> TypedFieldWrapper < P , S >.notEqual(value: S ): Boolean","title":"notEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notIn notIn \u00b6 infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.notIn(value: Collection< S >): Boolean","title":"Not in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-in/#notin","text":"infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.notIn(value: Collection< S >): Boolean","title":"notIn"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notLike notLike \u00b6 infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String, exactMatch: Boolean = true): Unit","title":"Not like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-like/#notlike","text":"infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String, exactMatch: Boolean = true): Unit","title":"notLike"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-null/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notNull notNull \u00b6 fun <S> NullableGenericFieldWrapper < P , S >.notNull(): Boolean","title":"Not null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-null/#notnull","text":"fun <S> NullableGenericFieldWrapper < P , S >.notNull(): Boolean","title":"notNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/root-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / rootCondition rootCondition \u00b6 open val rootCondition: RootCondition < P > Overrides ConditionsCondition.rootCondition The root condition","title":"Root condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/root-condition/#rootcondition","text":"open val rootCondition: RootCondition < P > Overrides ConditionsCondition.rootCondition The root condition","title":"rootCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / Condition Condition \u00b6 interface Condition Condition interface Functions \u00b6 Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inheritors \u00b6 Name Summary ConditionsCondition abstract class ConditionsCondition<P : StatePersistable, out F : Fields < P >> : Condition A Condition that contains other conditions. Allows for nested and/or condition groups RootCondition interface RootCondition<P : StatePersistable> : Condition VaultCustomQueryCondition open class VaultCustomQueryCondition<L : StatePersistable> : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/#condition","text":"interface Condition Condition interface","title":"Condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/#functions","text":"Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/#inheritors","text":"Name Summary ConditionsCondition abstract class ConditionsCondition<P : StatePersistable, out F : Fields < P >> : Condition A Condition that contains other conditions. Allows for nested and/or condition groups RootCondition interface RootCondition<P : StatePersistable> : Condition VaultCustomQueryCondition open class VaultCustomQueryCondition<L : StatePersistable> : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / Condition / toCriteria toCriteria \u00b6 abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/to-criteria/#tocriteria","text":"abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition ConditionsCondition \u00b6 abstract class ConditionsCondition<P : StatePersistable, out F : Fields < P >> : Condition A Condition that contains other conditions. Allows for nested and/or condition groups Constructors \u00b6 Name Summary <init> ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups Properties \u00b6 Name Summary fields abstract val fields: F The fields of the target StatePersistable type P rootCondition abstract val rootCondition: RootCondition < P > The root condition Functions \u00b6 Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition < P , F >.() -> Unit): Unit or fun or(initializer: CompositeCondition < P , F >.() -> Unit): Unit Inherited Functions \u00b6 Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inheritors \u00b6 Name Summary CompositeCondition abstract class CompositeCondition<P : StatePersistable, out F : Fields < P >> : ConditionsCondition < P , F > A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition<P : StatePersistable, out F : Fields < P >> : ConditionsCondition < P , F >, RootCondition < P > A ConditionsCondition extended by Vaultaire\u2019s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#conditionscondition","text":"abstract class ConditionsCondition<P : StatePersistable, out F : Fields < P >> : Condition A Condition that contains other conditions. Allows for nested and/or condition groups","title":"ConditionsCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#constructors","text":"Name Summary <init> ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#properties","text":"Name Summary fields abstract val fields: F The fields of the target StatePersistable type P rootCondition abstract val rootCondition: RootCondition < P > The root condition","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#functions","text":"Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition < P , F >.() -> Unit): Unit or fun or(initializer: CompositeCondition < P , F >.() -> Unit): Unit","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#inherited-functions","text":"Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#inheritors","text":"Name Summary CompositeCondition abstract class CompositeCondition<P : StatePersistable, out F : Fields < P >> : ConditionsCondition < P , F > A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition<P : StatePersistable, out F : Fields < P >> : ConditionsCondition < P , F >, RootCondition < P > A ConditionsCondition extended by Vaultaire\u2019s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / <init> <init> \u00b6 ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/-init-/#init","text":"ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/add-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / addCondition addCondition \u00b6 fun addCondition(condition: Condition ): Unit","title":"Add condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/add-condition/#addcondition","text":"fun addCondition(condition: Condition ): Unit","title":"addCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/and/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / and and \u00b6 fun and(initializer: CompositeCondition < P , F >.() -> Unit): Unit","title":"And"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/and/#and","text":"fun and(initializer: CompositeCondition < P , F >.() -> Unit): Unit","title":"and"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/fields/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / fields fields \u00b6 abstract val fields: F The fields of the target StatePersistable type P","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/fields/#fields","text":"abstract val fields: F The fields of the target StatePersistable type P","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/or/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / or or \u00b6 fun or(initializer: CompositeCondition < P , F >.() -> Unit): Unit","title":"Or"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/or/#or","text":"fun or(initializer: CompositeCondition < P , F >.() -> Unit): Unit","title":"or"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/root-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / rootCondition rootCondition \u00b6 abstract val rootCondition: RootCondition < P > The root condition","title":"Root condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/root-condition/#rootcondition","text":"abstract val rootCondition: RootCondition < P > The root condition","title":"rootCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / OrCondition OrCondition \u00b6 class OrCondition<P : StatePersistable, out F : Fields < P >> : CompositeCondition < P , F > Defines a set of conditions where at least a single item must be matched Constructors \u00b6 Name Summary <init> OrCondition(fields: F , rootCondition: RootCondition < P >) Defines a set of conditions where at least a single item must be matched Inherited Properties \u00b6 Name Summary fields open val fields: F The fields of the target StatePersistable type P rootCondition open val rootCondition: RootCondition < P > The root condition Functions \u00b6 Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inherited Functions \u00b6 Name Summary != infix fun <S> TypedFieldWrapper < P , S >.!=(value: S ): Boolean !in fun <S : Comparable< S >> TypedFieldWrapper < P , S >.!in(value: Collection< S >): Boolean == infix fun <S> TypedFieldWrapper < P , S >.==(value: S ): Boolean _equal infix fun FieldWrapper < P >._equal(value: Any): Boolean _like infix fun FieldWrapper < P >._like(value: String): Boolean _notEqual infix fun FieldWrapper < P >._notEqual(value: Any): Boolean _notLike infix fun FieldWrapper < P >._notLike(value: String): Boolean asStringProperty fun FieldWrapper < P >.asStringProperty(): KProperty1< P , String> between fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(from: S , to: S ): Boolean infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(value: Pair< S , S >): Boolean btw infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.btw(value: Pair< S , S >): Boolean equal infix fun <S> TypedFieldWrapper < P , S >.equal(value: S ): Boolean greaterThan infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThan(value: S ): Boolean greaterThanOrEqual infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThanOrEqual(value: S ): Boolean gt infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gt(value: S ): Boolean gte infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gte(value: S ): Boolean in infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.in(value: Collection< S >): Boolean isIn infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.isIn(value: Collection< S >): Boolean isNull fun <S> NullableGenericFieldWrapper < P , S >.isNull(): Boolean lessThan infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThan(value: S ): Boolean lessThanOrEqual infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThanOrEqual(value: S ): Boolean like infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String, exactMatch: Boolean = true): Unit lt infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lt(value: S ): Boolean lte infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lte(value: S ): Boolean notEqual infix fun <S> TypedFieldWrapper < P , S >.notEqual(value: S ): Boolean notIn infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.notIn(value: Collection< S >): Boolean notLike infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String, exactMatch: Boolean = true): Unit notNull fun <S> NullableGenericFieldWrapper < P , S >.notNull(): Boolean","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#orcondition","text":"class OrCondition<P : StatePersistable, out F : Fields < P >> : CompositeCondition < P , F > Defines a set of conditions where at least a single item must be matched","title":"OrCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#constructors","text":"Name Summary <init> OrCondition(fields: F , rootCondition: RootCondition < P >) Defines a set of conditions where at least a single item must be matched","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#inherited-properties","text":"Name Summary fields open val fields: F The fields of the target StatePersistable type P rootCondition open val rootCondition: RootCondition < P > The root condition","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#functions","text":"Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#inherited-functions","text":"Name Summary != infix fun <S> TypedFieldWrapper < P , S >.!=(value: S ): Boolean !in fun <S : Comparable< S >> TypedFieldWrapper < P , S >.!in(value: Collection< S >): Boolean == infix fun <S> TypedFieldWrapper < P , S >.==(value: S ): Boolean _equal infix fun FieldWrapper < P >._equal(value: Any): Boolean _like infix fun FieldWrapper < P >._like(value: String): Boolean _notEqual infix fun FieldWrapper < P >._notEqual(value: Any): Boolean _notLike infix fun FieldWrapper < P >._notLike(value: String): Boolean asStringProperty fun FieldWrapper < P >.asStringProperty(): KProperty1< P , String> between fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(from: S , to: S ): Boolean infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.between(value: Pair< S , S >): Boolean btw infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.btw(value: Pair< S , S >): Boolean equal infix fun <S> TypedFieldWrapper < P , S >.equal(value: S ): Boolean greaterThan infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThan(value: S ): Boolean greaterThanOrEqual infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.greaterThanOrEqual(value: S ): Boolean gt infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gt(value: S ): Boolean gte infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.gte(value: S ): Boolean in infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.in(value: Collection< S >): Boolean isIn infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.isIn(value: Collection< S >): Boolean isNull fun <S> NullableGenericFieldWrapper < P , S >.isNull(): Boolean lessThan infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThan(value: S ): Boolean lessThanOrEqual infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lessThanOrEqual(value: S ): Boolean like infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.like(value: String, exactMatch: Boolean = true): Unit lt infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lt(value: S ): Boolean lte infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.lte(value: S ): Boolean notEqual infix fun <S> TypedFieldWrapper < P , S >.notEqual(value: S ): Boolean notIn infix fun <S : Comparable< S >> TypedFieldWrapper < P , S >.notIn(value: Collection< S >): Boolean notLike infix fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String): Unit fun <T : StatePersistable> TypedFieldWrapper < T , String>.notLike(value: String, exactMatch: Boolean = true): Unit notNull fun <S> NullableGenericFieldWrapper < P , S >.notNull(): Boolean","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / OrCondition / <init> <init> \u00b6 OrCondition(fields: F , rootCondition: RootCondition < P >) Defines a set of conditions where at least a single item must be matched","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/-init-/#init","text":"OrCondition(fields: F , rootCondition: RootCondition < P >) Defines a set of conditions where at least a single item must be matched","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / OrCondition / toCriteria toCriteria \u00b6 fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/to-criteria/#tocriteria","text":"fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition RootCondition \u00b6 interface RootCondition<P : StatePersistable> : Condition Properties \u00b6 Name Summary constraints abstract var constraints: Set<ConstraintInfo> constraintTypes abstract var constraintTypes: Set<Type> externalIds abstract var externalIds: List<UUID> notary abstract var notary: List<AbstractParty>? participants abstract var participants: List<AbstractParty>? relevancyStatus abstract var relevancyStatus: RelevancyStatus softLockingCondition abstract var softLockingCondition: SoftLockingCondition? stateRefs abstract var stateRefs: List<StateRef>? status abstract var status: StateStatus timeCondition abstract var timeCondition: TimeCondition? Inherited Functions \u00b6 Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inheritors \u00b6 Name Summary VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition<P : StatePersistable, out F : Fields < P >> : ConditionsCondition < P , F >, RootCondition < P > A ConditionsCondition extended by Vaultaire\u2019s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/#rootcondition","text":"interface RootCondition<P : StatePersistable> : Condition","title":"RootCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/#properties","text":"Name Summary constraints abstract var constraints: Set<ConstraintInfo> constraintTypes abstract var constraintTypes: Set<Type> externalIds abstract var externalIds: List<UUID> notary abstract var notary: List<AbstractParty>? participants abstract var participants: List<AbstractParty>? relevancyStatus abstract var relevancyStatus: RelevancyStatus softLockingCondition abstract var softLockingCondition: SoftLockingCondition? stateRefs abstract var stateRefs: List<StateRef>? status abstract var status: StateStatus timeCondition abstract var timeCondition: TimeCondition?","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/#inherited-functions","text":"Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/#inheritors","text":"Name Summary VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition<P : StatePersistable, out F : Fields < P >> : ConditionsCondition < P , F >, RootCondition < P > A ConditionsCondition extended by Vaultaire\u2019s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/constraint-types/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / constraintTypes constraintTypes \u00b6 abstract var constraintTypes: Set<Type>","title":"Constraint types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/constraint-types/#constrainttypes","text":"abstract var constraintTypes: Set<Type>","title":"constraintTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/constraints/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / constraints constraints \u00b6 abstract var constraints: Set<ConstraintInfo>","title":"Constraints"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/constraints/#constraints","text":"abstract var constraints: Set<ConstraintInfo>","title":"constraints"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/external-ids/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / externalIds externalIds \u00b6 abstract var externalIds: List<UUID>","title":"External ids"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/external-ids/#externalids","text":"abstract var externalIds: List<UUID>","title":"externalIds"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/notary/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / notary notary \u00b6 abstract var notary: List<AbstractParty>?","title":"Notary"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/notary/#notary","text":"abstract var notary: List<AbstractParty>?","title":"notary"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/participants/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / participants participants \u00b6 abstract var participants: List<AbstractParty>?","title":"Participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/participants/#participants","text":"abstract var participants: List<AbstractParty>?","title":"participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/relevancy-status/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / relevancyStatus relevancyStatus \u00b6 abstract var relevancyStatus: RelevancyStatus","title":"Relevancy status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/relevancy-status/#relevancystatus","text":"abstract var relevancyStatus: RelevancyStatus","title":"relevancyStatus"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/soft-locking-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / softLockingCondition softLockingCondition \u00b6 abstract var softLockingCondition: SoftLockingCondition?","title":"Soft locking condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/soft-locking-condition/#softlockingcondition","text":"abstract var softLockingCondition: SoftLockingCondition?","title":"softLockingCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/state-refs/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / stateRefs stateRefs \u00b6 abstract var stateRefs: List<StateRef>?","title":"State refs"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/state-refs/#staterefs","text":"abstract var stateRefs: List<StateRef>?","title":"stateRefs"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/status/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / status status \u00b6 abstract var status: StateStatus","title":"Status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/status/#status","text":"abstract var status: StateStatus","title":"status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/time-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / timeCondition timeCondition \u00b6 abstract var timeCondition: TimeCondition?","title":"Time condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/time-condition/#timecondition","text":"abstract var timeCondition: TimeCondition?","title":"timeCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns SortColumns \u00b6 class SortColumns<P : StatePersistable> Used to define Sort.SortColumn s Constructors \u00b6 Name Summary <init> SortColumns(statePersistableType: Class< P >) Used to define Sort.SortColumn s Properties \u00b6 Name Summary ASC val ASC: Direction constraintType val constraintType: VaultStateAttribute consumedTime val consumedTime: VaultStateAttribute contractStateType val contractStateType: VaultStateAttribute DESC val DESC: Direction entries val entries: LinkedHashSet<SortColumn> externalId val externalId: LinearStateAttribute issuerRef val issuerRef: FungibleStateAttribute lockId val lockId: VaultStateAttribute notaryName val notaryName: VaultStateAttribute quantity val quantity: FungibleStateAttribute recordedTime val recordedTime: VaultStateAttribute statePersistableType val statePersistableType: Class< P > stateRef val stateRef: CommonStateAttribute stateRefIndex val stateRefIndex: CommonStateAttribute stateRefTxnId val stateRefTxnId: CommonStateAttribute stateStatus val stateStatus: VaultStateAttribute uuid val uuid: LinearStateAttribute Functions \u00b6 Name Summary sort infix fun CommonStateAttribute.sort(value: Direction): Boolean infix fun FungibleStateAttribute.sort(value: Direction): Boolean infix fun LinearStateAttribute.sort(value: Direction): Boolean infix fun VaultStateAttribute.sort(value: Direction): Boolean infix fun FieldWrapper < P >.sort(value: Direction): Unit","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#sortcolumns","text":"class SortColumns<P : StatePersistable> Used to define Sort.SortColumn s","title":"SortColumns"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#constructors","text":"Name Summary <init> SortColumns(statePersistableType: Class< P >) Used to define Sort.SortColumn s","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#properties","text":"Name Summary ASC val ASC: Direction constraintType val constraintType: VaultStateAttribute consumedTime val consumedTime: VaultStateAttribute contractStateType val contractStateType: VaultStateAttribute DESC val DESC: Direction entries val entries: LinkedHashSet<SortColumn> externalId val externalId: LinearStateAttribute issuerRef val issuerRef: FungibleStateAttribute lockId val lockId: VaultStateAttribute notaryName val notaryName: VaultStateAttribute quantity val quantity: FungibleStateAttribute recordedTime val recordedTime: VaultStateAttribute statePersistableType val statePersistableType: Class< P > stateRef val stateRef: CommonStateAttribute stateRefIndex val stateRefIndex: CommonStateAttribute stateRefTxnId val stateRefTxnId: CommonStateAttribute stateStatus val stateStatus: VaultStateAttribute uuid val uuid: LinearStateAttribute","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#functions","text":"Name Summary sort infix fun CommonStateAttribute.sort(value: Direction): Boolean infix fun FungibleStateAttribute.sort(value: Direction): Boolean infix fun LinearStateAttribute.sort(value: Direction): Boolean infix fun VaultStateAttribute.sort(value: Direction): Boolean infix fun FieldWrapper < P >.sort(value: Direction): Unit","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-a-s-c/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / ASC ASC \u00b6 val ASC: Direction","title":" a s c"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-a-s-c/#asc","text":"val ASC: Direction","title":"ASC"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-d-e-s-c/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / DESC DESC \u00b6 val DESC: Direction","title":" d e s c"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-d-e-s-c/#desc","text":"val DESC: Direction","title":"DESC"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / <init> <init> \u00b6 SortColumns(statePersistableType: Class< P >) Used to define Sort.SortColumn s","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-init-/#init","text":"SortColumns(statePersistableType: Class< P >) Used to define Sort.SortColumn s","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/constraint-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / constraintType constraintType \u00b6 val constraintType: VaultStateAttribute","title":"Constraint type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/constraint-type/#constrainttype","text":"val constraintType: VaultStateAttribute","title":"constraintType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/consumed-time/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / consumedTime consumedTime \u00b6 val consumedTime: VaultStateAttribute","title":"Consumed time"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/consumed-time/#consumedtime","text":"val consumedTime: VaultStateAttribute","title":"consumedTime"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/contract-state-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / contractStateType contractStateType \u00b6 val contractStateType: VaultStateAttribute","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/contract-state-type/#contractstatetype","text":"val contractStateType: VaultStateAttribute","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/entries/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / entries entries \u00b6 val entries: LinkedHashSet<SortColumn>","title":"Entries"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/entries/#entries","text":"val entries: LinkedHashSet<SortColumn>","title":"entries"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/external-id/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / externalId externalId \u00b6 val externalId: LinearStateAttribute","title":"External id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/external-id/#externalid","text":"val externalId: LinearStateAttribute","title":"externalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/issuer-ref/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / issuerRef issuerRef \u00b6 val issuerRef: FungibleStateAttribute","title":"Issuer ref"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/issuer-ref/#issuerref","text":"val issuerRef: FungibleStateAttribute","title":"issuerRef"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/lock-id/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / lockId lockId \u00b6 val lockId: VaultStateAttribute","title":"Lock id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/lock-id/#lockid","text":"val lockId: VaultStateAttribute","title":"lockId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/notary-name/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / notaryName notaryName \u00b6 val notaryName: VaultStateAttribute","title":"Notary name"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/notary-name/#notaryname","text":"val notaryName: VaultStateAttribute","title":"notaryName"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/quantity/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / quantity quantity \u00b6 val quantity: FungibleStateAttribute","title":"Quantity"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/quantity/#quantity","text":"val quantity: FungibleStateAttribute","title":"quantity"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/recorded-time/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / recordedTime recordedTime \u00b6 val recordedTime: VaultStateAttribute","title":"Recorded time"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/recorded-time/#recordedtime","text":"val recordedTime: VaultStateAttribute","title":"recordedTime"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/sort/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / sort sort \u00b6 infix fun CommonStateAttribute.sort(value: Direction): Boolean infix fun FungibleStateAttribute.sort(value: Direction): Boolean infix fun LinearStateAttribute.sort(value: Direction): Boolean infix fun VaultStateAttribute.sort(value: Direction): Boolean infix fun FieldWrapper < P >.sort(value: Direction): Unit","title":"Sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/sort/#sort","text":"infix fun CommonStateAttribute.sort(value: Direction): Boolean infix fun FungibleStateAttribute.sort(value: Direction): Boolean infix fun LinearStateAttribute.sort(value: Direction): Boolean infix fun VaultStateAttribute.sort(value: Direction): Boolean infix fun FieldWrapper < P >.sort(value: Direction): Unit","title":"sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-persistable-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / statePersistableType statePersistableType \u00b6 val statePersistableType: Class< P >","title":"State persistable type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-persistable-type/#statepersistabletype","text":"val statePersistableType: Class< P >","title":"statePersistableType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref-index/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / stateRefIndex stateRefIndex \u00b6 val stateRefIndex: CommonStateAttribute","title":"State ref index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref-index/#staterefindex","text":"val stateRefIndex: CommonStateAttribute","title":"stateRefIndex"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref-txn-id/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / stateRefTxnId stateRefTxnId \u00b6 val stateRefTxnId: CommonStateAttribute","title":"State ref txn id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref-txn-id/#statereftxnid","text":"val stateRefTxnId: CommonStateAttribute","title":"stateRefTxnId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / stateRef stateRef \u00b6 val stateRef: CommonStateAttribute","title":"State ref"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref/#stateref","text":"val stateRef: CommonStateAttribute","title":"stateRef"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-status/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / stateStatus stateStatus \u00b6 val stateStatus: VaultStateAttribute","title":"State status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-status/#statestatus","text":"val stateStatus: VaultStateAttribute","title":"stateStatus"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/uuid/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / uuid uuid \u00b6 val uuid: LinearStateAttribute","title":"Uuid"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/uuid/#uuid","text":"val uuid: LinearStateAttribute","title":"uuid"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeConsumedCondition TimeConsumedCondition \u00b6 class TimeConsumedCondition : TimeInstantTypeCondition Constructors \u00b6 Name Summary <init> TimeConsumedCondition()","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/#timeconsumedcondition","text":"class TimeConsumedCondition : TimeInstantTypeCondition","title":"TimeConsumedCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/#constructors","text":"Name Summary <init> TimeConsumedCondition()","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeConsumedCondition / <init> <init> \u00b6 TimeConsumedCondition()","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/-init-/#init","text":"TimeConsumedCondition()","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeInstantTypeCondition TimeInstantTypeCondition \u00b6 abstract class TimeInstantTypeCondition Constructors \u00b6 Name Summary <init> TimeInstantTypeCondition(type: TimeInstantType) Inheritors \u00b6 Name Summary TimeConsumedCondition class TimeConsumedCondition : TimeInstantTypeCondition TimeRecordedCondition class TimeRecordedCondition : TimeInstantTypeCondition","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/#timeinstanttypecondition","text":"abstract class TimeInstantTypeCondition","title":"TimeInstantTypeCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/#constructors","text":"Name Summary <init> TimeInstantTypeCondition(type: TimeInstantType)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/#inheritors","text":"Name Summary TimeConsumedCondition class TimeConsumedCondition : TimeInstantTypeCondition TimeRecordedCondition class TimeRecordedCondition : TimeInstantTypeCondition","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeInstantTypeCondition / <init> <init> \u00b6 TimeInstantTypeCondition(type: TimeInstantType)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/-init-/#init","text":"TimeInstantTypeCondition(type: TimeInstantType)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeRecordedCondition TimeRecordedCondition \u00b6 class TimeRecordedCondition : TimeInstantTypeCondition Constructors \u00b6 Name Summary <init> TimeRecordedCondition()","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/#timerecordedcondition","text":"class TimeRecordedCondition : TimeInstantTypeCondition","title":"TimeRecordedCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/#constructors","text":"Name Summary <init> TimeRecordedCondition()","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeRecordedCondition / <init> <init> \u00b6 TimeRecordedCondition()","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/-init-/#init","text":"TimeRecordedCondition()","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultCustomQueryCondition VaultCustomQueryCondition \u00b6 open class VaultCustomQueryCondition<L : StatePersistable> : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. Constructors \u00b6 Name Summary <init> VaultCustomQueryCondition(expression: CriteriaExpression< L , Boolean>, status: StateStatus)``VaultCustomQueryCondition(criterion: VaultCustomQueryCriteria< L >) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. Functions \u00b6 Name Summary toCriteria fun toCriteria(): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-condition/#vaultcustomquerycondition","text":"open class VaultCustomQueryCondition<L : StatePersistable> : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"VaultCustomQueryCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-condition/#constructors","text":"Name Summary <init> VaultCustomQueryCondition(expression: CriteriaExpression< L , Boolean>, status: StateStatus)``VaultCustomQueryCondition(criterion: VaultCustomQueryCriteria< L >) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-condition/#functions","text":"Name Summary toCriteria fun toCriteria(): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultCustomQueryCondition / <init> <init> \u00b6 VaultCustomQueryCondition(expression: CriteriaExpression< L , Boolean>, status: StateStatus)``VaultCustomQueryCondition(criterion: VaultCustomQueryCriteria< L >) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-condition/-init-/#init","text":"VaultCustomQueryCondition(expression: CriteriaExpression< L , Boolean>, status: StateStatus)``VaultCustomQueryCondition(criterion: VaultCustomQueryCriteria< L >) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultCustomQueryCondition / toCriteria toCriteria \u00b6 fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-condition/to-criteria/#tocriteria","text":"fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition VaultQueryCriteriaCondition \u00b6 abstract class VaultQueryCriteriaCondition<P : StatePersistable, out F : Fields < P >> : ConditionsCondition < P , F >, RootCondition < P > A ConditionsCondition extended by Vaultaire\u2019s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort Constructors \u00b6 Name Summary <init> VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List<StateRef>? = null, notary: List<AbstractParty>? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set<Type> = emptySet(), constraints: Set<ConstraintInfo> = emptySet(), externalIds: List<UUID> = emptyList(), participants: List<AbstractParty>? = null) A ConditionsCondition extended by Vaultaire\u2019s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort Properties \u00b6 Name Summary constraints open var constraints: Set<ConstraintInfo> constraintTypes open var constraintTypes: Set<Type> contractStateType abstract val contractStateType: Class<out ContractState> The target ContractState type externalIds open var externalIds: List<UUID> notary open var notary: List<AbstractParty>? participants open var participants: List<AbstractParty>? relevancyStatus open var relevancyStatus: RelevancyStatus rootCondition open val rootCondition: RootCondition < P > The root condition softLockingCondition open var softLockingCondition: SoftLockingCondition? statePersistableType abstract val statePersistableType: Class< P > The target StatePersistable type stateRefs open var stateRefs: List<StateRef>? status open var status: StateStatus timeCondition open var timeCondition: TimeCondition? timeConsumed val timeConsumed: TimeConsumedCondition timeRecorded val timeRecorded: TimeRecordedCondition Inherited Properties \u00b6 Name Summary fields abstract val fields: F The fields of the target StatePersistable type P Functions \u00b6 Name Summary aggregate fun aggregate(initializer: Aggregates < P >.() -> Unit): Unit greaterThan infix fun TimeInstantTypeCondition .greaterThan(instant: Instant): Unit greaterThanOrEqual infix fun TimeInstantTypeCondition .greaterThanOrEqual(instant: Instant): Unit gt infix fun TimeInstantTypeCondition .gt(instant: Instant): Unit gtw infix fun TimeInstantTypeCondition .gtw(instant: Instant): Unit lessThan infix fun TimeInstantTypeCondition .lessThan(instant: Instant): Unit lessThanOrEqual infix fun TimeInstantTypeCondition .lessThanOrEqual(instant: Instant): Unit lt infix fun TimeInstantTypeCondition .lt(instant: Instant): Unit ltw infix fun TimeInstantTypeCondition .ltw(instant: Instant): Unit orderBy fun orderBy(initializer: SortColumns < P >.() -> Unit): Unit toCriteria open fun toCriteria(): QueryCriteria fun toCriteria(ignoreAggregates: Boolean = false): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise toSort fun toSort(): Sort Inherited Functions \u00b6 Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition < P , F >.() -> Unit): Unit or fun or(initializer: CompositeCondition < P , F >.() -> Unit): Unit","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#vaultquerycriteriacondition","text":"abstract class VaultQueryCriteriaCondition<P : StatePersistable, out F : Fields < P >> : ConditionsCondition < P , F >, RootCondition < P > A ConditionsCondition extended by Vaultaire\u2019s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"VaultQueryCriteriaCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#constructors","text":"Name Summary <init> VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List<StateRef>? = null, notary: List<AbstractParty>? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set<Type> = emptySet(), constraints: Set<ConstraintInfo> = emptySet(), externalIds: List<UUID> = emptyList(), participants: List<AbstractParty>? = null) A ConditionsCondition extended by Vaultaire\u2019s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#properties","text":"Name Summary constraints open var constraints: Set<ConstraintInfo> constraintTypes open var constraintTypes: Set<Type> contractStateType abstract val contractStateType: Class<out ContractState> The target ContractState type externalIds open var externalIds: List<UUID> notary open var notary: List<AbstractParty>? participants open var participants: List<AbstractParty>? relevancyStatus open var relevancyStatus: RelevancyStatus rootCondition open val rootCondition: RootCondition < P > The root condition softLockingCondition open var softLockingCondition: SoftLockingCondition? statePersistableType abstract val statePersistableType: Class< P > The target StatePersistable type stateRefs open var stateRefs: List<StateRef>? status open var status: StateStatus timeCondition open var timeCondition: TimeCondition? timeConsumed val timeConsumed: TimeConsumedCondition timeRecorded val timeRecorded: TimeRecordedCondition","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#inherited-properties","text":"Name Summary fields abstract val fields: F The fields of the target StatePersistable type P","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#functions","text":"Name Summary aggregate fun aggregate(initializer: Aggregates < P >.() -> Unit): Unit greaterThan infix fun TimeInstantTypeCondition .greaterThan(instant: Instant): Unit greaterThanOrEqual infix fun TimeInstantTypeCondition .greaterThanOrEqual(instant: Instant): Unit gt infix fun TimeInstantTypeCondition .gt(instant: Instant): Unit gtw infix fun TimeInstantTypeCondition .gtw(instant: Instant): Unit lessThan infix fun TimeInstantTypeCondition .lessThan(instant: Instant): Unit lessThanOrEqual infix fun TimeInstantTypeCondition .lessThanOrEqual(instant: Instant): Unit lt infix fun TimeInstantTypeCondition .lt(instant: Instant): Unit ltw infix fun TimeInstantTypeCondition .ltw(instant: Instant): Unit orderBy fun orderBy(initializer: SortColumns < P >.() -> Unit): Unit toCriteria open fun toCriteria(): QueryCriteria fun toCriteria(ignoreAggregates: Boolean = false): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise toSort fun toSort(): Sort","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#inherited-functions","text":"Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition < P , F >.() -> Unit): Unit or fun or(initializer: CompositeCondition < P , F >.() -> Unit): Unit","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / <init> <init> \u00b6 VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List<StateRef>? = null, notary: List<AbstractParty>? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set<Type> = emptySet(), constraints: Set<ConstraintInfo> = emptySet(), externalIds: List<UUID> = emptyList(), participants: List<AbstractParty>? = null) A ConditionsCondition extended by Vaultaire\u2019s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/-init-/#init","text":"VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List<StateRef>? = null, notary: List<AbstractParty>? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set<Type> = emptySet(), constraints: Set<ConstraintInfo> = emptySet(), externalIds: List<UUID> = emptyList(), participants: List<AbstractParty>? = null) A ConditionsCondition extended by Vaultaire\u2019s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/aggregate/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / aggregate aggregate \u00b6 fun aggregate(initializer: Aggregates < P >.() -> Unit): Unit","title":"Aggregate"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/aggregate/#aggregate","text":"fun aggregate(initializer: Aggregates < P >.() -> Unit): Unit","title":"aggregate"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraint-types/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / constraintTypes constraintTypes \u00b6 open var constraintTypes: Set<Type> Overrides RootCondition.constraintTypes","title":"Constraint types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraint-types/#constrainttypes","text":"open var constraintTypes: Set<Type> Overrides RootCondition.constraintTypes","title":"constraintTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraints/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / constraints constraints \u00b6 open var constraints: Set<ConstraintInfo> Overrides RootCondition.constraints","title":"Constraints"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraints/#constraints","text":"open var constraints: Set<ConstraintInfo> Overrides RootCondition.constraints","title":"constraints"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/contract-state-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / contractStateType contractStateType \u00b6 abstract val contractStateType: Class<out ContractState> The target ContractState type","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/contract-state-type/#contractstatetype","text":"abstract val contractStateType: Class<out ContractState> The target ContractState type","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/external-ids/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / externalIds externalIds \u00b6 open var externalIds: List<UUID> Overrides RootCondition.externalIds","title":"External ids"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/external-ids/#externalids","text":"open var externalIds: List<UUID> Overrides RootCondition.externalIds","title":"externalIds"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/greater-than-or-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / greaterThanOrEqual greaterThanOrEqual \u00b6 infix fun TimeInstantTypeCondition .greaterThanOrEqual(instant: Instant): Unit","title":"Greater than or equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/greater-than-or-equal/#greaterthanorequal","text":"infix fun TimeInstantTypeCondition .greaterThanOrEqual(instant: Instant): Unit","title":"greaterThanOrEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/greater-than/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / greaterThan greaterThan \u00b6 infix fun TimeInstantTypeCondition .greaterThan(instant: Instant): Unit","title":"Greater than"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/greater-than/#greaterthan","text":"infix fun TimeInstantTypeCondition .greaterThan(instant: Instant): Unit","title":"greaterThan"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/gt/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / gt gt \u00b6 infix fun TimeInstantTypeCondition .gt(instant: Instant): Unit","title":"Gt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/gt/#gt","text":"infix fun TimeInstantTypeCondition .gt(instant: Instant): Unit","title":"gt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/gtw/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / gtw gtw \u00b6 infix fun TimeInstantTypeCondition .gtw(instant: Instant): Unit","title":"Gtw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/gtw/#gtw","text":"infix fun TimeInstantTypeCondition .gtw(instant: Instant): Unit","title":"gtw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/less-than-or-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / lessThanOrEqual lessThanOrEqual \u00b6 infix fun TimeInstantTypeCondition .lessThanOrEqual(instant: Instant): Unit","title":"Less than or equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/less-than-or-equal/#lessthanorequal","text":"infix fun TimeInstantTypeCondition .lessThanOrEqual(instant: Instant): Unit","title":"lessThanOrEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/less-than/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / lessThan lessThan \u00b6 infix fun TimeInstantTypeCondition .lessThan(instant: Instant): Unit","title":"Less than"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/less-than/#lessthan","text":"infix fun TimeInstantTypeCondition .lessThan(instant: Instant): Unit","title":"lessThan"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/lt/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / lt lt \u00b6 infix fun TimeInstantTypeCondition .lt(instant: Instant): Unit","title":"Lt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/lt/#lt","text":"infix fun TimeInstantTypeCondition .lt(instant: Instant): Unit","title":"lt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/ltw/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / ltw ltw \u00b6 infix fun TimeInstantTypeCondition .ltw(instant: Instant): Unit","title":"Ltw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/ltw/#ltw","text":"infix fun TimeInstantTypeCondition .ltw(instant: Instant): Unit","title":"ltw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/notary/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / notary notary \u00b6 open var notary: List<AbstractParty>? Overrides RootCondition.notary","title":"Notary"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/notary/#notary","text":"open var notary: List<AbstractParty>? Overrides RootCondition.notary","title":"notary"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/order-by/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / orderBy orderBy \u00b6 fun orderBy(initializer: SortColumns < P >.() -> Unit): Unit","title":"Order by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/order-by/#orderby","text":"fun orderBy(initializer: SortColumns < P >.() -> Unit): Unit","title":"orderBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/participants/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / participants participants \u00b6 open var participants: List<AbstractParty>? Overrides RootCondition.participants","title":"Participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/participants/#participants","text":"open var participants: List<AbstractParty>? Overrides RootCondition.participants","title":"participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/relevancy-status/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / relevancyStatus relevancyStatus \u00b6 open var relevancyStatus: RelevancyStatus Overrides RootCondition.relevancyStatus","title":"Relevancy status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/relevancy-status/#relevancystatus","text":"open var relevancyStatus: RelevancyStatus Overrides RootCondition.relevancyStatus","title":"relevancyStatus"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/root-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / rootCondition rootCondition \u00b6 open val rootCondition: RootCondition < P > Overrides ConditionsCondition.rootCondition The root condition","title":"Root condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/root-condition/#rootcondition","text":"open val rootCondition: RootCondition < P > Overrides ConditionsCondition.rootCondition The root condition","title":"rootCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/soft-locking-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / softLockingCondition softLockingCondition \u00b6 open var softLockingCondition: SoftLockingCondition? Overrides RootCondition.softLockingCondition","title":"Soft locking condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/soft-locking-condition/#softlockingcondition","text":"open var softLockingCondition: SoftLockingCondition? Overrides RootCondition.softLockingCondition","title":"softLockingCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-persistable-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / statePersistableType statePersistableType \u00b6 abstract val statePersistableType: Class< P > The target StatePersistable type","title":"State persistable type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-persistable-type/#statepersistabletype","text":"abstract val statePersistableType: Class< P > The target StatePersistable type","title":"statePersistableType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-refs/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / stateRefs stateRefs \u00b6 open var stateRefs: List<StateRef>? Overrides RootCondition.stateRefs","title":"State refs"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-refs/#staterefs","text":"open var stateRefs: List<StateRef>? Overrides RootCondition.stateRefs","title":"stateRefs"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/status/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / status status \u00b6 open var status: StateStatus Overrides RootCondition.status","title":"Status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/status/#status","text":"open var status: StateStatus Overrides RootCondition.status","title":"status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / timeCondition timeCondition \u00b6 open var timeCondition: TimeCondition? Overrides RootCondition.timeCondition","title":"Time condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-condition/#timecondition","text":"open var timeCondition: TimeCondition? Overrides RootCondition.timeCondition","title":"timeCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-consumed/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / timeConsumed timeConsumed \u00b6 val timeConsumed: TimeConsumedCondition","title":"Time consumed"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-consumed/#timeconsumed","text":"val timeConsumed: TimeConsumedCondition","title":"timeConsumed"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-recorded/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / timeRecorded timeRecorded \u00b6 val timeRecorded: TimeRecordedCondition","title":"Time recorded"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-recorded/#timerecorded","text":"val timeRecorded: TimeRecordedCondition","title":"timeRecorded"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / toCriteria toCriteria \u00b6 open fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise fun toCriteria(ignoreAggregates: Boolean = false): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise Parameters \u00b6 ignoreAggregates - whether to ignore aggregate functions. Corda paged queries can have either state or aggregate results, but not both.","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-criteria/#tocriteria","text":"open fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise fun toCriteria(ignoreAggregates: Boolean = false): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-criteria/#parameters","text":"ignoreAggregates - whether to ignore aggregate functions. Corda paged queries can have either state or aggregate results, but not both.","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-sort/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / toSort toSort \u00b6 fun toSort(): Sort","title":"To sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-sort/#tosort","text":"fun toSort(): Sort","title":"toSort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/","text":"com.github.manosbatsis.vaultaire.dto Package com.github.manosbatsis.vaultaire.dto \u00b6 Types \u00b6 Name Summary AccountParty data class AccountParty Convenient \u201cparticipant\u201d type that combines a known Corda Account ID with a corresponding anonymous party. VaultaireBaseStateClientDto interface VaultaireBaseStateClientDto<T : ContractState, S : StateService < T >> : VaultaireModelClientDto < T , S > Base interface for client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched . VaultaireDto interface VaultaireDto<T : Any> : VaultaireDtoBase Implemented by DTOs with no support for type conversion VaultaireDtoBase interface VaultaireDtoBase VaultaireModelClientDto interface VaultaireModelClientDto<T : Any, S : NodeServiceDelegate > : VaultaireDtoBase Implemented by client, REST-friendly DTOs targeting model classes, i.e. non-ContractState types, with type conversion support using a NodeService for toTargetType and toPatched . VaultaireStateClientDto interface VaultaireStateClientDto<T : ContractState> : VaultaireBaseStateClientDto < T , StateService < T >> Implemented by client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched .","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/#package-comgithubmanosbatsisvaultairedto","text":"","title":"Package com.github.manosbatsis.vaultaire.dto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/#types","text":"Name Summary AccountParty data class AccountParty Convenient \u201cparticipant\u201d type that combines a known Corda Account ID with a corresponding anonymous party. VaultaireBaseStateClientDto interface VaultaireBaseStateClientDto<T : ContractState, S : StateService < T >> : VaultaireModelClientDto < T , S > Base interface for client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched . VaultaireDto interface VaultaireDto<T : Any> : VaultaireDtoBase Implemented by DTOs with no support for type conversion VaultaireDtoBase interface VaultaireDtoBase VaultaireModelClientDto interface VaultaireModelClientDto<T : Any, S : NodeServiceDelegate > : VaultaireDtoBase Implemented by client, REST-friendly DTOs targeting model classes, i.e. non-ContractState types, with type conversion support using a NodeService for toTargetType and toPatched . VaultaireStateClientDto interface VaultaireStateClientDto<T : ContractState> : VaultaireBaseStateClientDto < T , StateService < T >> Implemented by client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched .","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-state-client-dto/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireBaseStateClientDto VaultaireBaseStateClientDto \u00b6 interface VaultaireBaseStateClientDto<T : ContractState, S : StateService < T >> : VaultaireModelClientDto < T , S > Base interface for client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched . Inherited Functions \u00b6 Name Summary toName open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name toNameOrNull open fun toNameOrNull(party: Party?): CordaX500Name? toParty open fun toParty(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefault open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefaultNullable open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party? toPartyOrNull open fun toPartyOrNull(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party? toPatched abstract fun toPatched(original: T , stateService: S ): T Create a patched copy of the given T instance, updated using this DTO\u2019s non-null properties toTargetType abstract fun toTargetType(stateService: S ): T Create an instance of T , using this DTO\u2019s properties. May throw a IllegalStateException if there is mot enough information to do so. Inheritors \u00b6 Name Summary VaultaireStateClientDto interface VaultaireStateClientDto<T : ContractState> : VaultaireBaseStateClientDto < T , StateService < T >> Implemented by client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched .","title":" vaultaire base state client dto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-state-client-dto/#vaultairebasestateclientdto","text":"interface VaultaireBaseStateClientDto<T : ContractState, S : StateService < T >> : VaultaireModelClientDto < T , S > Base interface for client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched .","title":"VaultaireBaseStateClientDto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-state-client-dto/#inherited-functions","text":"Name Summary toName open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name toNameOrNull open fun toNameOrNull(party: Party?): CordaX500Name? toParty open fun toParty(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefault open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefaultNullable open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party? toPartyOrNull open fun toPartyOrNull(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party? toPatched abstract fun toPatched(original: T , stateService: S ): T Create a patched copy of the given T instance, updated using this DTO\u2019s non-null properties toTargetType abstract fun toTargetType(stateService: S ): T Create an instance of T , using this DTO\u2019s properties. May throw a IllegalStateException if there is mot enough information to do so.","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-state-client-dto/#inheritors","text":"Name Summary VaultaireStateClientDto interface VaultaireStateClientDto<T : ContractState> : VaultaireBaseStateClientDto < T , StateService < T >> Implemented by client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched .","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-state-client-dto/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireStateClientDto VaultaireStateClientDto \u00b6 interface VaultaireStateClientDto<T : ContractState> : VaultaireBaseStateClientDto < T , StateService < T >> Implemented by client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched .","title":" vaultaire state client dto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-state-client-dto/#vaultairestateclientdto","text":"interface VaultaireStateClientDto<T : ContractState> : VaultaireBaseStateClientDto < T , StateService < T >> Implemented by client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched .","title":"VaultaireStateClientDto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/","text":"com.github.manosbatsis.vaultaire.dto / AccountParty AccountParty \u00b6 data class AccountParty Convenient \u201cparticipant\u201d type that combines a known Corda Account ID with a corresponding anonymous party. Constructors \u00b6 Name Summary <init> AccountParty(identifier: UUID, name: String, party: AnonymousParty, externalId: String? = null) Convenient \u201cparticipant\u201d type that combines a known Corda Account ID with a corresponding anonymous party. Properties \u00b6 Name Summary externalId var externalId: String? The account external ID, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.identifier.externalId identifier var identifier: UUID The account ID, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.identifier.id name var name: String The account name, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.name party var party: AnonymousParty The account party Functions \u00b6 Name Summary hasMatchingIdentifier fun hasMatchingIdentifier(other: AccountParty ?): Boolean","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/#accountparty","text":"data class AccountParty Convenient \u201cparticipant\u201d type that combines a known Corda Account ID with a corresponding anonymous party.","title":"AccountParty"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/#constructors","text":"Name Summary <init> AccountParty(identifier: UUID, name: String, party: AnonymousParty, externalId: String? = null) Convenient \u201cparticipant\u201d type that combines a known Corda Account ID with a corresponding anonymous party.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/#properties","text":"Name Summary externalId var externalId: String? The account external ID, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.identifier.externalId identifier var identifier: UUID The account ID, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.identifier.id name var name: String The account name, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.name party var party: AnonymousParty The account party","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/#functions","text":"Name Summary hasMatchingIdentifier fun hasMatchingIdentifier(other: AccountParty ?): Boolean","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/-init-/","text":"com.github.manosbatsis.vaultaire.dto / AccountParty / <init> <init> \u00b6 AccountParty(identifier: UUID, name: String, party: AnonymousParty, externalId: String? = null) Convenient \u201cparticipant\u201d type that combines a known Corda Account ID with a corresponding anonymous party.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/-init-/#init","text":"AccountParty(identifier: UUID, name: String, party: AnonymousParty, externalId: String? = null) Convenient \u201cparticipant\u201d type that combines a known Corda Account ID with a corresponding anonymous party.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/external-id/","text":"com.github.manosbatsis.vaultaire.dto / AccountParty / externalId externalId \u00b6 var externalId: String? The account external ID, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.identifier.externalId","title":"External id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/external-id/#externalid","text":"var externalId: String? The account external ID, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.identifier.externalId","title":"externalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/has-matching-identifier/","text":"com.github.manosbatsis.vaultaire.dto / AccountParty / hasMatchingIdentifier hasMatchingIdentifier \u00b6 fun hasMatchingIdentifier(other: AccountParty ?): Boolean","title":"Has matching identifier"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/has-matching-identifier/#hasmatchingidentifier","text":"fun hasMatchingIdentifier(other: AccountParty ?): Boolean","title":"hasMatchingIdentifier"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/identifier/","text":"com.github.manosbatsis.vaultaire.dto / AccountParty / identifier identifier \u00b6 var identifier: UUID The account ID, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.identifier.id","title":"Identifier"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/identifier/#identifier","text":"var identifier: UUID The account ID, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.identifier.id","title":"identifier"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/name/","text":"com.github.manosbatsis.vaultaire.dto / AccountParty / name name \u00b6 var name: String The account name, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.name","title":"Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/name/#name","text":"var name: String The account name, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.name","title":"name"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/party/","text":"com.github.manosbatsis.vaultaire.dto / AccountParty / party party \u00b6 var party: AnonymousParty The account party","title":"Party"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/party/#party","text":"var party: AnonymousParty The account party","title":"party"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireDto VaultaireDto \u00b6 interface VaultaireDto<T : Any> : VaultaireDtoBase Implemented by DTOs with no support for type conversion Functions \u00b6 Name Summary toPatched abstract fun toPatched(original: T ): T Create a patched copy of the given T instance, updated using this DTO\u2019s non-null properties toTargetType abstract fun toTargetType(): T Create an instance of T , using this DTO\u2019s properties. May throw a IllegalStateException if there is mot enough information to do so. Inherited Functions \u00b6 Name Summary errNull open fun <X> errNull(fieldName: String): X","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto/#vaultairedto","text":"interface VaultaireDto<T : Any> : VaultaireDtoBase Implemented by DTOs with no support for type conversion","title":"VaultaireDto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto/#functions","text":"Name Summary toPatched abstract fun toPatched(original: T ): T Create a patched copy of the given T instance, updated using this DTO\u2019s non-null properties toTargetType abstract fun toTargetType(): T Create an instance of T , using this DTO\u2019s properties. May throw a IllegalStateException if there is mot enough information to do so.","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto/#inherited-functions","text":"Name Summary errNull open fun <X> errNull(fieldName: String): X","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto/to-patched/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireDto / toPatched toPatched \u00b6 abstract fun toPatched(original: T ): T Create a patched copy of the given T instance, updated using this DTO\u2019s non-null properties","title":"To patched"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto/to-patched/#topatched","text":"abstract fun toPatched(original: T ): T Create a patched copy of the given T instance, updated using this DTO\u2019s non-null properties","title":"toPatched"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto/to-target-type/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireDto / toTargetType toTargetType \u00b6 abstract fun toTargetType(): T Create an instance of T , using this DTO\u2019s properties. May throw a IllegalStateException if there is mot enough information to do so.","title":"To target type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto/to-target-type/#totargettype","text":"abstract fun toTargetType(): T Create an instance of T , using this DTO\u2019s properties. May throw a IllegalStateException if there is mot enough information to do so.","title":"toTargetType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto-base/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireDtoBase VaultaireDtoBase \u00b6 interface VaultaireDtoBase Functions \u00b6 Name Summary errNull open fun <X> errNull(fieldName: String): X Companion Object Properties \u00b6 Name Summary ERR_NULL const val ERR_NULL: String Inheritors \u00b6 Name Summary VaultaireDto interface VaultaireDto<T : Any> : VaultaireDtoBase Implemented by DTOs with no support for type conversion VaultaireModelClientDto interface VaultaireModelClientDto<T : Any, S : NodeServiceDelegate > : VaultaireDtoBase Implemented by client, REST-friendly DTOs targeting model classes, i.e. non-ContractState types, with type conversion support using a NodeService for toTargetType and toPatched .","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto-base/#vaultairedtobase","text":"interface VaultaireDtoBase","title":"VaultaireDtoBase"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto-base/#functions","text":"Name Summary errNull open fun <X> errNull(fieldName: String): X","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto-base/#companion-object-properties","text":"Name Summary ERR_NULL const val ERR_NULL: String","title":"Companion Object Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto-base/#inheritors","text":"Name Summary VaultaireDto interface VaultaireDto<T : Any> : VaultaireDtoBase Implemented by DTOs with no support for type conversion VaultaireModelClientDto interface VaultaireModelClientDto<T : Any, S : NodeServiceDelegate > : VaultaireDtoBase Implemented by client, REST-friendly DTOs targeting model classes, i.e. non-ContractState types, with type conversion support using a NodeService for toTargetType and toPatched .","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto-base/-e-r-r_-n-u-l-l/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireDtoBase / ERR_NULL ERR_NULL \u00b6 protected const val ERR_NULL: String","title":" e r r  n u l l"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto-base/-e-r-r_-n-u-l-l/#err_null","text":"protected const val ERR_NULL: String","title":"ERR_NULL"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto-base/err-null/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireDtoBase / errNull errNull \u00b6 open fun <X> errNull(fieldName: String): X","title":"Err null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-dto-base/err-null/#errnull","text":"open fun <X> errNull(fieldName: String): X","title":"errNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireModelClientDto VaultaireModelClientDto \u00b6 interface VaultaireModelClientDto<T : Any, S : NodeServiceDelegate > : VaultaireDtoBase Implemented by client, REST-friendly DTOs targeting model classes, i.e. non-ContractState types, with type conversion support using a NodeService for toTargetType and toPatched . Functions \u00b6 Name Summary toName open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name toNameOrNull open fun toNameOrNull(party: Party?): CordaX500Name? toParty open fun toParty(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefault open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefaultNullable open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party? toPartyOrNull open fun toPartyOrNull(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party? toPatched abstract fun toPatched(original: T , stateService: S ): T Create a patched copy of the given T instance, updated using this DTO\u2019s non-null properties toTargetType abstract fun toTargetType(stateService: S ): T Create an instance of T , using this DTO\u2019s properties. May throw a IllegalStateException if there is mot enough information to do so. Inherited Functions \u00b6 Name Summary errNull open fun <X> errNull(fieldName: String): X Inheritors \u00b6 Name Summary VaultaireBaseStateClientDto interface VaultaireBaseStateClientDto<T : ContractState, S : StateService < T >> : VaultaireModelClientDto < T , S > Base interface for client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched .","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/#vaultairemodelclientdto","text":"interface VaultaireModelClientDto<T : Any, S : NodeServiceDelegate > : VaultaireDtoBase Implemented by client, REST-friendly DTOs targeting model classes, i.e. non-ContractState types, with type conversion support using a NodeService for toTargetType and toPatched .","title":"VaultaireModelClientDto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/#functions","text":"Name Summary toName open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name toNameOrNull open fun toNameOrNull(party: Party?): CordaX500Name? toParty open fun toParty(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefault open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefaultNullable open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party? toPartyOrNull open fun toPartyOrNull(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party? toPatched abstract fun toPatched(original: T , stateService: S ): T Create a patched copy of the given T instance, updated using this DTO\u2019s non-null properties toTargetType abstract fun toTargetType(stateService: S ): T Create an instance of T , using this DTO\u2019s properties. May throw a IllegalStateException if there is mot enough information to do so.","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/#inherited-functions","text":"Name Summary errNull open fun <X> errNull(fieldName: String): X","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/#inheritors","text":"Name Summary VaultaireBaseStateClientDto interface VaultaireBaseStateClientDto<T : ContractState, S : StateService < T >> : VaultaireModelClientDto < T , S > Base interface for client, REST-friendly DTOs, targeting ContractState types, with type conversion support using a StateService for toTargetType and toPatched .","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-name-or-null/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireModelClientDto / toNameOrNull toNameOrNull \u00b6 open fun toNameOrNull(party: Party?): CordaX500Name?","title":"To name or null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-name-or-null/#tonameornull","text":"open fun toNameOrNull(party: Party?): CordaX500Name?","title":"toNameOrNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-name/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireModelClientDto / toName toName \u00b6 open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name","title":"To name"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-name/#toname","text":"open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name","title":"toName"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-party-or-default-nullable/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireModelClientDto / toPartyOrDefaultNullable toPartyOrDefaultNullable \u00b6 open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party?","title":"To party or default nullable"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-party-or-default-nullable/#topartyordefaultnullable","text":"open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party?","title":"toPartyOrDefaultNullable"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-party-or-default/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireModelClientDto / toPartyOrDefault toPartyOrDefault \u00b6 open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party","title":"To party or default"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-party-or-default/#topartyordefault","text":"open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party","title":"toPartyOrDefault"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-party-or-null/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireModelClientDto / toPartyOrNull toPartyOrNull \u00b6 open fun toPartyOrNull(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party?","title":"To party or null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-party-or-null/#topartyornull","text":"open fun toPartyOrNull(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party?","title":"toPartyOrNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-party/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireModelClientDto / toParty toParty \u00b6 open fun toParty(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party","title":"To party"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-party/#toparty","text":"open fun toParty(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party","title":"toParty"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-patched/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireModelClientDto / toPatched toPatched \u00b6 abstract fun toPatched(original: T , stateService: S ): T Create a patched copy of the given T instance, updated using this DTO\u2019s non-null properties","title":"To patched"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-patched/#topatched","text":"abstract fun toPatched(original: T , stateService: S ): T Create a patched copy of the given T instance, updated using this DTO\u2019s non-null properties","title":"toPatched"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-target-type/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireModelClientDto / toTargetType toTargetType \u00b6 abstract fun toTargetType(stateService: S ): T Create an instance of T , using this DTO\u2019s properties. May throw a IllegalStateException if there is mot enough information to do so.","title":"To target type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-model-client-dto/to-target-type/#totargettype","text":"abstract fun toTargetType(stateService: S ): T Create an instance of T , using this DTO\u2019s properties. May throw a IllegalStateException if there is mot enough information to do so.","title":"toTargetType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/","text":"com.github.manosbatsis.vaultaire.dto.attachment Package com.github.manosbatsis.vaultaire.dto.attachment \u00b6 Types \u00b6 Name Summary Attachment data class Attachment : Closeable Data transfer object representing an attachment to be persisted in the vault AttachmentFile data class AttachmentFile Data transfer object representing an attachment file to be persisted in the vault AttachmentReceipt class AttachmentReceipt Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable.","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/#package-comgithubmanosbatsisvaultairedtoattachment","text":"","title":"Package com.github.manosbatsis.vaultaire.dto.attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/#types","text":"Name Summary Attachment data class Attachment : Closeable Data transfer object representing an attachment to be persisted in the vault AttachmentFile data class AttachmentFile Data transfer object representing an attachment file to be persisted in the vault AttachmentReceipt class AttachmentReceipt Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable.","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/","text":"com.github.manosbatsis.vaultaire.dto.attachment / Attachment Attachment \u00b6 data class Attachment : Closeable Data transfer object representing an attachment to be persisted in the vault Constructors \u00b6 Name Summary <init> Attachment(tmpFile: File? = null, inputStream: InputStream, filenames: List<String>, original: Boolean = false) Data transfer object representing an attachment to be persisted in the vault Properties \u00b6 Name Summary filenames val filenames: List<String> The files contained in the attachment archive inputStream val inputStream: InputStream The attachment input stream to upload original val original: Boolean true if an archive as originally uploaded, false if automatically created to save in the vault tmpFile val tmpFile: File? The temporary file backing this attachment, if any Functions \u00b6 Name Summary close fun close(): Unit","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/#attachment","text":"data class Attachment : Closeable Data transfer object representing an attachment to be persisted in the vault","title":"Attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/#constructors","text":"Name Summary <init> Attachment(tmpFile: File? = null, inputStream: InputStream, filenames: List<String>, original: Boolean = false) Data transfer object representing an attachment to be persisted in the vault","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/#properties","text":"Name Summary filenames val filenames: List<String> The files contained in the attachment archive inputStream val inputStream: InputStream The attachment input stream to upload original val original: Boolean true if an archive as originally uploaded, false if automatically created to save in the vault tmpFile val tmpFile: File? The temporary file backing this attachment, if any","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/#functions","text":"Name Summary close fun close(): Unit","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/-init-/","text":"com.github.manosbatsis.vaultaire.dto.attachment / Attachment / <init> <init> \u00b6 Attachment(tmpFile: File? = null, inputStream: InputStream, filenames: List<String>, original: Boolean = false) Data transfer object representing an attachment to be persisted in the vault","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/-init-/#init","text":"Attachment(tmpFile: File? = null, inputStream: InputStream, filenames: List<String>, original: Boolean = false) Data transfer object representing an attachment to be persisted in the vault","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/close/","text":"com.github.manosbatsis.vaultaire.dto.attachment / Attachment / close close \u00b6 fun close(): Unit","title":"Close"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/close/#close","text":"fun close(): Unit","title":"close"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/filenames/","text":"com.github.manosbatsis.vaultaire.dto.attachment / Attachment / filenames filenames \u00b6 val filenames: List<String> The files contained in the attachment archive","title":"Filenames"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/filenames/#filenames","text":"val filenames: List<String> The files contained in the attachment archive","title":"filenames"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/input-stream/","text":"com.github.manosbatsis.vaultaire.dto.attachment / Attachment / inputStream inputStream \u00b6 val inputStream: InputStream The attachment input stream to upload","title":"Input stream"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/input-stream/#inputstream","text":"val inputStream: InputStream The attachment input stream to upload","title":"inputStream"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/original/","text":"com.github.manosbatsis.vaultaire.dto.attachment / Attachment / original original \u00b6 val original: Boolean true if an archive as originally uploaded, false if automatically created to save in the vault","title":"Original"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/original/#original","text":"val original: Boolean true if an archive as originally uploaded, false if automatically created to save in the vault","title":"original"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/tmp-file/","text":"com.github.manosbatsis.vaultaire.dto.attachment / Attachment / tmpFile tmpFile \u00b6 val tmpFile: File? The temporary file backing this attachment, if any","title":"Tmp file"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/tmp-file/#tmpfile","text":"val tmpFile: File? The temporary file backing this attachment, if any","title":"tmpFile"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentFile AttachmentFile \u00b6 data class AttachmentFile Data transfer object representing an attachment file to be persisted in the vault Constructors \u00b6 Name Summary <init> AttachmentFile(name: String, originalFilename: String, inputStream: InputStream, size: Long, contentType: String?) Data transfer object representing an attachment file to be persisted in the vault Properties \u00b6 Name Summary contentType val contentType: String? inputStream val inputStream: InputStream name val name: String originalFilename val originalFilename: String size val size: Long","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/#attachmentfile","text":"data class AttachmentFile Data transfer object representing an attachment file to be persisted in the vault","title":"AttachmentFile"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/#constructors","text":"Name Summary <init> AttachmentFile(name: String, originalFilename: String, inputStream: InputStream, size: Long, contentType: String?) Data transfer object representing an attachment file to be persisted in the vault","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/#properties","text":"Name Summary contentType val contentType: String? inputStream val inputStream: InputStream name val name: String originalFilename val originalFilename: String size val size: Long","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/-init-/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentFile / <init> <init> \u00b6 AttachmentFile(name: String, originalFilename: String, inputStream: InputStream, size: Long, contentType: String?) Data transfer object representing an attachment file to be persisted in the vault","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/-init-/#init","text":"AttachmentFile(name: String, originalFilename: String, inputStream: InputStream, size: Long, contentType: String?) Data transfer object representing an attachment file to be persisted in the vault","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/content-type/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentFile / contentType contentType \u00b6 val contentType: String?","title":"Content type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/content-type/#contenttype","text":"val contentType: String?","title":"contentType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/input-stream/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentFile / inputStream inputStream \u00b6 val inputStream: InputStream","title":"Input stream"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/input-stream/#inputstream","text":"val inputStream: InputStream","title":"inputStream"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/name/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentFile / name name \u00b6 val name: String","title":"Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/name/#name","text":"val name: String","title":"name"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/original-filename/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentFile / originalFilename originalFilename \u00b6 val originalFilename: String","title":"Original filename"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/original-filename/#originalfilename","text":"val originalFilename: String","title":"originalFilename"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/size/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentFile / size size \u00b6 val size: Long","title":"Size"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/size/#size","text":"val size: Long","title":"size"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentReceipt AttachmentReceipt \u00b6 class AttachmentReceipt Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable. Constructors \u00b6 Name Summary <init> AttachmentReceipt(date: Date? = null, hash: String? = null, files: List<String> = emptyList(), author: String? = null, savedOriginal: Boolean = false) Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable. Properties \u00b6 Name Summary author var author: String? The attachment authoring organization date var date: Date? The datetime of attachment persistence to the vault files var files: List<String> The attached files hash var hash: String? The attachment net.corda.core.crypto.SecureHash string savedOriginal var savedOriginal: Boolean Whether an original archive was persisted in the vault, false if automatically created","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/#attachmentreceipt","text":"class AttachmentReceipt Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable.","title":"AttachmentReceipt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/#constructors","text":"Name Summary <init> AttachmentReceipt(date: Date? = null, hash: String? = null, files: List<String> = emptyList(), author: String? = null, savedOriginal: Boolean = false) Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/#properties","text":"Name Summary author var author: String? The attachment authoring organization date var date: Date? The datetime of attachment persistence to the vault files var files: List<String> The attached files hash var hash: String? The attachment net.corda.core.crypto.SecureHash string savedOriginal var savedOriginal: Boolean Whether an original archive was persisted in the vault, false if automatically created","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/-init-/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentReceipt / <init> <init> \u00b6 AttachmentReceipt(date: Date? = null, hash: String? = null, files: List<String> = emptyList(), author: String? = null, savedOriginal: Boolean = false) Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/-init-/#init","text":"AttachmentReceipt(date: Date? = null, hash: String? = null, files: List<String> = emptyList(), author: String? = null, savedOriginal: Boolean = false) Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/author/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentReceipt / author author \u00b6 var author: String? The attachment authoring organization","title":"Author"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/author/#author","text":"var author: String? The attachment authoring organization","title":"author"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/date/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentReceipt / date date \u00b6 var date: Date? The datetime of attachment persistence to the vault","title":"Date"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/date/#date","text":"var date: Date? The datetime of attachment persistence to the vault","title":"date"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/files/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentReceipt / files files \u00b6 var files: List<String> The attached files","title":"Files"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/files/#files","text":"var files: List<String> The attached files","title":"files"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/hash/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentReceipt / hash hash \u00b6 var hash: String? The attachment net.corda.core.crypto.SecureHash string","title":"Hash"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/hash/#hash","text":"var hash: String? The attachment net.corda.core.crypto.SecureHash string","title":"hash"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/saved-original/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentReceipt / savedOriginal savedOriginal \u00b6 var savedOriginal: Boolean Whether an original archive was persisted in the vault, false if automatically created","title":"Saved original"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/saved-original/#savedoriginal","text":"var savedOriginal: Boolean Whether an original archive was persisted in the vault, false if automatically created","title":"savedOriginal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/","text":"com.github.manosbatsis.vaultaire.dto.info Package com.github.manosbatsis.vaultaire.dto.info \u00b6 Types \u00b6 Name Summary ExtendedNodeInfo data class ExtendedNodeInfo NetworkInfo data class NetworkInfo","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/#package-comgithubmanosbatsisvaultairedtoinfo","text":"","title":"Package com.github.manosbatsis.vaultaire.dto.info"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/#types","text":"Name Summary ExtendedNodeInfo data class ExtendedNodeInfo NetworkInfo data class NetworkInfo","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo ExtendedNodeInfo \u00b6 data class ExtendedNodeInfo Constructors \u00b6 Name Summary <init> ExtendedNodeInfo(platformVersion: Int, identity: Party, identities: List<Party>, notaries: List<Party>, flows: List<String>, addresses: List<NetworkHostAndPort>) Properties \u00b6 Name Summary addresses val addresses: List<NetworkHostAndPort> flows val flows: List<String> identities val identities: List<Party> identity val identity: Party notaries val notaries: List<Party> platformVersion val platformVersion: Int","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/#extendednodeinfo","text":"data class ExtendedNodeInfo","title":"ExtendedNodeInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/#constructors","text":"Name Summary <init> ExtendedNodeInfo(platformVersion: Int, identity: Party, identities: List<Party>, notaries: List<Party>, flows: List<String>, addresses: List<NetworkHostAndPort>)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/#properties","text":"Name Summary addresses val addresses: List<NetworkHostAndPort> flows val flows: List<String> identities val identities: List<Party> identity val identity: Party notaries val notaries: List<Party> platformVersion val platformVersion: Int","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/-init-/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo / <init> <init> \u00b6 ExtendedNodeInfo(platformVersion: Int, identity: Party, identities: List<Party>, notaries: List<Party>, flows: List<String>, addresses: List<NetworkHostAndPort>)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/-init-/#init","text":"ExtendedNodeInfo(platformVersion: Int, identity: Party, identities: List<Party>, notaries: List<Party>, flows: List<String>, addresses: List<NetworkHostAndPort>)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/addresses/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo / addresses addresses \u00b6 val addresses: List<NetworkHostAndPort>","title":"Addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/addresses/#addresses","text":"val addresses: List<NetworkHostAndPort>","title":"addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/flows/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo / flows flows \u00b6 val flows: List<String>","title":"Flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/flows/#flows","text":"val flows: List<String>","title":"flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/identities/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo / identities identities \u00b6 val identities: List<Party>","title":"Identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/identities/#identities","text":"val identities: List<Party>","title":"identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/identity/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo / identity identity \u00b6 val identity: Party","title":"Identity"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/identity/#identity","text":"val identity: Party","title":"identity"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/notaries/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo / notaries notaries \u00b6 val notaries: List<Party>","title":"Notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/notaries/#notaries","text":"val notaries: List<Party>","title":"notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/platform-version/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo / platformVersion platformVersion \u00b6 val platformVersion: Int","title":"Platform version"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/platform-version/#platformversion","text":"val platformVersion: Int","title":"platformVersion"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/","text":"com.github.manosbatsis.vaultaire.dto.info / NetworkInfo NetworkInfo \u00b6 data class NetworkInfo Constructors \u00b6 Name Summary <init> NetworkInfo(nodes: Map<String, ExtendedNodeInfo >) Properties \u00b6 Name Summary nodes val nodes: Map<String, ExtendedNodeInfo >","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/#networkinfo","text":"data class NetworkInfo","title":"NetworkInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/#constructors","text":"Name Summary <init> NetworkInfo(nodes: Map<String, ExtendedNodeInfo >)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/#properties","text":"Name Summary nodes val nodes: Map<String, ExtendedNodeInfo >","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/-init-/","text":"com.github.manosbatsis.vaultaire.dto.info / NetworkInfo / <init> <init> \u00b6 NetworkInfo(nodes: Map<String, ExtendedNodeInfo >)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/-init-/#init","text":"NetworkInfo(nodes: Map<String, ExtendedNodeInfo >)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/nodes/","text":"com.github.manosbatsis.vaultaire.dto.info / NetworkInfo / nodes nodes \u00b6 val nodes: Map<String, ExtendedNodeInfo >","title":"Nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/nodes/#nodes","text":"val nodes: Map<String, ExtendedNodeInfo >","title":"nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/","text":"com.github.manosbatsis.vaultaire.registry Package com.github.manosbatsis.vaultaire.registry \u00b6 Types \u00b6 Name Summary Registry object Registry","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/#package-comgithubmanosbatsisvaultaireregistry","text":"","title":"Package com.github.manosbatsis.vaultaire.registry"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/#types","text":"Name Summary Registry object Registry","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/","text":"com.github.manosbatsis.vaultaire.registry / Registry Registry \u00b6 object Registry Functions \u00b6 Name Summary getServices fun getServices(): Map<Class<*>, Class<*>> getStateServiceType fun <T : ContractState, S : StateService < T >> getStateServiceType(contractStateType: Class< T >): Class< S >? registerQueryDsl fun <P : StatePersistable, F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> registerQueryDsl(keyType: KClass< P >, queryCriteriaType: KClass< Q >): Class<*>? registerService fun <T : ContractState, P : StatePersistable, F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >, S : ExtendedStateService < T , P , F , Q >> registerService(keyType: KClass< T >, serviceType: KClass< S >): Class<*>? fun registerService(keyType: Class<out ContractState>, serviceType: Class<out ExtendedStateService <*, *, *, *>>): Class<*>?","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/#registry","text":"object Registry","title":"Registry"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/#functions","text":"Name Summary getServices fun getServices(): Map<Class<*>, Class<*>> getStateServiceType fun <T : ContractState, S : StateService < T >> getStateServiceType(contractStateType: Class< T >): Class< S >? registerQueryDsl fun <P : StatePersistable, F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> registerQueryDsl(keyType: KClass< P >, queryCriteriaType: KClass< Q >): Class<*>? registerService fun <T : ContractState, P : StatePersistable, F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >, S : ExtendedStateService < T , P , F , Q >> registerService(keyType: KClass< T >, serviceType: KClass< S >): Class<*>? fun registerService(keyType: Class<out ContractState>, serviceType: Class<out ExtendedStateService <*, *, *, *>>): Class<*>?","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/get-services/","text":"com.github.manosbatsis.vaultaire.registry / Registry / getServices getServices \u00b6 fun getServices(): Map<Class<*>, Class<*>>","title":"Get services"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/get-services/#getservices","text":"fun getServices(): Map<Class<*>, Class<*>>","title":"getServices"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/get-state-service-type/","text":"com.github.manosbatsis.vaultaire.registry / Registry / getStateServiceType getStateServiceType \u00b6 fun <T : ContractState, S : StateService < T >> getStateServiceType(contractStateType: Class< T >): Class< S >?","title":"Get state service type"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/get-state-service-type/#getstateservicetype","text":"fun <T : ContractState, S : StateService < T >> getStateServiceType(contractStateType: Class< T >): Class< S >?","title":"getStateServiceType"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-query-dsl/","text":"com.github.manosbatsis.vaultaire.registry / Registry / registerQueryDsl registerQueryDsl \u00b6 fun <P : StatePersistable, F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> registerQueryDsl(keyType: KClass< P >, queryCriteriaType: KClass< Q >): Class<*>?","title":"Register query dsl"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-query-dsl/#registerquerydsl","text":"fun <P : StatePersistable, F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> registerQueryDsl(keyType: KClass< P >, queryCriteriaType: KClass< Q >): Class<*>?","title":"registerQueryDsl"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-service/","text":"com.github.manosbatsis.vaultaire.registry / Registry / registerService registerService \u00b6 fun <T : ContractState, P : StatePersistable, F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >, S : ExtendedStateService < T , P , F , Q >> registerService(keyType: KClass< T >, serviceType: KClass< S >): Class<*>? fun registerService(keyType: Class<out ContractState>, serviceType: Class<out ExtendedStateService <*, *, *, *>>): Class<*>?","title":"Register service"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-service/#registerservice","text":"fun <T : ContractState, P : StatePersistable, F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >, S : ExtendedStateService < T , P , F , Q >> registerService(keyType: KClass< T >, serviceType: KClass< S >): Class<*>? fun registerService(keyType: Class<out ContractState>, serviceType: Class<out ExtendedStateService <*, *, *, *>>): Class<*>?","title":"registerService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/","text":"com.github.manosbatsis.vaultaire.service Package com.github.manosbatsis.vaultaire.service \u00b6 Types \u00b6 Name Summary ServiceDefaults interface ServiceDefaults SimpleServiceDefaults data class SimpleServiceDefaults : ServiceDefaults Define option defaults for StateService instances VaultaireAttachmentService class VaultaireAttachmentService : SingletonSerializeAsToken","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/#package-comgithubmanosbatsisvaultaireservice","text":"","title":"Package com.github.manosbatsis.vaultaire.service"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/#types","text":"Name Summary ServiceDefaults interface ServiceDefaults SimpleServiceDefaults data class SimpleServiceDefaults : ServiceDefaults Define option defaults for StateService instances VaultaireAttachmentService class VaultaireAttachmentService : SingletonSerializeAsToken","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults ServiceDefaults \u00b6 interface ServiceDefaults Properties \u00b6 Name Summary criteria abstract val criteria: QueryCriteria pageNumber abstract val pageNumber: Int pageSize abstract val pageSize: Int paging abstract val paging: PageSpecification sort abstract val sort: Sort Inheritors \u00b6 Name Summary SimpleServiceDefaults data class SimpleServiceDefaults : ServiceDefaults Define option defaults for StateService instances","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/#servicedefaults","text":"interface ServiceDefaults","title":"ServiceDefaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/#properties","text":"Name Summary criteria abstract val criteria: QueryCriteria pageNumber abstract val pageNumber: Int pageSize abstract val pageSize: Int paging abstract val paging: PageSpecification sort abstract val sort: Sort","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/#inheritors","text":"Name Summary SimpleServiceDefaults data class SimpleServiceDefaults : ServiceDefaults Define option defaults for StateService instances","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/criteria/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / criteria criteria \u00b6 abstract val criteria: QueryCriteria","title":"Criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/criteria/#criteria","text":"abstract val criteria: QueryCriteria","title":"criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/page-number/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / pageNumber pageNumber \u00b6 abstract val pageNumber: Int","title":"Page number"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/page-number/#pagenumber","text":"abstract val pageNumber: Int","title":"pageNumber"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/page-size/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / pageSize pageSize \u00b6 abstract val pageSize: Int","title":"Page size"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/page-size/#pagesize","text":"abstract val pageSize: Int","title":"pageSize"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/paging/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / paging paging \u00b6 abstract val paging: PageSpecification","title":"Paging"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/paging/#paging","text":"abstract val paging: PageSpecification","title":"paging"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/sort/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / sort sort \u00b6 abstract val sort: Sort","title":"Sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/sort/#sort","text":"abstract val sort: Sort","title":"sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/","text":"com.github.manosbatsis.vaultaire.service / SimpleServiceDefaults SimpleServiceDefaults \u00b6 data class SimpleServiceDefaults : ServiceDefaults Define option defaults for StateService instances Constructors \u00b6 Name Summary <init> SimpleServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances Properties \u00b6 Name Summary criteria val criteria: QueryCriteria pageNumber val pageNumber: Int pageSize val pageSize: Int paging val paging: PageSpecification sort val sort: Sort","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/#simpleservicedefaults","text":"data class SimpleServiceDefaults : ServiceDefaults Define option defaults for StateService instances","title":"SimpleServiceDefaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/#constructors","text":"Name Summary <init> SimpleServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/#properties","text":"Name Summary criteria val criteria: QueryCriteria pageNumber val pageNumber: Int pageSize val pageSize: Int paging val paging: PageSpecification sort val sort: Sort","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/-init-/","text":"com.github.manosbatsis.vaultaire.service / SimpleServiceDefaults / <init> <init> \u00b6 SimpleServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/-init-/#init","text":"SimpleServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/criteria/","text":"com.github.manosbatsis.vaultaire.service / SimpleServiceDefaults / criteria criteria \u00b6 val criteria: QueryCriteria Overrides ServiceDefaults.criteria","title":"Criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/criteria/#criteria","text":"val criteria: QueryCriteria Overrides ServiceDefaults.criteria","title":"criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/page-number/","text":"com.github.manosbatsis.vaultaire.service / SimpleServiceDefaults / pageNumber pageNumber \u00b6 val pageNumber: Int Overrides ServiceDefaults.pageNumber","title":"Page number"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/page-number/#pagenumber","text":"val pageNumber: Int Overrides ServiceDefaults.pageNumber","title":"pageNumber"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/page-size/","text":"com.github.manosbatsis.vaultaire.service / SimpleServiceDefaults / pageSize pageSize \u00b6 val pageSize: Int Overrides ServiceDefaults.pageSize","title":"Page size"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/page-size/#pagesize","text":"val pageSize: Int Overrides ServiceDefaults.pageSize","title":"pageSize"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/paging/","text":"com.github.manosbatsis.vaultaire.service / SimpleServiceDefaults / paging paging \u00b6 val paging: PageSpecification Overrides ServiceDefaults.paging","title":"Paging"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/paging/#paging","text":"val paging: PageSpecification Overrides ServiceDefaults.paging","title":"paging"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/sort/","text":"com.github.manosbatsis.vaultaire.service / SimpleServiceDefaults / sort sort \u00b6 val sort: Sort Overrides ServiceDefaults.sort","title":"Sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/sort/#sort","text":"val sort: Sort Overrides ServiceDefaults.sort","title":"sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-vaultaire-attachment-service/","text":"com.github.manosbatsis.vaultaire.service / VaultaireAttachmentService VaultaireAttachmentService \u00b6 class VaultaireAttachmentService : SingletonSerializeAsToken Constructors \u00b6 Name Summary <init> VaultaireAttachmentService(serviceHub: AppServiceHub) Properties \u00b6 Name Summary vaultaireSecureHash val vaultaireSecureHash: SecureHash","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-vaultaire-attachment-service/#vaultaireattachmentservice","text":"class VaultaireAttachmentService : SingletonSerializeAsToken","title":"VaultaireAttachmentService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-vaultaire-attachment-service/#constructors","text":"Name Summary <init> VaultaireAttachmentService(serviceHub: AppServiceHub)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-vaultaire-attachment-service/#properties","text":"Name Summary vaultaireSecureHash val vaultaireSecureHash: SecureHash","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-vaultaire-attachment-service/-init-/","text":"com.github.manosbatsis.vaultaire.service / VaultaireAttachmentService / <init> <init> \u00b6 VaultaireAttachmentService(serviceHub: AppServiceHub)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-vaultaire-attachment-service/-init-/#init","text":"VaultaireAttachmentService(serviceHub: AppServiceHub)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-vaultaire-attachment-service/vaultaire-secure-hash/","text":"com.github.manosbatsis.vaultaire.service / VaultaireAttachmentService / vaultaireSecureHash vaultaireSecureHash \u00b6 val vaultaireSecureHash: SecureHash","title":"Vaultaire secure hash"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-vaultaire-attachment-service/vaultaire-secure-hash/#vaultairesecurehash","text":"val vaultaireSecureHash: SecureHash","title":"vaultaireSecureHash"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/","text":"com.github.manosbatsis.vaultaire.service.dao Package com.github.manosbatsis.vaultaire.service.dao \u00b6 Types \u00b6 Name Summary BasicStateService open class BasicStateService<T : ContractState> : BasicNodeService , StateServiceDelegate < T >, StateService < T > Basic StateService implementation, used for vault operations on a specific ContractState type DefaultExtendedStateService abstract class DefaultExtendedStateService<T : ContractState, P : StatePersistable, out F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> : BasicStateService < T >, ExtendedStateService < T , P , F , Q > Extends BasicStateService to provide a StateService aware of the target ContractState type\u2019s StatePersistable and Fields . ExtendedStateService interface ExtendedStateService<T : ContractState, P : StatePersistable, out F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> : StateServiceDelegate < T > StateCordaServiceDelegate abstract class StateCordaServiceDelegate<T : ContractState> : NodeCordaServiceDelegate , StateServiceDelegate < T > Implementation of StateServiceDelegate as a CordaService StateService interface StateService<T : ContractState> : NodeService , StateServiceDelegate < T > Short-lived helper, used for vault operations on a specific ContractState type StateServiceDelegate interface StateServiceDelegate<T : ContractState> : NodeServiceDelegate StateService delegate for vault operations StateServiceHubDelegate open class StateServiceHubDelegate<T : ContractState> : NodeServiceHubDelegate, StateServiceDelegate < T > ServiceHub -based StateServiceDelegate implementation StateServicePoolBoyDelegate open class StateServicePoolBoyDelegate<T : ContractState> : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate < T > StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate<T : ContractState> : NodeServiceRpcConnectionDelegate, StateServiceDelegate < T > NodeRpcConnection -based StateServiceDelegate implementation","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/#package-comgithubmanosbatsisvaultaireservicedao","text":"","title":"Package com.github.manosbatsis.vaultaire.service.dao"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/#types","text":"Name Summary BasicStateService open class BasicStateService<T : ContractState> : BasicNodeService , StateServiceDelegate < T >, StateService < T > Basic StateService implementation, used for vault operations on a specific ContractState type DefaultExtendedStateService abstract class DefaultExtendedStateService<T : ContractState, P : StatePersistable, out F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> : BasicStateService < T >, ExtendedStateService < T , P , F , Q > Extends BasicStateService to provide a StateService aware of the target ContractState type\u2019s StatePersistable and Fields . ExtendedStateService interface ExtendedStateService<T : ContractState, P : StatePersistable, out F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> : StateServiceDelegate < T > StateCordaServiceDelegate abstract class StateCordaServiceDelegate<T : ContractState> : NodeCordaServiceDelegate , StateServiceDelegate < T > Implementation of StateServiceDelegate as a CordaService StateService interface StateService<T : ContractState> : NodeService , StateServiceDelegate < T > Short-lived helper, used for vault operations on a specific ContractState type StateServiceDelegate interface StateServiceDelegate<T : ContractState> : NodeServiceDelegate StateService delegate for vault operations StateServiceHubDelegate open class StateServiceHubDelegate<T : ContractState> : NodeServiceHubDelegate, StateServiceDelegate < T > ServiceHub -based StateServiceDelegate implementation StateServicePoolBoyDelegate open class StateServicePoolBoyDelegate<T : ContractState> : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate < T > StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate<T : ContractState> : NodeServiceRpcConnectionDelegate, StateServiceDelegate < T > NodeRpcConnection -based StateServiceDelegate implementation","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/","text":"com.github.manosbatsis.vaultaire.service.dao / BasicStateService BasicStateService \u00b6 open class BasicStateService<T : ContractState> : BasicNodeService , StateServiceDelegate < T >, StateService < T > Basic StateService implementation, used for vault operations on a specific ContractState type Parameters \u00b6 T - the ContractState type Constructors \u00b6 Name Summary <init> BasicStateService(poolBoy: PoolBoyConnection, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate < T >) Basic StateService implementation, used for vault operations on a specific ContractState type Properties \u00b6 Name Summary delegate open val delegate: StateServiceDelegate < T > ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean Inherited Functions \u00b6 Name Summary countBy open fun <T : ContractState> countBy(contractStateType: Class< T >, criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria countBy open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun <T : ContractState> findByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByExternalId open fun findByExternalId(externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef< T > Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inheritors \u00b6 Name Summary DefaultExtendedStateService abstract class DefaultExtendedStateService<T : ContractState, P : StatePersistable, out F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> : BasicStateService < T >, ExtendedStateService < T , P , F , Q > Extends BasicStateService to provide a StateService aware of the target ContractState type\u2019s StatePersistable and Fields .","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#basicstateservice","text":"open class BasicStateService<T : ContractState> : BasicNodeService , StateServiceDelegate < T >, StateService < T > Basic StateService implementation, used for vault operations on a specific ContractState type","title":"BasicStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#constructors","text":"Name Summary <init> BasicStateService(poolBoy: PoolBoyConnection, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate < T >) Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#properties","text":"Name Summary delegate open val delegate: StateServiceDelegate < T > ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#inherited-functions","text":"Name Summary countBy open fun <T : ContractState> countBy(contractStateType: Class< T >, criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria countBy open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun <T : ContractState> findByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByExternalId open fun findByExternalId(externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef< T > Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#inheritors","text":"Name Summary DefaultExtendedStateService abstract class DefaultExtendedStateService<T : ContractState, P : StatePersistable, out F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> : BasicStateService < T >, ExtendedStateService < T , P , F , Q > Extends BasicStateService to provide a StateService aware of the target ContractState type\u2019s StatePersistable and Fields .","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / BasicStateService / <init> <init> \u00b6 BasicStateService(poolBoy: PoolBoyConnection, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate < T >) Basic StateService implementation, used for vault operations on a specific ContractState type Parameters \u00b6 T - the ContractState type","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/-init-/#init","text":"BasicStateService(poolBoy: PoolBoyConnection, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate < T >) Basic StateService implementation, used for vault operations on a specific ContractState type","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/-init-/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / BasicStateService / delegate delegate \u00b6 open val delegate: StateServiceDelegate < T > Overrides BasicNodeService.delegate","title":"Delegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/delegate/#delegate","text":"open val delegate: StateServiceDelegate < T > Overrides BasicNodeService.delegate","title":"delegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/of-linear-state/","text":"com.github.manosbatsis.vaultaire.service.dao / BasicStateService / ofLinearState ofLinearState \u00b6 open val ofLinearState: Boolean Overrides StateService.ofLinearState","title":"Of linear state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/of-linear-state/#oflinearstate","text":"open val ofLinearState: Boolean Overrides StateService.ofLinearState","title":"ofLinearState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/of-queryable-state/","text":"com.github.manosbatsis.vaultaire.service.dao / BasicStateService / ofQueryableState ofQueryableState \u00b6 open val ofQueryableState: Boolean Overrides StateService.ofQueryableState","title":"Of queryable state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/of-queryable-state/#ofqueryablestate","text":"open val ofQueryableState: Boolean Overrides StateService.ofQueryableState","title":"ofQueryableState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/","text":"com.github.manosbatsis.vaultaire.service.dao / DefaultExtendedStateService DefaultExtendedStateService \u00b6 abstract class DefaultExtendedStateService<T : ContractState, P : StatePersistable, out F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> : BasicStateService < T >, ExtendedStateService < T , P , F , Q > Extends BasicStateService to provide a StateService aware of the target ContractState type\u2019s StatePersistable and Fields . Subclassed by Vaultaire\u2019s annotation processing to generate service components. Constructors \u00b6 Name Summary <init> DefaultExtendedStateService(delegate: StateServiceDelegate < T >) Extends BasicStateService to provide a StateService aware of the target ContractState type\u2019s StatePersistable and Fields . Properties \u00b6 Name Summary criteriaConditionsType open lateinit var criteriaConditionsType: Class< Q > The fields of the target StatePersistable type P Inherited Properties \u00b6 Name Summary delegate open val delegate: StateServiceDelegate < T > fields abstract val fields: F The fields of the target StatePersistable type P ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean statePersistableType abstract val statePersistableType: Class< P > The type of the target state\u2019s StatePersistable Inherited Functions \u00b6 Name Summary buildQuery abstract fun buildQuery(block: Q .() -> Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q queryBy open fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page< T > Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair<String, Direction>): Page< T > open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair<String, Direction>): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any toSort open fun toSort(vararg sort: Pair<String, Direction>): Sort Build a sort from the given string/direction pairs trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair<String, Direction>): DataFeed<Page< T >, Update< T >> open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair<String, Direction>): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any open fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed<Page< T >, Update< T >> Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates.","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/#defaultextendedstateservice","text":"abstract class DefaultExtendedStateService<T : ContractState, P : StatePersistable, out F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> : BasicStateService < T >, ExtendedStateService < T , P , F , Q > Extends BasicStateService to provide a StateService aware of the target ContractState type\u2019s StatePersistable and Fields . Subclassed by Vaultaire\u2019s annotation processing to generate service components.","title":"DefaultExtendedStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/#constructors","text":"Name Summary <init> DefaultExtendedStateService(delegate: StateServiceDelegate < T >) Extends BasicStateService to provide a StateService aware of the target ContractState type\u2019s StatePersistable and Fields .","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/#properties","text":"Name Summary criteriaConditionsType open lateinit var criteriaConditionsType: Class< Q > The fields of the target StatePersistable type P","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/#inherited-properties","text":"Name Summary delegate open val delegate: StateServiceDelegate < T > fields abstract val fields: F The fields of the target StatePersistable type P ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean statePersistableType abstract val statePersistableType: Class< P > The type of the target state\u2019s StatePersistable","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/#inherited-functions","text":"Name Summary buildQuery abstract fun buildQuery(block: Q .() -> Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q queryBy open fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page< T > Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair<String, Direction>): Page< T > open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair<String, Direction>): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any toSort open fun toSort(vararg sort: Pair<String, Direction>): Sort Build a sort from the given string/direction pairs trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair<String, Direction>): DataFeed<Page< T >, Update< T >> open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair<String, Direction>): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any open fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed<Page< T >, Update< T >> Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates.","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / DefaultExtendedStateService / <init> <init> \u00b6 DefaultExtendedStateService(delegate: StateServiceDelegate < T >) Extends BasicStateService to provide a StateService aware of the target ContractState type\u2019s StatePersistable and Fields . Subclassed by Vaultaire\u2019s annotation processing to generate service components.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/-init-/#init","text":"DefaultExtendedStateService(delegate: StateServiceDelegate < T >) Extends BasicStateService to provide a StateService aware of the target ContractState type\u2019s StatePersistable and Fields . Subclassed by Vaultaire\u2019s annotation processing to generate service components.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/criteria-conditions-type/","text":"com.github.manosbatsis.vaultaire.service.dao / DefaultExtendedStateService / criteriaConditionsType criteriaConditionsType \u00b6 open lateinit var criteriaConditionsType: Class< Q > Overrides ExtendedStateService.criteriaConditionsType The fields of the target StatePersistable type P","title":"Criteria conditions type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/criteria-conditions-type/#criteriaconditionstype","text":"open lateinit var criteriaConditionsType: Class< Q > Overrides ExtendedStateService.criteriaConditionsType The fields of the target StatePersistable type P","title":"criteriaConditionsType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService ExtendedStateService \u00b6 interface ExtendedStateService<T : ContractState, P : StatePersistable, out F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> : StateServiceDelegate < T > Properties \u00b6 Name Summary criteriaConditionsType abstract var criteriaConditionsType: Class< Q > The fields of the target StatePersistable type P fields abstract val fields: F The fields of the target StatePersistable type P statePersistableType abstract val statePersistableType: Class< P > The type of the target state\u2019s StatePersistable Inherited Properties \u00b6 Name Summary contractStateType abstract val contractStateType: Class< T > Functions \u00b6 Name Summary buildQuery abstract fun buildQuery(block: Q .() -> Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q queryBy open fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page< T > Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair<String, Direction>): Page< T > open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair<String, Direction>): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any toSort open fun toSort(vararg sort: Pair<String, Direction>): Sort Build a sort from the given string/direction pairs trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair<String, Direction>): DataFeed<Page< T >, Update< T >> open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair<String, Direction>): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any open fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed<Page< T >, Update< T >> Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates. Inherited Functions \u00b6 Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any Inheritors \u00b6 Name Summary DefaultExtendedStateService abstract class DefaultExtendedStateService<T : ContractState, P : StatePersistable, out F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> : BasicStateService < T >, ExtendedStateService < T , P , F , Q > Extends BasicStateService to provide a StateService aware of the target ContractState type\u2019s StatePersistable and Fields .","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#extendedstateservice","text":"interface ExtendedStateService<T : ContractState, P : StatePersistable, out F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> : StateServiceDelegate < T >","title":"ExtendedStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#properties","text":"Name Summary criteriaConditionsType abstract var criteriaConditionsType: Class< Q > The fields of the target StatePersistable type P fields abstract val fields: F The fields of the target StatePersistable type P statePersistableType abstract val statePersistableType: Class< P > The type of the target state\u2019s StatePersistable","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#inherited-properties","text":"Name Summary contractStateType abstract val contractStateType: Class< T >","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#functions","text":"Name Summary buildQuery abstract fun buildQuery(block: Q .() -> Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q queryBy open fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page< T > Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair<String, Direction>): Page< T > open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair<String, Direction>): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any toSort open fun toSort(vararg sort: Pair<String, Direction>): Sort Build a sort from the given string/direction pairs trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair<String, Direction>): DataFeed<Page< T >, Update< T >> open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair<String, Direction>): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any open fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed<Page< T >, Update< T >> Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates.","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#inherited-functions","text":"Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#inheritors","text":"Name Summary DefaultExtendedStateService abstract class DefaultExtendedStateService<T : ContractState, P : StatePersistable, out F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> : BasicStateService < T >, ExtendedStateService < T , P , F , Q > Extends BasicStateService to provide a StateService aware of the target ContractState type\u2019s StatePersistable and Fields .","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/build-query/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / buildQuery buildQuery \u00b6 abstract fun buildQuery(block: Q .() -> Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q","title":"Build query"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/build-query/#buildquery","text":"abstract fun buildQuery(block: Q .() -> Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q","title":"buildQuery"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/criteria-conditions-type/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / criteriaConditionsType criteriaConditionsType \u00b6 abstract var criteriaConditionsType: Class< Q > The fields of the target StatePersistable type P","title":"Criteria conditions type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/criteria-conditions-type/#criteriaconditionstype","text":"abstract var criteriaConditionsType: Class< Q > The fields of the target StatePersistable type P","title":"criteriaConditionsType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/fields/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / fields fields \u00b6 abstract val fields: F The fields of the target StatePersistable type P","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/fields/#fields","text":"abstract val fields: F The fields of the target StatePersistable type P","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/query-by/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / queryBy queryBy \u00b6 @Suspendable open fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page< T > Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag @Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair<String, Direction>): Page< T > @Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair<String, Direction>): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/query-by/#queryby","text":"@Suspendable open fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page< T > Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag @Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair<String, Direction>): Page< T > @Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair<String, Direction>): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/state-persistable-type/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / statePersistableType statePersistableType \u00b6 abstract val statePersistableType: Class< P > The type of the target state\u2019s StatePersistable","title":"State persistable type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/state-persistable-type/#statepersistabletype","text":"abstract val statePersistableType: Class< P > The type of the target state\u2019s StatePersistable","title":"statePersistableType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/to-sort/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / toSort toSort \u00b6 open fun toSort(vararg sort: Pair<String, Direction>): Sort Build a sort from the given string/direction pairs","title":"To sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/to-sort/#tosort","text":"open fun toSort(vararg sort: Pair<String, Direction>): Sort Build a sort from the given string/direction pairs","title":"toSort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/track-by/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / trackBy trackBy \u00b6 @Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair<String, Direction>): DataFeed<Page< T >, Update< T >> @Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair<String, Direction>): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any @Suspendable open fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed<Page< T >, Update< T >> Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates.","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/track-by/#trackby","text":"@Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair<String, Direction>): DataFeed<Page< T >, Update< T >> @Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair<String, Direction>): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any @Suspendable open fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed<Page< T >, Update< T >> Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates.","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / StateCordaServiceDelegate StateCordaServiceDelegate \u00b6 abstract class StateCordaServiceDelegate<T : ContractState> : NodeCordaServiceDelegate , StateServiceDelegate < T > Implementation of StateServiceDelegate as a CordaService Constructors \u00b6 Name Summary <init> StateCordaServiceDelegate(serviceHub: AppServiceHub, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) Implementation of StateServiceDelegate as a CordaService Properties \u00b6 Name Summary contractStateType open val contractStateType: Class< T > Inherited Properties \u00b6 Name Summary defaults open val defaults: ServiceDefaults Inherited Functions \u00b6 Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/#statecordaservicedelegate","text":"abstract class StateCordaServiceDelegate<T : ContractState> : NodeCordaServiceDelegate , StateServiceDelegate < T > Implementation of StateServiceDelegate as a CordaService","title":"StateCordaServiceDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/#constructors","text":"Name Summary <init> StateCordaServiceDelegate(serviceHub: AppServiceHub, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) Implementation of StateServiceDelegate as a CordaService","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/#properties","text":"Name Summary contractStateType open val contractStateType: Class< T >","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/#inherited-properties","text":"Name Summary defaults open val defaults: ServiceDefaults","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/#inherited-functions","text":"Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / StateCordaServiceDelegate / <init> <init> \u00b6 StateCordaServiceDelegate(serviceHub: AppServiceHub, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) Implementation of StateServiceDelegate as a CordaService","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/-init-/#init","text":"StateCordaServiceDelegate(serviceHub: AppServiceHub, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) Implementation of StateServiceDelegate as a CordaService","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.service.dao / StateCordaServiceDelegate / contractStateType contractStateType \u00b6 open val contractStateType: Class< T > Overrides StateServiceDelegate.contractStateType","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/contract-state-type/#contractstatetype","text":"open val contractStateType: Class< T > Overrides StateServiceDelegate.contractStateType","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService StateService \u00b6 interface StateService<T : ContractState> : NodeService , StateServiceDelegate < T > Short-lived helper, used for vault operations on a specific ContractState type Parameters \u00b6 T - the ContractState type Properties \u00b6 Name Summary ofLinearState abstract val ofLinearState: Boolean ofQueryableState abstract val ofQueryableState: Boolean Inherited Properties \u00b6 Name Summary contractStateType abstract val contractStateType: Class< T > Functions \u00b6 Name Summary countBy open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun findByExternalId(externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef< T > Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inherited Functions \u00b6 Name Summary countBy abstract fun <T : ContractState> countBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId abstract fun <T : ContractState> findByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UUID if any open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? abstract fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun <T : ContractState> getByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T > Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List<UUID> = emptyList()): StateAndRef< T > Find the state of type T matching the given UUID if any, throw an error otherwise open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy abstract fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy abstract fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any Inheritors \u00b6 Name Summary BasicStateService open class BasicStateService<T : ContractState> : BasicNodeService , StateServiceDelegate < T >, StateService < T > Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#stateservice","text":"interface StateService<T : ContractState> : NodeService , StateServiceDelegate < T > Short-lived helper, used for vault operations on a specific ContractState type","title":"StateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#properties","text":"Name Summary ofLinearState abstract val ofLinearState: Boolean ofQueryableState abstract val ofQueryableState: Boolean","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#inherited-properties","text":"Name Summary contractStateType abstract val contractStateType: Class< T >","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#functions","text":"Name Summary countBy open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun findByExternalId(externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef< T > Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#inherited-functions","text":"Name Summary countBy abstract fun <T : ContractState> countBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId abstract fun <T : ContractState> findByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UUID if any open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? abstract fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun <T : ContractState> getByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T > Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List<UUID> = emptyList()): StateAndRef< T > Find the state of type T matching the given UUID if any, throw an error otherwise open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy abstract fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy abstract fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#inheritors","text":"Name Summary BasicStateService open class BasicStateService<T : ContractState> : BasicNodeService , StateServiceDelegate < T >, StateService < T > Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/count-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / countBy countBy \u00b6 @Suspendable open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria","title":"Count by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/count-by/#countby","text":"@Suspendable open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria","title":"countBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/find-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / findByExternalId findByExternalId \u00b6 @Suspendable open fun findByExternalId(externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"Find by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/find-by-external-id/#findbyexternalid","text":"@Suspendable open fun findByExternalId(externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"findByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/find-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / findByLinearId findByLinearId \u00b6 @Suspendable open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UUID if any @Suspendable open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? @Suspendable open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any","title":"Find by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/find-by-linear-id/#findbylinearid","text":"@Suspendable open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UUID if any @Suspendable open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? @Suspendable open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any","title":"findByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / getByExternalId getByExternalId \u00b6 @Suspendable open fun getByExternalId(externalId: String): StateAndRef< T > Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise Exceptions \u00b6 NotFoundException - if no match is found","title":"Get by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-external-id/#getbyexternalid","text":"@Suspendable open fun getByExternalId(externalId: String): StateAndRef< T > Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise","title":"getByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-external-id/#exceptions","text":"NotFoundException - if no match is found","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / getByLinearId getByLinearId \u00b6 @Suspendable open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UUID if any, throw an error otherwise Exceptions \u00b6 NotFoundException - if no match is found @Suspendable open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > @Suspendable open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise Exceptions \u00b6 NotFoundException - if no match is found","title":"Get by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-linear-id/#getbylinearid","text":"@Suspendable open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UUID if any, throw an error otherwise","title":"getByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-linear-id/#exceptions","text":"NotFoundException - if no match is found @Suspendable open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > @Suspendable open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-linear-id/#exceptions_1","text":"NotFoundException - if no match is found","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/of-linear-state/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / ofLinearState ofLinearState \u00b6 abstract val ofLinearState: Boolean","title":"Of linear state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/of-linear-state/#oflinearstate","text":"abstract val ofLinearState: Boolean","title":"ofLinearState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/of-queryable-state/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / ofQueryableState ofQueryableState \u00b6 abstract val ofQueryableState: Boolean","title":"Of queryable state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/of-queryable-state/#ofqueryablestate","text":"abstract val ofQueryableState: Boolean","title":"ofQueryableState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/query-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / queryBy queryBy \u00b6 @Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/query-by/#queryby","text":"@Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/track-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / trackBy trackBy \u00b6 @Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/track-by/#trackby","text":"@Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceDelegate StateServiceDelegate \u00b6 interface StateServiceDelegate<T : ContractState> : NodeServiceDelegate StateService delegate for vault operations Properties \u00b6 Name Summary contractStateType abstract val contractStateType: Class< T > Inherited Properties \u00b6 Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name Functions \u00b6 Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any Inherited Functions \u00b6 Name Summary addresses abstract fun addresses(): List<NetworkHostAndPort> createStateService abstract fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. flows abstract fun flows(): List<String> getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getNodeInfo abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. identities abstract fun identities(): List<Party> isLinearState open fun <T : ContractState> isLinearState(contractStateType: Class< T >): Boolean isQueryableState open fun <T : ContractState> isQueryableState(contractStateType: Class< T >): Boolean nodes abstract fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries. notaries abstract fun notaries(): List<Party> openAttachment abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers abstract fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries. platformVersion abstract fun platformVersion(): Int queryBy abstract fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault serverTime abstract fun serverTime(): LocalDateTime toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash. wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inheritors \u00b6 Name Summary BasicStateService open class BasicStateService<T : ContractState> : BasicNodeService , StateServiceDelegate < T >, StateService < T > Basic StateService implementation, used for vault operations on a specific ContractState type ExtendedStateService interface ExtendedStateService<T : ContractState, P : StatePersistable, out F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> : StateServiceDelegate < T > StateCordaServiceDelegate abstract class StateCordaServiceDelegate<T : ContractState> : NodeCordaServiceDelegate , StateServiceDelegate < T > Implementation of StateServiceDelegate as a CordaService StateService interface StateService<T : ContractState> : NodeService , StateServiceDelegate < T > Short-lived helper, used for vault operations on a specific ContractState type StateServiceHubDelegate open class StateServiceHubDelegate<T : ContractState> : NodeServiceHubDelegate, StateServiceDelegate < T > ServiceHub -based StateServiceDelegate implementation StateServicePoolBoyDelegate open class StateServicePoolBoyDelegate<T : ContractState> : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate < T > StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate<T : ContractState> : NodeServiceRpcConnectionDelegate, StateServiceDelegate < T > NodeRpcConnection -based StateServiceDelegate implementation","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#stateservicedelegate","text":"interface StateServiceDelegate<T : ContractState> : NodeServiceDelegate StateService delegate for vault operations","title":"StateServiceDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#properties","text":"Name Summary contractStateType abstract val contractStateType: Class< T >","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#inherited-properties","text":"Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#functions","text":"Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#inherited-functions","text":"Name Summary addresses abstract fun addresses(): List<NetworkHostAndPort> createStateService abstract fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. flows abstract fun flows(): List<String> getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getNodeInfo abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. identities abstract fun identities(): List<Party> isLinearState open fun <T : ContractState> isLinearState(contractStateType: Class< T >): Boolean isQueryableState open fun <T : ContractState> isQueryableState(contractStateType: Class< T >): Boolean nodes abstract fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries. notaries abstract fun notaries(): List<Party> openAttachment abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers abstract fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries. platformVersion abstract fun platformVersion(): Int queryBy abstract fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault serverTime abstract fun serverTime(): LocalDateTime toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash. wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#inheritors","text":"Name Summary BasicStateService open class BasicStateService<T : ContractState> : BasicNodeService , StateServiceDelegate < T >, StateService < T > Basic StateService implementation, used for vault operations on a specific ContractState type ExtendedStateService interface ExtendedStateService<T : ContractState, P : StatePersistable, out F : Fields < P >, Q : VaultQueryCriteriaCondition < P , F >> : StateServiceDelegate < T > StateCordaServiceDelegate abstract class StateCordaServiceDelegate<T : ContractState> : NodeCordaServiceDelegate , StateServiceDelegate < T > Implementation of StateServiceDelegate as a CordaService StateService interface StateService<T : ContractState> : NodeService , StateServiceDelegate < T > Short-lived helper, used for vault operations on a specific ContractState type StateServiceHubDelegate open class StateServiceHubDelegate<T : ContractState> : NodeServiceHubDelegate, StateServiceDelegate < T > ServiceHub -based StateServiceDelegate implementation StateServicePoolBoyDelegate open class StateServicePoolBoyDelegate<T : ContractState> : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate < T > StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate<T : ContractState> : NodeServiceRpcConnectionDelegate, StateServiceDelegate < T > NodeRpcConnection -based StateServiceDelegate implementation","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceDelegate / contractStateType contractStateType \u00b6 abstract val contractStateType: Class< T >","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/contract-state-type/#contractstatetype","text":"abstract val contractStateType: Class< T >","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/query-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceDelegate / queryBy queryBy \u00b6 @Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/query-by/#queryby","text":"@Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/track-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceDelegate / trackBy trackBy \u00b6 @Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/track-by/#trackby","text":"@Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceHubDelegate StateServiceHubDelegate \u00b6 open class StateServiceHubDelegate<T : ContractState> : NodeServiceHubDelegate, StateServiceDelegate < T > ServiceHub -based StateServiceDelegate implementation Constructors \u00b6 Name Summary <init> StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based StateServiceDelegate implementation Properties \u00b6 Name Summary contractStateType open val contractStateType: Class< T > Inherited Functions \u00b6 Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/#stateservicehubdelegate","text":"open class StateServiceHubDelegate<T : ContractState> : NodeServiceHubDelegate, StateServiceDelegate < T > ServiceHub -based StateServiceDelegate implementation","title":"StateServiceHubDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/#constructors","text":"Name Summary <init> StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based StateServiceDelegate implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/#properties","text":"Name Summary contractStateType open val contractStateType: Class< T >","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/#inherited-functions","text":"Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceHubDelegate / <init> <init> \u00b6 StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based StateServiceDelegate implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/-init-/#init","text":"StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based StateServiceDelegate implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceHubDelegate / contractStateType contractStateType \u00b6 open val contractStateType: Class< T > Overrides StateServiceDelegate.contractStateType","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/contract-state-type/#contractstatetype","text":"open val contractStateType: Class< T > Overrides StateServiceDelegate.contractStateType","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServicePoolBoyDelegate StateServicePoolBoyDelegate \u00b6 open class StateServicePoolBoyDelegate<T : ContractState> : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate < T > Constructors \u00b6 Name Summary <init> StateServicePoolBoyDelegate(poolBoy: PoolBoyConnection, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) Properties \u00b6 Name Summary contractStateType open val contractStateType: Class< T > Inherited Properties \u00b6 Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name poolBoy val poolBoy: PoolBoyConnection Inherited Functions \u00b6 Name Summary addresses open fun addresses(): List<NetworkHostAndPort> createStateService open fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flows open fun flows(): List<String> getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List<Party> nodes open fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List<Party> openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/#stateservicepoolboydelegate","text":"open class StateServicePoolBoyDelegate<T : ContractState> : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate < T >","title":"StateServicePoolBoyDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/#constructors","text":"Name Summary <init> StateServicePoolBoyDelegate(poolBoy: PoolBoyConnection, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults())","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/#properties","text":"Name Summary contractStateType open val contractStateType: Class< T >","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/#inherited-properties","text":"Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name poolBoy val poolBoy: PoolBoyConnection","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/#inherited-functions","text":"Name Summary addresses open fun addresses(): List<NetworkHostAndPort> createStateService open fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flows open fun flows(): List<String> getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List<Party> nodes open fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List<Party> openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServicePoolBoyDelegate / <init> <init> \u00b6 StateServicePoolBoyDelegate(poolBoy: PoolBoyConnection, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults())","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/-init-/#init","text":"StateServicePoolBoyDelegate(poolBoy: PoolBoyConnection, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults())","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServicePoolBoyDelegate / contractStateType contractStateType \u00b6 open val contractStateType: Class< T > Overrides StateServiceDelegate.contractStateType","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/contract-state-type/#contractstatetype","text":"open val contractStateType: Class< T > Overrides StateServiceDelegate.contractStateType","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceRpcConnectionDelegate StateServiceRpcConnectionDelegate \u00b6 open class StateServiceRpcConnectionDelegate<T : ContractState> : NodeServiceRpcConnectionDelegate, StateServiceDelegate < T > NodeRpcConnection -based StateServiceDelegate implementation Constructors \u00b6 Name Summary <init> StateServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) NodeRpcConnection -based StateServiceDelegate implementation Properties \u00b6 Name Summary contractStateType open val contractStateType: Class< T > Inherited Functions \u00b6 Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/#stateservicerpcconnectiondelegate","text":"open class StateServiceRpcConnectionDelegate<T : ContractState> : NodeServiceRpcConnectionDelegate, StateServiceDelegate < T > NodeRpcConnection -based StateServiceDelegate implementation","title":"StateServiceRpcConnectionDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/#constructors","text":"Name Summary <init> StateServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) NodeRpcConnection -based StateServiceDelegate implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/#properties","text":"Name Summary contractStateType open val contractStateType: Class< T >","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/#inherited-functions","text":"Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceRpcConnectionDelegate / <init> <init> \u00b6 StateServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) NodeRpcConnection -based StateServiceDelegate implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/-init-/#init","text":"StateServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection, contractStateType: Class< T >, defaults: ServiceDefaults = SimpleServiceDefaults()) NodeRpcConnection -based StateServiceDelegate implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceRpcConnectionDelegate / contractStateType contractStateType \u00b6 open val contractStateType: Class< T > Overrides StateServiceDelegate.contractStateType","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/contract-state-type/#contractstatetype","text":"open val contractStateType: Class< T > Overrides StateServiceDelegate.contractStateType","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/","text":"com.github.manosbatsis.vaultaire.service.node Package com.github.manosbatsis.vaultaire.service.node \u00b6 Types \u00b6 Name Summary AbstractNodeServiceHubDelegate abstract class AbstractNodeServiceHubDelegate<S : ServiceHub> : SingletonSerializeAsToken, NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation NodeCordaServiceDelegate abstract class NodeCordaServiceDelegate : AbstractNodeServiceHubDelegate <AppServiceHub> Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService NodeService interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type NodeServiceDelegate interface NodeServiceDelegate NodeService delegate for vault operations NodeServiceRpcPoolBoyDelegate open class NodeServiceRpcPoolBoyDelegate : NodeServiceDelegate RPC implementation base Exceptions \u00b6 Name Summary NotFoundException class NotFoundException : RuntimeException","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/#package-comgithubmanosbatsisvaultaireservicenode","text":"","title":"Package com.github.manosbatsis.vaultaire.service.node"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/#types","text":"Name Summary AbstractNodeServiceHubDelegate abstract class AbstractNodeServiceHubDelegate<S : ServiceHub> : SingletonSerializeAsToken, NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation NodeCordaServiceDelegate abstract class NodeCordaServiceDelegate : AbstractNodeServiceHubDelegate <AppServiceHub> Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService NodeService interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type NodeServiceDelegate interface NodeServiceDelegate NodeService delegate for vault operations NodeServiceRpcPoolBoyDelegate open class NodeServiceRpcPoolBoyDelegate : NodeServiceDelegate RPC implementation base","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/#exceptions","text":"Name Summary NotFoundException class NotFoundException : RuntimeException","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate AbstractNodeServiceHubDelegate \u00b6 abstract class AbstractNodeServiceHubDelegate<S : ServiceHub> : SingletonSerializeAsToken, NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation Constructors \u00b6 Name Summary <init> AbstractNodeServiceHubDelegate(serviceHub: S ) ServiceHub -based NodeServiceDelegate implementation Properties \u00b6 Name Summary nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name serviceHub val serviceHub: S Inherited Properties \u00b6 Name Summary defaults abstract val defaults: ServiceDefaults Functions \u00b6 Name Summary addresses open fun addresses(): List<NetworkHostAndPort> createStateService open fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flowAwareStartFlow fun <T> flowAwareStartFlow(flowLogic: FlowLogic< T >): CordaFuture< T > Will start the given flow as a subflow of the current top-level FlowLogic if any, or using the AppServiceHub otherwise. flows open fun flows(): List<String> getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List<Party> nodes open fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List<Party> openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inherited Functions \u00b6 Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun <T : ContractState> isLinearState(contractStateType: Class< T >): Boolean isQueryableState open fun <T : ContractState> isQueryableState(contractStateType: Class< T >): Boolean openAttachment open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name Inheritors \u00b6 Name Summary NodeCordaServiceDelegate abstract class NodeCordaServiceDelegate : AbstractNodeServiceHubDelegate <AppServiceHub> Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/#abstractnodeservicehubdelegate","text":"abstract class AbstractNodeServiceHubDelegate<S : ServiceHub> : SingletonSerializeAsToken, NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation","title":"AbstractNodeServiceHubDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/#constructors","text":"Name Summary <init> AbstractNodeServiceHubDelegate(serviceHub: S ) ServiceHub -based NodeServiceDelegate implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/#properties","text":"Name Summary nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name serviceHub val serviceHub: S","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/#inherited-properties","text":"Name Summary defaults abstract val defaults: ServiceDefaults","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/#functions","text":"Name Summary addresses open fun addresses(): List<NetworkHostAndPort> createStateService open fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flowAwareStartFlow fun <T> flowAwareStartFlow(flowLogic: FlowLogic< T >): CordaFuture< T > Will start the given flow as a subflow of the current top-level FlowLogic if any, or using the AppServiceHub otherwise. flows open fun flows(): List<String> getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List<Party> nodes open fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List<Party> openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/#inherited-functions","text":"Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun <T : ContractState> isLinearState(contractStateType: Class< T >): Boolean isQueryableState open fun <T : ContractState> isQueryableState(contractStateType: Class< T >): Boolean openAttachment open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/#inheritors","text":"Name Summary NodeCordaServiceDelegate abstract class NodeCordaServiceDelegate : AbstractNodeServiceHubDelegate <AppServiceHub> Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / <init> <init> \u00b6 AbstractNodeServiceHubDelegate(serviceHub: S ) ServiceHub -based NodeServiceDelegate implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/-init-/#init","text":"AbstractNodeServiceHubDelegate(serviceHub: S ) ServiceHub -based NodeServiceDelegate implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/addresses/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / addresses addresses \u00b6 open fun addresses(): List<NetworkHostAndPort> Overrides NodeServiceDelegate.addresses","title":"Addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/addresses/#addresses","text":"open fun addresses(): List<NetworkHostAndPort> Overrides NodeServiceDelegate.addresses","title":"addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/create-state-service/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / createStateService createStateService \u00b6 open fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Overrides NodeServiceDelegate.createStateService Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized.","title":"Create state service"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/create-state-service/#createstateservice","text":"open fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Overrides NodeServiceDelegate.createStateService Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized.","title":"createStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/flow-aware-start-flow/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / flowAwareStartFlow flowAwareStartFlow \u00b6 @Suspendable fun <T> flowAwareStartFlow(flowLogic: FlowLogic< T >): CordaFuture< T > Will start the given flow as a subflow of the current top-level FlowLogic if any, or using the AppServiceHub otherwise.","title":"Flow aware start flow"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/flow-aware-start-flow/#flowawarestartflow","text":"@Suspendable fun <T> flowAwareStartFlow(flowLogic: FlowLogic< T >): CordaFuture< T > Will start the given flow as a subflow of the current top-level FlowLogic if any, or using the AppServiceHub otherwise.","title":"flowAwareStartFlow"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/flows/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / flows flows \u00b6 open fun flows(): List<String> Overrides NodeServiceDelegate.flows","title":"Flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/flows/#flows","text":"open fun flows(): List<String> Overrides NodeServiceDelegate.flows","title":"flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/get-node-info/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / getNodeInfo getNodeInfo \u00b6 open fun getNodeInfo(): NodeInfo Overrides NodeServiceDelegate.getNodeInfo Get information about the node in context as an NodeInfo","title":"Get node info"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/get-node-info/#getnodeinfo","text":"open fun getNodeInfo(): NodeInfo Overrides NodeServiceDelegate.getNodeInfo Get information about the node in context as an NodeInfo","title":"getNodeInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/identities/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / identities identities \u00b6 open fun identities(): List<Party> Overrides NodeServiceDelegate.identities","title":"Identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/identities/#identities","text":"open fun identities(): List<Party> Overrides NodeServiceDelegate.identities","title":"identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/node-identity-criteria/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / nodeIdentityCriteria nodeIdentityCriteria \u00b6 open val nodeIdentityCriteria: LinearStateQueryCriteria Overrides NodeServiceDelegate.nodeIdentityCriteria","title":"Node identity criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/node-identity-criteria/#nodeidentitycriteria","text":"open val nodeIdentityCriteria: LinearStateQueryCriteria Overrides NodeServiceDelegate.nodeIdentityCriteria","title":"nodeIdentityCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/node-identity/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / nodeIdentity nodeIdentity \u00b6 open val nodeIdentity: Party Overrides NodeServiceDelegate.nodeIdentity","title":"Node identity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/node-identity/#nodeidentity","text":"open val nodeIdentity: Party Overrides NodeServiceDelegate.nodeIdentity","title":"nodeIdentity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/node-legal-name/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / nodeLegalName nodeLegalName \u00b6 open val nodeLegalName: CordaX500Name Overrides NodeServiceDelegate.nodeLegalName","title":"Node legal name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/node-legal-name/#nodelegalname","text":"open val nodeLegalName: CordaX500Name Overrides NodeServiceDelegate.nodeLegalName","title":"nodeLegalName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/nodes/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / nodes nodes \u00b6 open fun nodes(): List<Party> Overrides NodeServiceDelegate.nodes Get a list of nodes in the network, including self and notaries.","title":"Nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/nodes/#nodes","text":"open fun nodes(): List<Party> Overrides NodeServiceDelegate.nodes Get a list of nodes in the network, including self and notaries.","title":"nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/notaries/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / notaries notaries \u00b6 open fun notaries(): List<Party> Overrides NodeServiceDelegate.notaries","title":"Notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/notaries/#notaries","text":"open fun notaries(): List<Party> Overrides NodeServiceDelegate.notaries","title":"notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/open-attachment/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / openAttachment openAttachment \u00b6 open fun openAttachment(hash: SecureHash): InputStream Overrides NodeServiceDelegate.openAttachment Retrieve the attachment matching the given secure hash from the vault","title":"Open attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/open-attachment/#openattachment","text":"open fun openAttachment(hash: SecureHash): InputStream Overrides NodeServiceDelegate.openAttachment Retrieve the attachment matching the given secure hash from the vault","title":"openAttachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/parties-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / partiesFromName partiesFromName \u00b6 @Suspendable open fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Overrides NodeServiceDelegate.partiesFromName Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. Parameters \u00b6 query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parties from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/parties-from-name/#partiesfromname","text":"@Suspendable open fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Overrides NodeServiceDelegate.partiesFromName Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted.","title":"partiesFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/parties-from-name/#parameters","text":"query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/peers/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / peers peers \u00b6 open fun peers(): List<Party> Overrides NodeServiceDelegate.peers Returns the node\u2019s network peers, excluding self and notaries.","title":"Peers"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/peers/#peers","text":"open fun peers(): List<Party> Overrides NodeServiceDelegate.peers Returns the node\u2019s network peers, excluding self and notaries.","title":"peers"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/platform-version/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / platformVersion platformVersion \u00b6 open fun platformVersion(): Int Overrides NodeServiceDelegate.platformVersion","title":"Platform version"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/platform-version/#platformversion","text":"open fun platformVersion(): Int Overrides NodeServiceDelegate.platformVersion","title":"platformVersion"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / queryBy queryBy \u00b6 @Suspendable open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page< T > Overrides NodeServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/query-by/#queryby","text":"@Suspendable open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page< T > Overrides NodeServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/server-time/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / serverTime serverTime \u00b6 open fun serverTime(): LocalDateTime Overrides NodeServiceDelegate.serverTime","title":"Server time"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/server-time/#servertime","text":"open fun serverTime(): LocalDateTime Overrides NodeServiceDelegate.serverTime","title":"serverTime"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/service-hub/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / serviceHub serviceHub \u00b6 val serviceHub: S","title":"Service hub"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/service-hub/#servicehub","text":"val serviceHub: S","title":"serviceHub"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / trackBy trackBy \u00b6 @Suspendable open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed<Page< T >, Update< T >> Overrides NodeServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/track-by/#trackby","text":"@Suspendable open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed<Page< T >, Update< T >> Overrides NodeServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/upload-attachment/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / uploadAttachment uploadAttachment \u00b6 open fun uploadAttachment(inputStream: InputStream): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar to the node, returns it\u2019s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar including metadata to the node, returns it\u2019s hash.","title":"Upload attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/upload-attachment/#uploadattachment","text":"open fun uploadAttachment(inputStream: InputStream): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar to the node, returns it\u2019s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar including metadata to the node, returns it\u2019s hash.","title":"uploadAttachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/well-known-party-from-x500-name/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / wellKnownPartyFromX500Name wellKnownPartyFromX500Name \u00b6 @Suspendable open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Overrides NodeServiceDelegate.wellKnownPartyFromX500Name Returns a Party match for the given CordaX500Name if found, null otherwise Parameters \u00b6 name - The name to convert to a party","title":"Well known party from x500 name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/well-known-party-from-x500-name/#wellknownpartyfromx500name","text":"@Suspendable open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Overrides NodeServiceDelegate.wellKnownPartyFromX500Name Returns a Party match for the given CordaX500Name if found, null otherwise","title":"wellKnownPartyFromX500Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/well-known-party-from-x500-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService BasicNodeService \u00b6 open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation Constructors \u00b6 Name Summary <init> BasicNodeService(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicNodeService(serviceHub: ServiceHub, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor, initializes a Corda Service delegate BasicNodeService(delegate: NodeServiceDelegate ) Basic NodeService implementation Properties \u00b6 Name Summary delegate open val delegate: NodeServiceDelegate Functions \u00b6 Name Summary countBy open fun <T : ContractState> countBy(contractStateType: Class< T >, criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun <T : ContractState> findByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any queryBy open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inherited Functions \u00b6 Name Summary findByLinearId open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UUID if any open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun <T : ContractState> getByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T > Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List<UUID> = emptyList()): StateAndRef< T > Find the state of type T matching the given UUID if any, throw an error otherwise open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise Inheritors \u00b6 Name Summary BasicStateService open class BasicStateService<T : ContractState> : BasicNodeService , StateServiceDelegate < T >, StateService < T > Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#basicnodeservice","text":"open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation","title":"BasicNodeService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#constructors","text":"Name Summary <init> BasicNodeService(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicNodeService(serviceHub: ServiceHub, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor, initializes a Corda Service delegate BasicNodeService(delegate: NodeServiceDelegate ) Basic NodeService implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#properties","text":"Name Summary delegate open val delegate: NodeServiceDelegate","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#functions","text":"Name Summary countBy open fun <T : ContractState> countBy(contractStateType: Class< T >, criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun <T : ContractState> findByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any queryBy open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#inherited-functions","text":"Name Summary findByLinearId open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UUID if any open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun <T : ContractState> getByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T > Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List<UUID> = emptyList()): StateAndRef< T > Find the state of type T matching the given UUID if any, throw an error otherwise open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#inheritors","text":"Name Summary BasicStateService open class BasicStateService<T : ContractState> : BasicNodeService , StateServiceDelegate < T >, StateService < T > Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / <init> <init> \u00b6 BasicNodeService(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicNodeService(serviceHub: ServiceHub, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor, initializes a Corda Service delegate BasicNodeService(delegate: NodeServiceDelegate ) Basic NodeService implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/-init-/#init","text":"BasicNodeService(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicNodeService(serviceHub: ServiceHub, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor, initializes a Corda Service delegate BasicNodeService(delegate: NodeServiceDelegate ) Basic NodeService implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/count-by/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / countBy countBy \u00b6 @Suspendable open fun <T : ContractState> countBy(contractStateType: Class< T >, criteria: QueryCriteria): Long Overrides NodeService.countBy Count states of type T matching stored in the vault and matching any given criteria","title":"Count by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/count-by/#countby","text":"@Suspendable open fun <T : ContractState> countBy(contractStateType: Class< T >, criteria: QueryCriteria): Long Overrides NodeService.countBy Count states of type T matching stored in the vault and matching any given criteria","title":"countBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/delegate/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / delegate delegate \u00b6 open val delegate: NodeServiceDelegate","title":"Delegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/delegate/#delegate","text":"open val delegate: NodeServiceDelegate","title":"delegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/find-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / findByExternalId findByExternalId \u00b6 @Suspendable open fun <T : ContractState> findByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T >? Overrides NodeService.findByExternalId Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"Find by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/find-by-external-id/#findbyexternalid","text":"@Suspendable open fun <T : ContractState> findByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T >? Overrides NodeService.findByExternalId Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"findByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/find-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / findByLinearId findByLinearId \u00b6 @Suspendable open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef< T >? Overrides NodeService.findByLinearId Find the state of type T matching the given UniqueIdentifier if any","title":"Find by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/find-by-linear-id/#findbylinearid","text":"@Suspendable open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef< T >? Overrides NodeService.findByLinearId Find the state of type T matching the given UniqueIdentifier if any","title":"findByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / queryBy queryBy \u00b6 @Suspendable open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page< T > Overrides NodeService.queryBy Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/query-by/#queryby","text":"@Suspendable open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page< T > Overrides NodeService.queryBy Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / trackBy trackBy \u00b6 @Suspendable open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed<Page< T >, Update< T >> Overrides NodeService.trackBy Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/track-by/#trackby","text":"@Suspendable open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed<Page< T >, Update< T >> Overrides NodeService.trackBy Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/","text":"com.github.manosbatsis.vaultaire.service.node / NodeCordaServiceDelegate NodeCordaServiceDelegate \u00b6 abstract class NodeCordaServiceDelegate : AbstractNodeServiceHubDelegate <AppServiceHub> Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService Constructors \u00b6 Name Summary <init> NodeCordaServiceDelegate(serviceHub: AppServiceHub) Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService Properties \u00b6 Name Summary defaults open val defaults: ServiceDefaults Inherited Properties \u00b6 Name Summary nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name serviceHub val serviceHub: S Inherited Functions \u00b6 Name Summary addresses open fun addresses(): List<NetworkHostAndPort> createStateService open fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flowAwareStartFlow fun <T> flowAwareStartFlow(flowLogic: FlowLogic< T >): CordaFuture< T > Will start the given flow as a subflow of the current top-level FlowLogic if any, or using the AppServiceHub otherwise. flows open fun flows(): List<String> getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List<Party> nodes open fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List<Party> openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inheritors \u00b6 Name Summary StateCordaServiceDelegate abstract class StateCordaServiceDelegate<T : ContractState> : NodeCordaServiceDelegate , StateServiceDelegate < T > Implementation of StateServiceDelegate as a CordaService","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/#nodecordaservicedelegate","text":"abstract class NodeCordaServiceDelegate : AbstractNodeServiceHubDelegate <AppServiceHub> Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService","title":"NodeCordaServiceDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/#constructors","text":"Name Summary <init> NodeCordaServiceDelegate(serviceHub: AppServiceHub) Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/#properties","text":"Name Summary defaults open val defaults: ServiceDefaults","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/#inherited-properties","text":"Name Summary nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name serviceHub val serviceHub: S","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/#inherited-functions","text":"Name Summary addresses open fun addresses(): List<NetworkHostAndPort> createStateService open fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flowAwareStartFlow fun <T> flowAwareStartFlow(flowLogic: FlowLogic< T >): CordaFuture< T > Will start the given flow as a subflow of the current top-level FlowLogic if any, or using the AppServiceHub otherwise. flows open fun flows(): List<String> getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List<Party> nodes open fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List<Party> openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/#inheritors","text":"Name Summary StateCordaServiceDelegate abstract class StateCordaServiceDelegate<T : ContractState> : NodeCordaServiceDelegate , StateServiceDelegate < T > Implementation of StateServiceDelegate as a CordaService","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / NodeCordaServiceDelegate / <init> <init> \u00b6 NodeCordaServiceDelegate(serviceHub: AppServiceHub) Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/-init-/#init","text":"NodeCordaServiceDelegate(serviceHub: AppServiceHub) Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/defaults/","text":"com.github.manosbatsis.vaultaire.service.node / NodeCordaServiceDelegate / defaults defaults \u00b6 open val defaults: ServiceDefaults Overrides NodeServiceDelegate.defaults","title":"Defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/defaults/#defaults","text":"open val defaults: ServiceDefaults Overrides NodeServiceDelegate.defaults","title":"defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService NodeService \u00b6 interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type Parameters \u00b6 T - the ContractState type Inherited Properties \u00b6 Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name Functions \u00b6 Name Summary countBy abstract fun <T : ContractState> countBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId abstract fun <T : ContractState> findByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UUID if any open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? abstract fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun <T : ContractState> getByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T > Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List<UUID> = emptyList()): StateAndRef< T > Find the state of type T matching the given UUID if any, throw an error otherwise open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy abstract fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy abstract fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inherited Functions \u00b6 Name Summary addresses abstract fun addresses(): List<NetworkHostAndPort> createStateService abstract fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. flows abstract fun flows(): List<String> getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getNodeInfo abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. identities abstract fun identities(): List<Party> isLinearState open fun <T : ContractState> isLinearState(contractStateType: Class< T >): Boolean isQueryableState open fun <T : ContractState> isQueryableState(contractStateType: Class< T >): Boolean nodes abstract fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries. notaries abstract fun notaries(): List<Party> openAttachment abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers abstract fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries. platformVersion abstract fun platformVersion(): Int queryBy abstract fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault serverTime abstract fun serverTime(): LocalDateTime toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash. wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inheritors \u00b6 Name Summary BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation StateService interface StateService<T : ContractState> : NodeService , StateServiceDelegate < T > Short-lived helper, used for vault operations on a specific ContractState type","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#nodeservice","text":"interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type","title":"NodeService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#inherited-properties","text":"Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#functions","text":"Name Summary countBy abstract fun <T : ContractState> countBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId abstract fun <T : ContractState> findByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UUID if any open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? abstract fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun <T : ContractState> getByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T > Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List<UUID> = emptyList()): StateAndRef< T > Find the state of type T matching the given UUID if any, throw an error otherwise open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy abstract fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy abstract fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#inherited-functions","text":"Name Summary addresses abstract fun addresses(): List<NetworkHostAndPort> createStateService abstract fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. flows abstract fun flows(): List<String> getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getNodeInfo abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. identities abstract fun identities(): List<Party> isLinearState open fun <T : ContractState> isLinearState(contractStateType: Class< T >): Boolean isQueryableState open fun <T : ContractState> isQueryableState(contractStateType: Class< T >): Boolean nodes abstract fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries. notaries abstract fun notaries(): List<Party> openAttachment abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers abstract fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries. platformVersion abstract fun platformVersion(): Int queryBy abstract fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault serverTime abstract fun serverTime(): LocalDateTime toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash. wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#inheritors","text":"Name Summary BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation StateService interface StateService<T : ContractState> : NodeService , StateServiceDelegate < T > Short-lived helper, used for vault operations on a specific ContractState type","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/count-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / countBy countBy \u00b6 abstract fun <T : ContractState> countBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria","title":"Count by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/count-by/#countby","text":"abstract fun <T : ContractState> countBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria","title":"countBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/find-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / findByExternalId findByExternalId \u00b6 abstract fun <T : ContractState> findByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"Find by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/find-by-external-id/#findbyexternalid","text":"abstract fun <T : ContractState> findByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T >? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"findByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/find-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / findByLinearId findByLinearId \u00b6 @Suspendable open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UUID if any @Suspendable open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? @Suspendable abstract fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any","title":"Find by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/find-by-linear-id/#findbylinearid","text":"@Suspendable open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UUID if any @Suspendable open fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? @Suspendable abstract fun <T : ContractState> findByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T >? Find the state of type T matching the given UniqueIdentifier if any","title":"findByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / getByExternalId getByExternalId \u00b6 @Suspendable open fun <T : ContractState> getByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T > Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise Exceptions \u00b6 NotFoundException - if no match is found","title":"Get by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-external-id/#getbyexternalid","text":"@Suspendable open fun <T : ContractState> getByExternalId(contractStateType: Class< T >, externalId: String): StateAndRef< T > Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise","title":"getByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-external-id/#exceptions","text":"NotFoundException - if no match is found","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / getByLinearId getByLinearId \u00b6 @Suspendable open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List<UUID> = emptyList()): StateAndRef< T > Find the state of type T matching the given UUID if any, throw an error otherwise Exceptions \u00b6 NotFoundException - if no match is found @Suspendable open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > @Suspendable open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise Exceptions \u00b6 NotFoundException - if no match is found","title":"Get by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-linear-id/#getbylinearid","text":"@Suspendable open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List<UUID> = emptyList()): StateAndRef< T > Find the state of type T matching the given UUID if any, throw an error otherwise","title":"getByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-linear-id/#exceptions","text":"NotFoundException - if no match is found @Suspendable open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > @Suspendable open fun <T : ContractState> getByLinearId(contractStateType: Class< T >, linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef< T > Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-linear-id/#exceptions_1","text":"NotFoundException - if no match is found","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / queryBy queryBy \u00b6 abstract fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/query-by/#queryby","text":"abstract fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page< T > Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / trackBy trackBy \u00b6 abstract fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/track-by/#trackby","text":"abstract fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate NodeServiceDelegate \u00b6 interface NodeServiceDelegate NodeService delegate for vault operations Properties \u00b6 Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name Functions \u00b6 Name Summary addresses abstract fun addresses(): List<NetworkHostAndPort> createStateService abstract fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. flows abstract fun flows(): List<String> getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getNodeInfo abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. identities abstract fun identities(): List<Party> isLinearState open fun <T : ContractState> isLinearState(contractStateType: Class< T >): Boolean isQueryableState open fun <T : ContractState> isQueryableState(contractStateType: Class< T >): Boolean nodes abstract fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries. notaries abstract fun notaries(): List<Party> openAttachment abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers abstract fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries. platformVersion abstract fun platformVersion(): Int queryBy abstract fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault serverTime abstract fun serverTime(): LocalDateTime toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash. wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inheritors \u00b6 Name Summary AbstractNodeServiceHubDelegate abstract class AbstractNodeServiceHubDelegate<S : ServiceHub> : SingletonSerializeAsToken, NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation NodeService interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type NodeServiceRpcPoolBoyDelegate open class NodeServiceRpcPoolBoyDelegate : NodeServiceDelegate RPC implementation base StateServiceDelegate interface StateServiceDelegate<T : ContractState> : NodeServiceDelegate StateService delegate for vault operations","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/#nodeservicedelegate","text":"interface NodeServiceDelegate NodeService delegate for vault operations","title":"NodeServiceDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/#properties","text":"Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/#functions","text":"Name Summary addresses abstract fun addresses(): List<NetworkHostAndPort> createStateService abstract fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. flows abstract fun flows(): List<String> getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getNodeInfo abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. identities abstract fun identities(): List<Party> isLinearState open fun <T : ContractState> isLinearState(contractStateType: Class< T >): Boolean isQueryableState open fun <T : ContractState> isQueryableState(contractStateType: Class< T >): Boolean nodes abstract fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries. notaries abstract fun notaries(): List<Party> openAttachment abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers abstract fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries. platformVersion abstract fun platformVersion(): Int queryBy abstract fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault serverTime abstract fun serverTime(): LocalDateTime toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash. wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/#inheritors","text":"Name Summary AbstractNodeServiceHubDelegate abstract class AbstractNodeServiceHubDelegate<S : ServiceHub> : SingletonSerializeAsToken, NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation NodeService interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type NodeServiceRpcPoolBoyDelegate open class NodeServiceRpcPoolBoyDelegate : NodeServiceDelegate RPC implementation base StateServiceDelegate interface StateServiceDelegate<T : ContractState> : NodeServiceDelegate StateService delegate for vault operations","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/addresses/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / addresses addresses \u00b6 abstract fun addresses(): List<NetworkHostAndPort>","title":"Addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/addresses/#addresses","text":"abstract fun addresses(): List<NetworkHostAndPort>","title":"addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/create-state-service/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / createStateService createStateService \u00b6 abstract fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized.","title":"Create state service"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/create-state-service/#createstateservice","text":"abstract fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized.","title":"createStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/defaults/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / defaults defaults \u00b6 abstract val defaults: ServiceDefaults","title":"Defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/defaults/#defaults","text":"abstract val defaults: ServiceDefaults","title":"defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/find-party-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / findPartyFromName findPartyFromName \u00b6 @Suspendable open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. Parameters \u00b6 name - The name to convert to a party","title":"Find party from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/find-party-from-name/#findpartyfromname","text":"@Suspendable open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching.","title":"findPartyFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/find-party-from-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/flows/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / flows flows \u00b6 abstract fun flows(): List<String>","title":"Flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/flows/#flows","text":"abstract fun flows(): List<String>","title":"flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-extended-info/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / getExtendedInfo getExtendedInfo \u00b6 open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo","title":"Get extended info"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-extended-info/#getextendedinfo","text":"open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo","title":"getExtendedInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-node-info/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / getNodeInfo getNodeInfo \u00b6 abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo","title":"Get node info"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-node-info/#getnodeinfo","text":"abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo","title":"getNodeInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-party-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / getPartyFromName getPartyFromName \u00b6 @Suspendable open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. Parameters \u00b6 name - The name to convert to a party","title":"Get party from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-party-from-name/#getpartyfromname","text":"@Suspendable open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown.","title":"getPartyFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-party-from-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/identities/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / identities identities \u00b6 abstract fun identities(): List<Party>","title":"Identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/identities/#identities","text":"abstract fun identities(): List<Party>","title":"identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/is-linear-state/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / isLinearState isLinearState \u00b6 open fun <T : ContractState> isLinearState(contractStateType: Class< T >): Boolean","title":"Is linear state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/is-linear-state/#islinearstate","text":"open fun <T : ContractState> isLinearState(contractStateType: Class< T >): Boolean","title":"isLinearState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/is-queryable-state/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / isQueryableState isQueryableState \u00b6 open fun <T : ContractState> isQueryableState(contractStateType: Class< T >): Boolean","title":"Is queryable state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/is-queryable-state/#isqueryablestate","text":"open fun <T : ContractState> isQueryableState(contractStateType: Class< T >): Boolean","title":"isQueryableState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-identity-criteria/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / nodeIdentityCriteria nodeIdentityCriteria \u00b6 abstract val nodeIdentityCriteria: LinearStateQueryCriteria","title":"Node identity criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-identity-criteria/#nodeidentitycriteria","text":"abstract val nodeIdentityCriteria: LinearStateQueryCriteria","title":"nodeIdentityCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-identity/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / nodeIdentity nodeIdentity \u00b6 abstract val nodeIdentity: Party","title":"Node identity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-identity/#nodeidentity","text":"abstract val nodeIdentity: Party","title":"nodeIdentity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-legal-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / nodeLegalName nodeLegalName \u00b6 abstract val nodeLegalName: CordaX500Name","title":"Node legal name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-legal-name/#nodelegalname","text":"abstract val nodeLegalName: CordaX500Name","title":"nodeLegalName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/nodes/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / nodes nodes \u00b6 abstract fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries.","title":"Nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/nodes/#nodes","text":"abstract fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries.","title":"nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/notaries/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / notaries notaries \u00b6 abstract fun notaries(): List<Party>","title":"Notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/notaries/#notaries","text":"abstract fun notaries(): List<Party>","title":"notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/open-attachment/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / openAttachment openAttachment \u00b6 abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault","title":"Open attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/open-attachment/#openattachment","text":"abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault","title":"openAttachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/parties-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / partiesFromName partiesFromName \u00b6 @Suspendable abstract fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. Parameters \u00b6 query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parties from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/parties-from-name/#partiesfromname","text":"@Suspendable abstract fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted.","title":"partiesFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/parties-from-name/#parameters","text":"query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/peers/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / peers peers \u00b6 abstract fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries.","title":"Peers"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/peers/#peers","text":"abstract fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries.","title":"peers"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/platform-version/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / platformVersion platformVersion \u00b6 abstract fun platformVersion(): Int","title":"Platform version"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/platform-version/#platformversion","text":"abstract fun platformVersion(): Int","title":"platformVersion"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / queryBy queryBy \u00b6 @Suspendable abstract fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/query-by/#queryby","text":"@Suspendable abstract fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/save-attachment/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / saveAttachment saveAttachment \u00b6 open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault","title":"Save attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/save-attachment/#saveattachment","text":"open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault","title":"saveAttachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/server-time/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / serverTime serverTime \u00b6 abstract fun serverTime(): LocalDateTime","title":"Server time"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/server-time/#servertime","text":"abstract fun serverTime(): LocalDateTime","title":"serverTime"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/to-corda-x500-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / toCordaX500Name toCordaX500Name \u00b6 @Suspendable open fun toCordaX500Name(query: String): CordaX500Name","title":"To corda x500 name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/to-corda-x500-name/#tocordax500name","text":"@Suspendable open fun toCordaX500Name(query: String): CordaX500Name","title":"toCordaX500Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / trackBy trackBy \u00b6 @Suspendable abstract fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/track-by/#trackby","text":"@Suspendable abstract fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/upload-attachment/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / uploadAttachment uploadAttachment \u00b6 abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash.","title":"Upload attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/upload-attachment/#uploadattachment","text":"abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash.","title":"uploadAttachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/well-known-party-from-x500-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / wellKnownPartyFromX500Name wellKnownPartyFromX500Name \u00b6 @Suspendable abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Parameters \u00b6 name - The name to convert to a party","title":"Well known party from x500 name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/well-known-party-from-x500-name/#wellknownpartyfromx500name","text":"@Suspendable abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"wellKnownPartyFromX500Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/well-known-party-from-x500-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate NodeServiceRpcPoolBoyDelegate \u00b6 open class NodeServiceRpcPoolBoyDelegate : NodeServiceDelegate RPC implementation base Constructors \u00b6 Name Summary <init> NodeServiceRpcPoolBoyDelegate(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) RPC implementation base Properties \u00b6 Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name poolBoy val poolBoy: PoolBoyConnection Functions \u00b6 Name Summary addresses open fun addresses(): List<NetworkHostAndPort> createStateService open fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flows open fun flows(): List<String> getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List<Party> nodes open fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List<Party> openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inherited Functions \u00b6 Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun <T : ContractState> isLinearState(contractStateType: Class< T >): Boolean isQueryableState open fun <T : ContractState> isQueryableState(contractStateType: Class< T >): Boolean openAttachment open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name Inheritors \u00b6 Name Summary StateServicePoolBoyDelegate open class StateServicePoolBoyDelegate<T : ContractState> : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate < T >","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/#nodeservicerpcpoolboydelegate","text":"open class NodeServiceRpcPoolBoyDelegate : NodeServiceDelegate RPC implementation base","title":"NodeServiceRpcPoolBoyDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/#constructors","text":"Name Summary <init> NodeServiceRpcPoolBoyDelegate(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) RPC implementation base","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/#properties","text":"Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name poolBoy val poolBoy: PoolBoyConnection","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/#functions","text":"Name Summary addresses open fun addresses(): List<NetworkHostAndPort> createStateService open fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flows open fun flows(): List<String> getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List<Party> nodes open fun nodes(): List<Party> Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List<Party> openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List<Party> Returns the node\u2019s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page< T > Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed<Page< T >, Update< T >> Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it\u2019s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it\u2019s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/#inherited-functions","text":"Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun <T : ContractState> isLinearState(contractStateType: Class< T >): Boolean isQueryableState open fun <T : ContractState> isQueryableState(contractStateType: Class< T >): Boolean openAttachment open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/#inheritors","text":"Name Summary StateServicePoolBoyDelegate open class StateServicePoolBoyDelegate<T : ContractState> : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate < T >","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / <init> <init> \u00b6 NodeServiceRpcPoolBoyDelegate(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) RPC implementation base","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/-init-/#init","text":"NodeServiceRpcPoolBoyDelegate(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) RPC implementation base","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/addresses/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / addresses addresses \u00b6 open fun addresses(): List<NetworkHostAndPort> Overrides NodeServiceDelegate.addresses","title":"Addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/addresses/#addresses","text":"open fun addresses(): List<NetworkHostAndPort> Overrides NodeServiceDelegate.addresses","title":"addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/create-state-service/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / createStateService createStateService \u00b6 open fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Overrides NodeServiceDelegate.createStateService Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized.","title":"Create state service"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/create-state-service/#createstateservice","text":"open fun <T : ContractState, S : StateService < T >> createStateService(contractStateType: Class< T >): S Overrides NodeServiceDelegate.createStateService Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized.","title":"createStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/defaults/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / defaults defaults \u00b6 open val defaults: ServiceDefaults Overrides NodeServiceDelegate.defaults","title":"Defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/defaults/#defaults","text":"open val defaults: ServiceDefaults Overrides NodeServiceDelegate.defaults","title":"defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/flows/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / flows flows \u00b6 open fun flows(): List<String> Overrides NodeServiceDelegate.flows","title":"Flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/flows/#flows","text":"open fun flows(): List<String> Overrides NodeServiceDelegate.flows","title":"flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/get-node-info/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / getNodeInfo getNodeInfo \u00b6 open fun getNodeInfo(): NodeInfo Overrides NodeServiceDelegate.getNodeInfo Get information about the node in context as an NodeInfo","title":"Get node info"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/get-node-info/#getnodeinfo","text":"open fun getNodeInfo(): NodeInfo Overrides NodeServiceDelegate.getNodeInfo Get information about the node in context as an NodeInfo","title":"getNodeInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/identities/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / identities identities \u00b6 open fun identities(): List<Party> Overrides NodeServiceDelegate.identities","title":"Identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/identities/#identities","text":"open fun identities(): List<Party> Overrides NodeServiceDelegate.identities","title":"identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/node-identity-criteria/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / nodeIdentityCriteria nodeIdentityCriteria \u00b6 open val nodeIdentityCriteria: LinearStateQueryCriteria Overrides NodeServiceDelegate.nodeIdentityCriteria","title":"Node identity criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/node-identity-criteria/#nodeidentitycriteria","text":"open val nodeIdentityCriteria: LinearStateQueryCriteria Overrides NodeServiceDelegate.nodeIdentityCriteria","title":"nodeIdentityCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/node-identity/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / nodeIdentity nodeIdentity \u00b6 open val nodeIdentity: Party Overrides NodeServiceDelegate.nodeIdentity","title":"Node identity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/node-identity/#nodeidentity","text":"open val nodeIdentity: Party Overrides NodeServiceDelegate.nodeIdentity","title":"nodeIdentity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/node-legal-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / nodeLegalName nodeLegalName \u00b6 open val nodeLegalName: CordaX500Name Overrides NodeServiceDelegate.nodeLegalName","title":"Node legal name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/node-legal-name/#nodelegalname","text":"open val nodeLegalName: CordaX500Name Overrides NodeServiceDelegate.nodeLegalName","title":"nodeLegalName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/nodes/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / nodes nodes \u00b6 open fun nodes(): List<Party> Overrides NodeServiceDelegate.nodes Get a list of nodes in the network, including self and notaries.","title":"Nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/nodes/#nodes","text":"open fun nodes(): List<Party> Overrides NodeServiceDelegate.nodes Get a list of nodes in the network, including self and notaries.","title":"nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/notaries/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / notaries notaries \u00b6 open fun notaries(): List<Party> Overrides NodeServiceDelegate.notaries","title":"Notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/notaries/#notaries","text":"open fun notaries(): List<Party> Overrides NodeServiceDelegate.notaries","title":"notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/open-attachment/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / openAttachment openAttachment \u00b6 open fun openAttachment(hash: SecureHash): InputStream Overrides NodeServiceDelegate.openAttachment Retrieve the attachment matching the given secure hash from the vault","title":"Open attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/open-attachment/#openattachment","text":"open fun openAttachment(hash: SecureHash): InputStream Overrides NodeServiceDelegate.openAttachment Retrieve the attachment matching the given secure hash from the vault","title":"openAttachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/parties-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / partiesFromName partiesFromName \u00b6 open fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Overrides NodeServiceDelegate.partiesFromName Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. Parameters \u00b6 query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parties from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/parties-from-name/#partiesfromname","text":"open fun partiesFromName(query: String, exactMatch: Boolean): Set<Party> Overrides NodeServiceDelegate.partiesFromName Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted.","title":"partiesFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/parties-from-name/#parameters","text":"query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/peers/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / peers peers \u00b6 open fun peers(): List<Party> Overrides NodeServiceDelegate.peers Returns the node\u2019s network peers, excluding self and notaries.","title":"Peers"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/peers/#peers","text":"open fun peers(): List<Party> Overrides NodeServiceDelegate.peers Returns the node\u2019s network peers, excluding self and notaries.","title":"peers"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/platform-version/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / platformVersion platformVersion \u00b6 open fun platformVersion(): Int Overrides NodeServiceDelegate.platformVersion","title":"Platform version"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/platform-version/#platformversion","text":"open fun platformVersion(): Int Overrides NodeServiceDelegate.platformVersion","title":"platformVersion"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/pool-boy/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / poolBoy poolBoy \u00b6 val poolBoy: PoolBoyConnection","title":"Pool boy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/pool-boy/#poolboy","text":"val poolBoy: PoolBoyConnection","title":"poolBoy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / queryBy queryBy \u00b6 open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page< T > Overrides NodeServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/query-by/#queryby","text":"open fun <T : ContractState> queryBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page< T > Overrides NodeServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/server-time/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / serverTime serverTime \u00b6 open fun serverTime(): LocalDateTime Overrides NodeServiceDelegate.serverTime","title":"Server time"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/server-time/#servertime","text":"open fun serverTime(): LocalDateTime Overrides NodeServiceDelegate.serverTime","title":"serverTime"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / trackBy trackBy \u00b6 open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed<Page< T >, Update< T >> Overrides NodeServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/track-by/#trackby","text":"open fun <T : ContractState> trackBy(contractStateType: Class< T >, criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed<Page< T >, Update< T >> Overrides NodeServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/upload-attachment/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / uploadAttachment uploadAttachment \u00b6 open fun uploadAttachment(inputStream: InputStream): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar to the node, returns it\u2019s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar including metadata to the node, returns it\u2019s hash.","title":"Upload attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/upload-attachment/#uploadattachment","text":"open fun uploadAttachment(inputStream: InputStream): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar to the node, returns it\u2019s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar including metadata to the node, returns it\u2019s hash.","title":"uploadAttachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/well-known-party-from-x500-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / wellKnownPartyFromX500Name wellKnownPartyFromX500Name \u00b6 open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Overrides NodeServiceDelegate.wellKnownPartyFromX500Name Returns a Party match for the given CordaX500Name if found, null otherwise Parameters \u00b6 name - The name to convert to a party","title":"Well known party from x500 name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/well-known-party-from-x500-name/#wellknownpartyfromx500name","text":"open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Overrides NodeServiceDelegate.wellKnownPartyFromX500Name Returns a Party match for the given CordaX500Name if found, null otherwise","title":"wellKnownPartyFromX500Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/well-known-party-from-x500-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-not-found-exception/","text":"com.github.manosbatsis.vaultaire.service.node / NotFoundException NotFoundException \u00b6 class NotFoundException : RuntimeException Constructors \u00b6 Name Summary <init> NotFoundException(id: String, stateType: Class<*>)","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-not-found-exception/#notfoundexception","text":"class NotFoundException : RuntimeException","title":"NotFoundException"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-not-found-exception/#constructors","text":"Name Summary <init> NotFoundException(id: String, stateType: Class<*>)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-not-found-exception/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / NotFoundException / <init> <init> \u00b6 NotFoundException(id: String, stateType: Class<*>)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-not-found-exception/-init-/#init","text":"NotFoundException(id: String, stateType: Class<*>)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/","text":"com.github.manosbatsis.vaultaire.util Package com.github.manosbatsis.vaultaire.util \u00b6 Types \u00b6 Name Summary DummyContract class DummyContract : Contract Fields interface Fields<T> Extended by Vaultaire\u2019s annotation processing to provide easy access to fields of a StatePersistable type FieldWrapper interface FieldWrapper<T> GenericFieldWrapper class GenericFieldWrapper<T, S> : TypedFieldWrapper < T , S > Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper<T, S> : TypedFieldWrapper < T , S ?> Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder ResultsPage open class ResultsPage<T> A wrapper for page results. Typically used as a more REST-friendly alternative to Vault.Page combined with mapping to states or DTOs. TypedFieldWrapper interface TypedFieldWrapper<T, S> : FieldWrapper < T > Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder ViewField interface ViewField Extensions for External Classes \u00b6 Name Summary kotlin.String","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/#package-comgithubmanosbatsisvaultaireutil","text":"","title":"Package com.github.manosbatsis.vaultaire.util"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/#types","text":"Name Summary DummyContract class DummyContract : Contract Fields interface Fields<T> Extended by Vaultaire\u2019s annotation processing to provide easy access to fields of a StatePersistable type FieldWrapper interface FieldWrapper<T> GenericFieldWrapper class GenericFieldWrapper<T, S> : TypedFieldWrapper < T , S > Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper<T, S> : TypedFieldWrapper < T , S ?> Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder ResultsPage open class ResultsPage<T> A wrapper for page results. Typically used as a more REST-friendly alternative to Vault.Page combined with mapping to states or DTOs. TypedFieldWrapper interface TypedFieldWrapper<T, S> : FieldWrapper < T > Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder ViewField interface ViewField","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/#extensions-for-external-classes","text":"Name Summary kotlin.String","title":"Extensions for External Classes"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-view-field/","text":"com.github.manosbatsis.vaultaire.util / ViewField ViewField \u00b6 interface ViewField","title":" view field"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-view-field/#viewfield","text":"interface ViewField","title":"ViewField"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dummy-contract/","text":"com.github.manosbatsis.vaultaire.util / DummyContract DummyContract \u00b6 class DummyContract : Contract Constructors \u00b6 Name Summary <init> DummyContract() Functions \u00b6 Name Summary verify fun verify(tx: LedgerTransaction): Unit Companion Object Properties \u00b6 Name Summary ID const val ID: String","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dummy-contract/#dummycontract","text":"class DummyContract : Contract","title":"DummyContract"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dummy-contract/#constructors","text":"Name Summary <init> DummyContract()","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dummy-contract/#functions","text":"Name Summary verify fun verify(tx: LedgerTransaction): Unit","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dummy-contract/#companion-object-properties","text":"Name Summary ID const val ID: String","title":"Companion Object Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dummy-contract/-i-d/","text":"com.github.manosbatsis.vaultaire.util / DummyContract / ID ID \u00b6 const val ID: String","title":" i d"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dummy-contract/-i-d/#id","text":"const val ID: String","title":"ID"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dummy-contract/-init-/","text":"com.github.manosbatsis.vaultaire.util / DummyContract / <init> <init> \u00b6 DummyContract()","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dummy-contract/-init-/#init","text":"DummyContract()","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dummy-contract/verify/","text":"com.github.manosbatsis.vaultaire.util / DummyContract / verify verify \u00b6 fun verify(tx: LedgerTransaction): Unit","title":"Verify"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dummy-contract/verify/#verify","text":"fun verify(tx: LedgerTransaction): Unit","title":"verify"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / FieldWrapper FieldWrapper \u00b6 interface FieldWrapper<T> Properties \u00b6 Name Summary property abstract val property: KProperty1< T , *> Inheritors \u00b6 Name Summary TypedFieldWrapper interface TypedFieldWrapper<T, S> : FieldWrapper < T > Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/#fieldwrapper","text":"interface FieldWrapper<T>","title":"FieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/#properties","text":"Name Summary property abstract val property: KProperty1< T , *>","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/#inheritors","text":"Name Summary TypedFieldWrapper interface TypedFieldWrapper<T, S> : FieldWrapper < T > Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / FieldWrapper / property property \u00b6 abstract val property: KProperty1< T , *>","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/property/#property","text":"abstract val property: KProperty1< T , *>","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/","text":"com.github.manosbatsis.vaultaire.util / Fields Fields \u00b6 interface Fields<T> Extended by Vaultaire\u2019s annotation processing to provide easy access to fields of a StatePersistable type Properties \u00b6 Name Summary fieldsByName abstract val fieldsByName: Map<String, FieldWrapper < T >> Functions \u00b6 Name Summary contains open fun contains(name: String): Boolean get open operator fun get(name: String): FieldWrapper < T >","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/#fields","text":"interface Fields<T> Extended by Vaultaire\u2019s annotation processing to provide easy access to fields of a StatePersistable type","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/#properties","text":"Name Summary fieldsByName abstract val fieldsByName: Map<String, FieldWrapper < T >>","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/#functions","text":"Name Summary contains open fun contains(name: String): Boolean get open operator fun get(name: String): FieldWrapper < T >","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/contains/","text":"com.github.manosbatsis.vaultaire.util / Fields / contains contains \u00b6 open fun contains(name: String): Boolean","title":"Contains"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/contains/#contains","text":"open fun contains(name: String): Boolean","title":"contains"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/fields-by-name/","text":"com.github.manosbatsis.vaultaire.util / Fields / fieldsByName fieldsByName \u00b6 abstract val fieldsByName: Map<String, FieldWrapper < T >>","title":"Fields by name"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/fields-by-name/#fieldsbyname","text":"abstract val fieldsByName: Map<String, FieldWrapper < T >>","title":"fieldsByName"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/get/","text":"com.github.manosbatsis.vaultaire.util / Fields / get get \u00b6 open operator fun get(name: String): FieldWrapper < T >","title":"Get"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/get/#get","text":"open operator fun get(name: String): FieldWrapper < T >","title":"get"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / GenericFieldWrapper GenericFieldWrapper \u00b6 class GenericFieldWrapper<T, S> : TypedFieldWrapper < T , S > Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Constructors \u00b6 Name Summary <init> GenericFieldWrapper(property: KProperty1< T , S >) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Properties \u00b6 Name Summary property val property: KProperty1< T , S > propertyNullable val propertyNullable: Boolean","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/#genericfieldwrapper","text":"class GenericFieldWrapper<T, S> : TypedFieldWrapper < T , S > Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"GenericFieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/#constructors","text":"Name Summary <init> GenericFieldWrapper(property: KProperty1< T , S >) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/#properties","text":"Name Summary property val property: KProperty1< T , S > propertyNullable val propertyNullable: Boolean","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/-init-/","text":"com.github.manosbatsis.vaultaire.util / GenericFieldWrapper / <init> <init> \u00b6 GenericFieldWrapper(property: KProperty1< T , S >) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/-init-/#init","text":"GenericFieldWrapper(property: KProperty1< T , S >) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/property-nullable/","text":"com.github.manosbatsis.vaultaire.util / GenericFieldWrapper / propertyNullable propertyNullable \u00b6 val propertyNullable: Boolean Overrides TypedFieldWrapper.propertyNullable","title":"Property nullable"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/property-nullable/#propertynullable","text":"val propertyNullable: Boolean Overrides TypedFieldWrapper.propertyNullable","title":"propertyNullable"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / GenericFieldWrapper / property property \u00b6 val property: KProperty1< T , S > Overrides TypedFieldWrapper.property","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/property/#property","text":"val property: KProperty1< T , S > Overrides TypedFieldWrapper.property","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / NullableGenericFieldWrapper NullableGenericFieldWrapper \u00b6 class NullableGenericFieldWrapper<T, S> : TypedFieldWrapper < T , S ?> Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Constructors \u00b6 Name Summary <init> NullableGenericFieldWrapper(property: KProperty1< T , S ?>) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Properties \u00b6 Name Summary property val property: KProperty1< T , S ?> propertyNullable val propertyNullable: Boolean","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/#nullablegenericfieldwrapper","text":"class NullableGenericFieldWrapper<T, S> : TypedFieldWrapper < T , S ?> Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"NullableGenericFieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/#constructors","text":"Name Summary <init> NullableGenericFieldWrapper(property: KProperty1< T , S ?>) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/#properties","text":"Name Summary property val property: KProperty1< T , S ?> propertyNullable val propertyNullable: Boolean","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/-init-/","text":"com.github.manosbatsis.vaultaire.util / NullableGenericFieldWrapper / <init> <init> \u00b6 NullableGenericFieldWrapper(property: KProperty1< T , S ?>) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/-init-/#init","text":"NullableGenericFieldWrapper(property: KProperty1< T , S ?>) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/property-nullable/","text":"com.github.manosbatsis.vaultaire.util / NullableGenericFieldWrapper / propertyNullable propertyNullable \u00b6 val propertyNullable: Boolean Overrides TypedFieldWrapper.propertyNullable","title":"Property nullable"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/property-nullable/#propertynullable","text":"val propertyNullable: Boolean Overrides TypedFieldWrapper.propertyNullable","title":"propertyNullable"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / NullableGenericFieldWrapper / property property \u00b6 val property: KProperty1< T , S ?> Overrides TypedFieldWrapper.property","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/property/#property","text":"val property: KProperty1< T , S ?> Overrides TypedFieldWrapper.property","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/","text":"com.github.manosbatsis.vaultaire.util / ResultsPage ResultsPage \u00b6 open class ResultsPage<T> A wrapper for page results. Typically used as a more REST-friendly alternative to Vault.Page combined with mapping to states or DTOs. Constructors \u00b6 Name Summary <init> ResultsPage(content: List< T > = emptyList(), pageSpecification: PageSpecification, totalResults: Long, sort: Sort)``ResultsPage(content: List< T > = emptyList(), pageNumber: Int = 1, pageSize: Int = 10, totalResults: Long = 0, sort: Map<String, Direction> = emptyMap()) A wrapper for page results. Typically used as a more REST-friendly alternative to Vault.Page combined with mapping to states or DTOs. Properties \u00b6 Name Summary content var content: List< T > pageNumber var pageNumber: Int pageSize var pageSize: Int sort var sort: Map<String, Direction> totalResults var totalResults: Long Companion Object Functions \u00b6 Name Summary from fun <C : ContractState> from(vaultPage: Page< C >, pageSpecification: PageSpecification, sort: Sort): ResultsPage < C > Build a ResultsPage using the states from the given Vault.Page fun <C : ContractState, T> from(vaultPage: Page< C >, pageSpecification: PageSpecification, sort: Sort, mapper: (original: Iterable<StateAndRef< C >>) -> List< T >): ResultsPage < T > Build a ResultsPage by applying the mapper to the given Vault.Page s states","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/#resultspage","text":"open class ResultsPage<T> A wrapper for page results. Typically used as a more REST-friendly alternative to Vault.Page combined with mapping to states or DTOs.","title":"ResultsPage"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/#constructors","text":"Name Summary <init> ResultsPage(content: List< T > = emptyList(), pageSpecification: PageSpecification, totalResults: Long, sort: Sort)``ResultsPage(content: List< T > = emptyList(), pageNumber: Int = 1, pageSize: Int = 10, totalResults: Long = 0, sort: Map<String, Direction> = emptyMap()) A wrapper for page results. Typically used as a more REST-friendly alternative to Vault.Page combined with mapping to states or DTOs.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/#properties","text":"Name Summary content var content: List< T > pageNumber var pageNumber: Int pageSize var pageSize: Int sort var sort: Map<String, Direction> totalResults var totalResults: Long","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/#companion-object-functions","text":"Name Summary from fun <C : ContractState> from(vaultPage: Page< C >, pageSpecification: PageSpecification, sort: Sort): ResultsPage < C > Build a ResultsPage using the states from the given Vault.Page fun <C : ContractState, T> from(vaultPage: Page< C >, pageSpecification: PageSpecification, sort: Sort, mapper: (original: Iterable<StateAndRef< C >>) -> List< T >): ResultsPage < T > Build a ResultsPage by applying the mapper to the given Vault.Page s states","title":"Companion Object Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/-init-/","text":"com.github.manosbatsis.vaultaire.util / ResultsPage / <init> <init> \u00b6 ResultsPage(content: List< T > = emptyList(), pageSpecification: PageSpecification, totalResults: Long, sort: Sort)``ResultsPage(content: List< T > = emptyList(), pageNumber: Int = 1, pageSize: Int = 10, totalResults: Long = 0, sort: Map<String, Direction> = emptyMap()) A wrapper for page results. Typically used as a more REST-friendly alternative to Vault.Page combined with mapping to states or DTOs.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/-init-/#init","text":"ResultsPage(content: List< T > = emptyList(), pageSpecification: PageSpecification, totalResults: Long, sort: Sort)``ResultsPage(content: List< T > = emptyList(), pageNumber: Int = 1, pageSize: Int = 10, totalResults: Long = 0, sort: Map<String, Direction> = emptyMap()) A wrapper for page results. Typically used as a more REST-friendly alternative to Vault.Page combined with mapping to states or DTOs.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/content/","text":"com.github.manosbatsis.vaultaire.util / ResultsPage / content content \u00b6 var content: List< T >","title":"Content"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/content/#content","text":"var content: List< T >","title":"content"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/from/","text":"com.github.manosbatsis.vaultaire.util / ResultsPage / from from \u00b6 fun <C : ContractState> from(vaultPage: Page< C >, pageSpecification: PageSpecification, sort: Sort): ResultsPage < C > Build a ResultsPage using the states from the given Vault.Page fun <C : ContractState, T> from(vaultPage: Page< C >, pageSpecification: PageSpecification, sort: Sort, mapper: (original: Iterable<StateAndRef< C >>) -> List< T >): ResultsPage < T > Build a ResultsPage by applying the mapper to the given Vault.Page s states","title":"From"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/from/#from","text":"fun <C : ContractState> from(vaultPage: Page< C >, pageSpecification: PageSpecification, sort: Sort): ResultsPage < C > Build a ResultsPage using the states from the given Vault.Page fun <C : ContractState, T> from(vaultPage: Page< C >, pageSpecification: PageSpecification, sort: Sort, mapper: (original: Iterable<StateAndRef< C >>) -> List< T >): ResultsPage < T > Build a ResultsPage by applying the mapper to the given Vault.Page s states","title":"from"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/page-number/","text":"com.github.manosbatsis.vaultaire.util / ResultsPage / pageNumber pageNumber \u00b6 var pageNumber: Int","title":"Page number"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/page-number/#pagenumber","text":"var pageNumber: Int","title":"pageNumber"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/page-size/","text":"com.github.manosbatsis.vaultaire.util / ResultsPage / pageSize pageSize \u00b6 var pageSize: Int","title":"Page size"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/page-size/#pagesize","text":"var pageSize: Int","title":"pageSize"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/sort/","text":"com.github.manosbatsis.vaultaire.util / ResultsPage / sort sort \u00b6 var sort: Map<String, Direction>","title":"Sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/sort/#sort","text":"var sort: Map<String, Direction>","title":"sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/total-results/","text":"com.github.manosbatsis.vaultaire.util / ResultsPage / totalResults totalResults \u00b6 var totalResults: Long","title":"Total results"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-results-page/total-results/#totalresults","text":"var totalResults: Long","title":"totalResults"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / TypedFieldWrapper TypedFieldWrapper \u00b6 interface TypedFieldWrapper<T, S> : FieldWrapper < T > Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Properties \u00b6 Name Summary property abstract val property: KProperty1< T , S > propertyNullable abstract val propertyNullable: Boolean Inheritors \u00b6 Name Summary GenericFieldWrapper class GenericFieldWrapper<T, S> : TypedFieldWrapper < T , S > Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper<T, S> : TypedFieldWrapper < T , S ?> Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/#typedfieldwrapper","text":"interface TypedFieldWrapper<T, S> : FieldWrapper < T > Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"TypedFieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/#properties","text":"Name Summary property abstract val property: KProperty1< T , S > propertyNullable abstract val propertyNullable: Boolean","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/#inheritors","text":"Name Summary GenericFieldWrapper class GenericFieldWrapper<T, S> : TypedFieldWrapper < T , S > Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper<T, S> : TypedFieldWrapper < T , S ?> Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/property-nullable/","text":"com.github.manosbatsis.vaultaire.util / TypedFieldWrapper / propertyNullable propertyNullable \u00b6 abstract val propertyNullable: Boolean","title":"Property nullable"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/property-nullable/#propertynullable","text":"abstract val propertyNullable: Boolean","title":"propertyNullable"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / TypedFieldWrapper / property property \u00b6 abstract val property: KProperty1< T , S > Overrides FieldWrapper.property","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/property/#property","text":"abstract val property: KProperty1< T , S > Overrides FieldWrapper.property","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/","text":"com.github.manosbatsis.vaultaire.util / kotlin.String Extensions for kotlin.String \u00b6 Name Summary asUniqueIdentifier fun String.asUniqueIdentifier(): UniqueIdentifier","title":"Index"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/#extensions-for-kotlinstring","text":"Name Summary asUniqueIdentifier fun String.asUniqueIdentifier(): UniqueIdentifier","title":"Extensions for kotlin.String"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/as-unique-identifier/","text":"com.github.manosbatsis.vaultaire.util / kotlin.String / asUniqueIdentifier asUniqueIdentifier \u00b6 fun String.asUniqueIdentifier(): UniqueIdentifier","title":"As unique identifier"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/as-unique-identifier/#asuniqueidentifier","text":"fun String.asUniqueIdentifier(): UniqueIdentifier","title":"asUniqueIdentifier"},{"location":"core/other-utils/","text":"Other Utilities \u00b6 Miscellaneous utilities provides by Vaultaire Generated Responders \u00b6 Some times you might want to use the same responding flow with multiple initiating flows. Since @InitiatedBy is not a repeatable annotation, the only option would be to subclass the same responder for each initiating flow, adding the appropriate @InitiatedBy . Vaultaire\u2019s annotation processor can help you automate this using a @VaultaireFlowResponder instead of maintaning such responders manually. Usage example: // or simply: @VaultaireFlowResponder(BaseBookFlowResponder::class) @VaultaireFlowResponder ( value = BaseBookFlowResponder :: class , comment = \"A basic responder to listen for finality\" ) @InitiatingFlow @StartableByRPC class CreateBookFlow ( input : BookMessage ) : FlowLogic < SignedTransaction > The above will automatically generate a responder flow: /** * A basic responder to listen for finality */ @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( otherPartySession : FlowSession ) : BaseBookFlowResponder ( otherPartySession ) Note : if the base responder flow is a final type, the generated responder will attempt to call it as a subflow instead of extending it: @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( val otherPartySession : FlowSession ) : FlowLogic < Unit > () { @Suspendable override fun call () { subFlow ( BaseBookFlowResponder ( otherPartySession )) } } Results Page \u00b6 The ResultsPage is a more REST-friendly alternative to Vault.Page . While it can be used to carry any type of results, it mainly focuses on mapping StateAndRef query results to either contract states or DTOs. Sample use: // Use a generated state service to query val vaultPage : Vault . Page < MyState > = stateService . queryBy ( criteria , pageSpecification , sort ) // As states val statesPage = ResultsPage . from ( vaultPage , pageSpecification , sort ) // As DTOs val dtosPage = ResultsPage . from ( vaultPage , pageSpecification , sort ) { stateAndRefs -> stateAndRefs . map { MyStateClientDto . mapToDto ( it . state . data , stateService ) } } Vaultaire JAR Attachment \u00b6 In some cases you may want to attach Vaultaire\u2019s JAR to a Corda transaction when creating a new accounts-aware state. VaultaireAttachmentService is a Corda service to do just that: // Obtain Vaultaire's JAR hash val vaultaireJarAttachment = serviceHub . cordaService ( VaultaireAttachmentService :: class . java ) . vaultaireSecureHash // Attach JAR to TX transactionBuilder . addAttachment ( vaultaireJarAttachment )","title":"Other Utilities"},{"location":"core/other-utils/#other-utilities","text":"Miscellaneous utilities provides by Vaultaire","title":"Other Utilities"},{"location":"core/other-utils/#generated-responders","text":"Some times you might want to use the same responding flow with multiple initiating flows. Since @InitiatedBy is not a repeatable annotation, the only option would be to subclass the same responder for each initiating flow, adding the appropriate @InitiatedBy . Vaultaire\u2019s annotation processor can help you automate this using a @VaultaireFlowResponder instead of maintaning such responders manually. Usage example: // or simply: @VaultaireFlowResponder(BaseBookFlowResponder::class) @VaultaireFlowResponder ( value = BaseBookFlowResponder :: class , comment = \"A basic responder to listen for finality\" ) @InitiatingFlow @StartableByRPC class CreateBookFlow ( input : BookMessage ) : FlowLogic < SignedTransaction > The above will automatically generate a responder flow: /** * A basic responder to listen for finality */ @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( otherPartySession : FlowSession ) : BaseBookFlowResponder ( otherPartySession ) Note : if the base responder flow is a final type, the generated responder will attempt to call it as a subflow instead of extending it: @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( val otherPartySession : FlowSession ) : FlowLogic < Unit > () { @Suspendable override fun call () { subFlow ( BaseBookFlowResponder ( otherPartySession )) } }","title":"Generated Responders"},{"location":"core/other-utils/#results-page","text":"The ResultsPage is a more REST-friendly alternative to Vault.Page . While it can be used to carry any type of results, it mainly focuses on mapping StateAndRef query results to either contract states or DTOs. Sample use: // Use a generated state service to query val vaultPage : Vault . Page < MyState > = stateService . queryBy ( criteria , pageSpecification , sort ) // As states val statesPage = ResultsPage . from ( vaultPage , pageSpecification , sort ) // As DTOs val dtosPage = ResultsPage . from ( vaultPage , pageSpecification , sort ) { stateAndRefs -> stateAndRefs . map { MyStateClientDto . mapToDto ( it . state . data , stateService ) } }","title":"Results Page"},{"location":"core/other-utils/#vaultaire-jar-attachment","text":"In some cases you may want to attach Vaultaire\u2019s JAR to a Corda transaction when creating a new accounts-aware state. VaultaireAttachmentService is a Corda service to do just that: // Obtain Vaultaire's JAR hash val vaultaireJarAttachment = serviceHub . cordaService ( VaultaireAttachmentService :: class . java ) . vaultaireSecureHash // Attach JAR to TX transactionBuilder . addAttachment ( vaultaireJarAttachment )","title":"Vaultaire JAR Attachment"},{"location":"core/query-dsl/","text":"Query DSL \u00b6 Vaultaire uses an annotation processor at build-time to create a query DSL for your contract/persistent states. Quick Example \u00b6 Consider the following Contract/Persistent States: /** Book ContractState */ data class BookState ( val publisher : Party , val author : Party , val title : String , val published : Date = Date () ) : ContractState , QueryableState { // ... } // Use Vaultaire's code generation! @VaultaireStateUtils ( name = \"booksQuery\" , contractStateType = BookState :: class ) @Entity @Table ( name = \"books\" ) data class PersistentBookState ( @Column ( name = \"publisher\" ) var publisher : String = \"\" , @Column ( name = \"author\" ) var author : String = \"\" , @Column ( name = \"title\" ) var title : String = \"\" , @Column ( name = \"published\" ) var published : Date ) : PersistentState () Before Vaultaire \u00b6 Before Vaultaire, you probably had to create query criteria with something like: val query = VaultQueryCriteria ( contractStateTypes = setOf ( BookState :: class . java ), status = Vault . StateStatus . ALL ) // Check publisher? if ( checkPublisher ) query = query . and ( VaultCustomQueryCriteria ( PersistentBookState :: publisher . equal ( \"Corda Books Ltd.\" ))) // Add more criteria query . and ( VaultCustomQueryCriteria ( PersistentBookState :: title . equal ( \"A book on Corda\" )) . or ( VaultCustomQueryCriteria ( PersistentBookState :: author . notEqual ( \"John Doe\" )))) val sort = Sort ( listOf ( Sort . SortColumn ( SortAttribute . Custom ( PersistentBookState :: class . java , \"published\" ), Sort . Direction . DESC ))) // Finally! queryBy ( query , sort ) A bit verbose so get\u2019s difficult to read as the query becomes more complex. Let\u2019s try to simplify things bellow. With Vaultaire DSL \u00b6 With Vaultaire\u2019s @VaultaireStateUtils and the generated DSL this becomes: // Use the generated DSL to create query criteria val query = booksQuery { status = Vault . StateStatus . ALL and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` \"Corda Books Ltd.\" or { fields . title ` == ` \"A book on Corda\" fields . author ` != ` \"John Doe\" } } orderBy { fields . title sort DESC } } queryBy ( query . toCriteria (), query . toSort ()) Create a DSL \u00b6 Project Module States \u00b6 To create a query DSL for your state after installing Vaultaire, annotate the corresponding PersistentState with @VaultaireStateUtils : // Use Vaultaire's DSL generation! @VaultaireStateUtils ( // If you omit the name, the DSL function will be named by appending \"Query\" // to the decapitalized contract state name, e.g. \"bookStateQuery\" name = \"booksQuery\" , contractStateType = BookState :: class ) @Entity @Table ( name = \"books\" ) data class PersistentBookState ( // state properties... ) : PersistentState () Project Dependency States \u00b6 To create a query DSL for a state from your project dependencies, annotate the any class in your project using the special @VaultaireStateUtilsFor annotation, providing the state\u2019s ContractState and PersistentState : @VaultaireStateUtilsMixin ( name = \"fungibleTokenConditions\" , persistentStateType = PersistentFungibleToken :: class , contractStateType = FungibleToken :: class ) class FungibleMixin Query Settings \u00b6 The generated DSL allows setting QueryCriteria.VaultQueryCriteria members. Here\u2019s an example using the defaults: val query = booksQuery { // settings status = Vault . StateStatus . UNCONSUMED stateRefs = null notary = null softLockingCondition = null timeCondition = null relevancyStatus = Vault . RelevancyStatus . ALL constraintTypes = emptySet () constraints = emptySet () participants = null // criteria and sorting... } Adding Criteria \u00b6 Query riteria are defined within the and / or functions. Both functions can be nested and mixed with criteria like: val query = booksQuery { // settings... // criteria or { // Match at least one fields . foo1 ` == ` someValue and { // Match all fields . foo1 . isNull () fields . foo2 ` == ` someOtherValue and { // ... } or { // ... } } } // sorting... } Adding Aggregates \u00b6 Aggregates can be specified within the and / or functions: val bookStateQuery = bookStateQuery { // settings... // criteria and { fields . title `like` \"%Corda Foundation%\" fields . genre ` == ` BookContract . BookGenre . SCIENCE_FICTION } // aggregates aggregate { // add some aggregates fields . externalId . count () fields . id . count () fields . editions . sum () fields . price . min () fields . price . avg () fields . price . max () } } Note : Corda paged queries can include either query results or \u201cother\u201d results based on the above aggregates. For that purpose, the toCriteria functions accepts an optional boolean to ignore aggregates, thus allowing the reuse of the same query to obtain either paged state or aggregate results. Accessing Fields \u00b6 Fields can be accessed via the generated DSL\u2019s fields object within and , or , or orderBy functions using dot notation e.g. fields.foo . You can also retrieve fields by name with e.g. fields[\"foo\"] or fields.get(\"foo\") and use non typesafe functions like _equal , _notEqual , _like , _notLike but this may change in a future release. Functions and Operators \u00b6 Name Aliases Examples isNull fields.foo.isNull() notNull fields.foo.notNull() equal `==` fields.foo `==` bar fields.foo equal bar fields.foo.equal(bar) notEqual `!=` fields.foo `!=` bar fields.foo notEqual bar fields.foo.notEqual(bar) lessThan lt fields.foo lt bar fields.foo lessThan bar fields.foo.lessThan(bar) lessThanOrEqual lte fields.foo lte bar fields.foo lessThanOrEqual bar fields.foo.lessThanOrEqual(bar) greaterThan gt fields.foo gt bar fields.foo greaterThan bar fields.foo.greaterThan(bar) greaterThanOrEqual gte fields.foo gte bar fields.foo greaterThanOrEqual bar fields.foo.greaterThanOrEqual(bar) between btw fields.foo btw Pair(bar1, bar2) fields.foo between Pair(bar1, bar2) fields.foo.between(bar1, bar2) like fields.foo like bar fields.foo.like(bar) notLike fields.foo notLike bar fields.foo.notLike(bar) isIn `in` fields.foo `in` bars fields.foo isIn bars fields.foo.isIn(bars) notIn `!in` fields.foo `!in` bars fields.foo notIn bars fields.foo.notIn(bars) Aggregate Functions \u00b6 Name Examples avg fields.foo.avg() fields.foo.avg(groupByColumns) fields.foo.avg(groupByColumns, sortDirection) count fields.foo.count() max fields.foo.max() fields.foo.max(groupByColumns) fields.foo.max(groupByColumns, sortDirection) min fields.foo.min() fields.foo.min(groupByColumns) fields.foo.min(groupByColumns, sortDirection) sum fields.foo.sum() fields.foo.sum(groupByColumns) fields.foo.sum(groupByColumns, sortDirection) Sorting \u00b6 Sorting is defined using the orderBy function. Both custom fields and standard attributes are supported, while aliases for standard attributes are provided for convenience: val criteria = bookConditions { // settings and criteria... // sorting orderBy { // Sort by standard attribute alias, same as // Sort.VaultStateAttribute.RECORDED_TIME sort ASC recordedTime sort ASC // Sort by custom field fields . title sort DESC } } The following standard attribute aliases are provided: Alias Standard Attribute stateRef Sort.CommonStateAttribute.STATE_REF stateRefTxnId Sort.CommonStateAttribute.STATE_REF_TXN_ID stateRefIndex Sort.CommonStateAttribute.STATE_REF_INDEX notaryName Sort.VaultStateAttribute.NOTARY_NAME contractStateType Sort.VaultStateAttribute.CONTRACT_STATE_TYPE stateStatus Sort.VaultStateAttribute.STATE_STATUS recordedTime Sort.VaultStateAttribute.RECORDED_TIME consumedTime Sort.VaultStateAttribute.CONSUMED_TIME lockId Sort.VaultStateAttribute.LOCK_ID constraintType Sort.VaultStateAttribute.CONSTRAINT_TYPE uuid Sort.LinearStateAttribute.UUID externalId Sort.LinearStateAttribute.EXTERNAL_ID quantity Sort.FungibleStateAttribute.QUANTITY issuerRef Sort.FungibleStateAttribute.ISSUER_REF","title":"Query DSL"},{"location":"core/query-dsl/#query-dsl","text":"Vaultaire uses an annotation processor at build-time to create a query DSL for your contract/persistent states.","title":"Query DSL"},{"location":"core/query-dsl/#quick-example","text":"Consider the following Contract/Persistent States: /** Book ContractState */ data class BookState ( val publisher : Party , val author : Party , val title : String , val published : Date = Date () ) : ContractState , QueryableState { // ... } // Use Vaultaire's code generation! @VaultaireStateUtils ( name = \"booksQuery\" , contractStateType = BookState :: class ) @Entity @Table ( name = \"books\" ) data class PersistentBookState ( @Column ( name = \"publisher\" ) var publisher : String = \"\" , @Column ( name = \"author\" ) var author : String = \"\" , @Column ( name = \"title\" ) var title : String = \"\" , @Column ( name = \"published\" ) var published : Date ) : PersistentState ()","title":"Quick Example"},{"location":"core/query-dsl/#before-vaultaire","text":"Before Vaultaire, you probably had to create query criteria with something like: val query = VaultQueryCriteria ( contractStateTypes = setOf ( BookState :: class . java ), status = Vault . StateStatus . ALL ) // Check publisher? if ( checkPublisher ) query = query . and ( VaultCustomQueryCriteria ( PersistentBookState :: publisher . equal ( \"Corda Books Ltd.\" ))) // Add more criteria query . and ( VaultCustomQueryCriteria ( PersistentBookState :: title . equal ( \"A book on Corda\" )) . or ( VaultCustomQueryCriteria ( PersistentBookState :: author . notEqual ( \"John Doe\" )))) val sort = Sort ( listOf ( Sort . SortColumn ( SortAttribute . Custom ( PersistentBookState :: class . java , \"published\" ), Sort . Direction . DESC ))) // Finally! queryBy ( query , sort ) A bit verbose so get\u2019s difficult to read as the query becomes more complex. Let\u2019s try to simplify things bellow.","title":"Before Vaultaire"},{"location":"core/query-dsl/#with-vaultaire-dsl","text":"With Vaultaire\u2019s @VaultaireStateUtils and the generated DSL this becomes: // Use the generated DSL to create query criteria val query = booksQuery { status = Vault . StateStatus . ALL and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` \"Corda Books Ltd.\" or { fields . title ` == ` \"A book on Corda\" fields . author ` != ` \"John Doe\" } } orderBy { fields . title sort DESC } } queryBy ( query . toCriteria (), query . toSort ())","title":"With Vaultaire DSL"},{"location":"core/query-dsl/#create-a-dsl","text":"","title":"Create a DSL"},{"location":"core/query-dsl/#project-module-states","text":"To create a query DSL for your state after installing Vaultaire, annotate the corresponding PersistentState with @VaultaireStateUtils : // Use Vaultaire's DSL generation! @VaultaireStateUtils ( // If you omit the name, the DSL function will be named by appending \"Query\" // to the decapitalized contract state name, e.g. \"bookStateQuery\" name = \"booksQuery\" , contractStateType = BookState :: class ) @Entity @Table ( name = \"books\" ) data class PersistentBookState ( // state properties... ) : PersistentState ()","title":"Project Module States"},{"location":"core/query-dsl/#project-dependency-states","text":"To create a query DSL for a state from your project dependencies, annotate the any class in your project using the special @VaultaireStateUtilsFor annotation, providing the state\u2019s ContractState and PersistentState : @VaultaireStateUtilsMixin ( name = \"fungibleTokenConditions\" , persistentStateType = PersistentFungibleToken :: class , contractStateType = FungibleToken :: class ) class FungibleMixin","title":"Project Dependency States"},{"location":"core/query-dsl/#query-settings","text":"The generated DSL allows setting QueryCriteria.VaultQueryCriteria members. Here\u2019s an example using the defaults: val query = booksQuery { // settings status = Vault . StateStatus . UNCONSUMED stateRefs = null notary = null softLockingCondition = null timeCondition = null relevancyStatus = Vault . RelevancyStatus . ALL constraintTypes = emptySet () constraints = emptySet () participants = null // criteria and sorting... }","title":"Query Settings"},{"location":"core/query-dsl/#adding-criteria","text":"Query riteria are defined within the and / or functions. Both functions can be nested and mixed with criteria like: val query = booksQuery { // settings... // criteria or { // Match at least one fields . foo1 ` == ` someValue and { // Match all fields . foo1 . isNull () fields . foo2 ` == ` someOtherValue and { // ... } or { // ... } } } // sorting... }","title":"Adding Criteria"},{"location":"core/query-dsl/#adding-aggregates","text":"Aggregates can be specified within the and / or functions: val bookStateQuery = bookStateQuery { // settings... // criteria and { fields . title `like` \"%Corda Foundation%\" fields . genre ` == ` BookContract . BookGenre . SCIENCE_FICTION } // aggregates aggregate { // add some aggregates fields . externalId . count () fields . id . count () fields . editions . sum () fields . price . min () fields . price . avg () fields . price . max () } } Note : Corda paged queries can include either query results or \u201cother\u201d results based on the above aggregates. For that purpose, the toCriteria functions accepts an optional boolean to ignore aggregates, thus allowing the reuse of the same query to obtain either paged state or aggregate results.","title":"Adding Aggregates"},{"location":"core/query-dsl/#accessing-fields","text":"Fields can be accessed via the generated DSL\u2019s fields object within and , or , or orderBy functions using dot notation e.g. fields.foo . You can also retrieve fields by name with e.g. fields[\"foo\"] or fields.get(\"foo\") and use non typesafe functions like _equal , _notEqual , _like , _notLike but this may change in a future release.","title":"Accessing Fields"},{"location":"core/query-dsl/#functions-and-operators","text":"Name Aliases Examples isNull fields.foo.isNull() notNull fields.foo.notNull() equal `==` fields.foo `==` bar fields.foo equal bar fields.foo.equal(bar) notEqual `!=` fields.foo `!=` bar fields.foo notEqual bar fields.foo.notEqual(bar) lessThan lt fields.foo lt bar fields.foo lessThan bar fields.foo.lessThan(bar) lessThanOrEqual lte fields.foo lte bar fields.foo lessThanOrEqual bar fields.foo.lessThanOrEqual(bar) greaterThan gt fields.foo gt bar fields.foo greaterThan bar fields.foo.greaterThan(bar) greaterThanOrEqual gte fields.foo gte bar fields.foo greaterThanOrEqual bar fields.foo.greaterThanOrEqual(bar) between btw fields.foo btw Pair(bar1, bar2) fields.foo between Pair(bar1, bar2) fields.foo.between(bar1, bar2) like fields.foo like bar fields.foo.like(bar) notLike fields.foo notLike bar fields.foo.notLike(bar) isIn `in` fields.foo `in` bars fields.foo isIn bars fields.foo.isIn(bars) notIn `!in` fields.foo `!in` bars fields.foo notIn bars fields.foo.notIn(bars)","title":"Functions and Operators"},{"location":"core/query-dsl/#aggregate-functions","text":"Name Examples avg fields.foo.avg() fields.foo.avg(groupByColumns) fields.foo.avg(groupByColumns, sortDirection) count fields.foo.count() max fields.foo.max() fields.foo.max(groupByColumns) fields.foo.max(groupByColumns, sortDirection) min fields.foo.min() fields.foo.min(groupByColumns) fields.foo.min(groupByColumns, sortDirection) sum fields.foo.sum() fields.foo.sum(groupByColumns) fields.foo.sum(groupByColumns, sortDirection)","title":"Aggregate Functions"},{"location":"core/query-dsl/#sorting","text":"Sorting is defined using the orderBy function. Both custom fields and standard attributes are supported, while aliases for standard attributes are provided for convenience: val criteria = bookConditions { // settings and criteria... // sorting orderBy { // Sort by standard attribute alias, same as // Sort.VaultStateAttribute.RECORDED_TIME sort ASC recordedTime sort ASC // Sort by custom field fields . title sort DESC } } The following standard attribute aliases are provided: Alias Standard Attribute stateRef Sort.CommonStateAttribute.STATE_REF stateRefTxnId Sort.CommonStateAttribute.STATE_REF_TXN_ID stateRefIndex Sort.CommonStateAttribute.STATE_REF_INDEX notaryName Sort.VaultStateAttribute.NOTARY_NAME contractStateType Sort.VaultStateAttribute.CONTRACT_STATE_TYPE stateStatus Sort.VaultStateAttribute.STATE_STATUS recordedTime Sort.VaultStateAttribute.RECORDED_TIME consumedTime Sort.VaultStateAttribute.CONSUMED_TIME lockId Sort.VaultStateAttribute.LOCK_ID constraintType Sort.VaultStateAttribute.CONSTRAINT_TYPE uuid Sort.LinearStateAttribute.UUID externalId Sort.LinearStateAttribute.EXTERNAL_ID quantity Sort.FungibleStateAttribute.QUANTITY issuerRef Sort.FungibleStateAttribute.ISSUER_REF","title":"Sorting"},{"location":"core/state-dtos/","text":"State DTOs \u00b6 Overview \u00b6 Maintaining Data Transfer Objects for your contract states can be a mundane, error-prone task. Vaultaire\u2019s annotation processing automates this by (re)generating those DTOs for you. Usage Patterns \u00b6 A typical use for generated DTOs is messaging over HTTP REST or RPC as input and output of Corda Flows. The provided conversion utilities can be used to create, update or even patch ContractState types they correspond to. DTO to State \u00b6 To convert from DTO to state, use the DTO\u2019s toTargetType() method: // Using default strategy // ---------------------- // Get the DTO val dto1 : BookStateClientDto = //... // Convert to State val state1 : BookState = dto1 . toTargetType () // Using the default strategy // ---------------------- // Get the Service val stateService : BookStateService = //... // Get the 'client' DTO val dto2 : BookStateClientDto = // ... // Convert to State val state2 : BookState = dto2 . toTargetType ( stateService ) DTO as Patch Update \u00b6 DTOs can be used to transfer and apply a \u201cpatch\u201d to update an existing state: // Get the Service val stateService = BookStateService ( serviceHub_or_RPCOps ) // Load state from Node Vault val state : BookState = stateService . getByLinearId ( id ) // Apply DTO as patch // ---------------------- val patchedState1 : BookState = dto1 . toPatched ( state ) // Apply 'client' DTO as patch // ---------------------- val patchedState2 : BookState = dto2 . toPatched ( state , stateService ) State to DTO \u00b6 To convert from state to DTO, use the DTO\u2019s latter\u2019s alternative, state-based constructor: // Get the state val state : BookState = stateService . getByLinearId ( id ) // Convert to DTO val dto = BookStateClientDto . mapToDto ( state ) DTO Generation \u00b6 This section explains the annotations and strategies involved in generating DTOs. Annotations \u00b6 Local States \u00b6 To have Vaultaire generate DTOs for ContractState s within local (Gradle module) sources, annotate them with @VaultaireStateDto : @VaultaireStateDto ( // optional: properties to ignore ignoreProperties = [ \"foo\" ] , // optional, default is false includeParticipants = false ) data class BookState ( val publisher : Party , val author : Party , val price : BigDecimal , val genre : Genre , @DefaultValue ( \"1\" ) val editions : Int = 1 , val foo : String = \"foo1\" , val title : String = \"Uknown\" , val published : Date = Date (), @field : JsonProperty ( \"alias\" ) val alternativeTitle : String? = null , override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { /* ... */ } Dependency States \u00b6 To generate DTOs for ContractState s outside the sources in context, e.g. from a contract states module or a project dependency, create a \u201cmixin\u201d class as a placeholder and annotate it with @VaultaireStateDtoMixin . This approach might be preferred or necessary even for state sources in context or under your control, e.g. when having (the good practice of) separate cordapp modules for contracts/states and flows. Mixin example: @VaultaireStateDtoMixin ( persistentStateType = PersistentBookState :: class , contractStateType = BookState :: class , // optional: properties to ignore ignoreProperties = [ \"foo\" ] ) class BookStateMixin // just a placeholder for our annotation Non-State Models \u00b6 @VaultaireModelDto and @VaultaireModelDtoMixin can be used for generation of DTOs for regular, non-ContractState data classes. to similarly generate REST-friendly DTOs and conversion utils focused op Corda-related types like accounts etc. @VaultaireModelDtoMixin ( baseType = SomeModel :: class ) data class SomeModelMixin Views \u00b6 Some times using DTOs with a subset of the original state or model\u2019s members is desired. Vaultaire allows automating generation for those DTOs as well using the views property of the annotation in context. For example, to generate a view of SomeModel that only includes title and description : @VaultaireModelDtoMixin ( baseType = SomeModel :: class , views = [ VaultaireView ( name = \"UpdateTitleAndDesc\" , namedFields = [ \"title\" , \"description\" ] ) ] ) data class SomeModelMixin The views property is supported by @VaultaireStateDto , @VaultaireStateDtoMixin , @VaultaireModelDto and @VaultaireModelDtoMixin . Utility Annotations \u00b6 The @DefaultValue can be used to provide default property initializers. It can be used equally on either ContractState or \u201cmixin\u201d properties: @VaultaireStateUtilsMixin ( /*...*/ ) @VaultaireStateDtoMixin ( /*...*/ ) data class MagazineMixin ( @DefaultValue ( \"1\" ) var issues : Int , @DefaultValue ( \"Date()\" ) val published : Date , @DefaultValue ( \"UniqueIdentifier()\" ) val linearId : UniqueIdentifier ) Sample DTO \u00b6 Sample (state) client DTO: nullable var members and utilities to convert from/to or patch an instance of the target type: /** * A [MagazineContract.MagazineState]-specific * [com.github.manosbatsis.vaultaire.dto.VaultaireStateClientDto] implementation */ @CordaSerializable data class MagazineStateClientDto ( var publisher : AccountInfoStateClientDto? = null , var author : AccountInfoStateClientDto? = null , var price : BigDecimal? = null , var genre : MagazineContract . MagazineGenre ? = null , var issues : Int? = 1 , var title : String? = null , var published : Date? = Date (), var linearId : UniqueIdentifier? = UniqueIdentifier (), var customMixinField : Map < String , String >? = null ) : VaultaireAccountsAwareStateClientDto < MagazineContract . MagazineState > { /** * Create a patched copy of the given [MagazineContract.MagazineState] instance, * updated using this DTO's non-null properties. */ @Suspendable override fun toPatched ( original : MagazineContract . MagazineState , stateService : AccountsAwareStateService < MagazineContract . MagazineState > ): MagazineContract . MagazineState { val publisherResolved = stateService . toAccountPartyOrNull ( this . publisher , original . publisher ) val authorResolved = stateService . toAccountParty ( this . author , original . author ) val patched = original . copy ( publisher = publisherResolved , author = authorResolved , price = this . price ?: original . price , genre = this . genre ?: original . genre , issues = this . issues ?: original . issues , title = this . title ?: original . title , published = this . published ?: original . published , linearId = this . linearId ?: original . linearId ) return patched } /** * Create an instance of [MagazineContract.MagazineState], using this DTO's properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ @Suspendable override fun toTargetType ( stateService : AccountsAwareStateService < MagazineContract . MagazineState > ): MagazineContract . MagazineState { val publisherResolved = stateService . toAccountPartyOrNull ( this . publisher , null , false , \"publisher\" ) val authorResolved = stateService . toAccountParty ( this . author , null , false , \"author\" ) return MagazineContract . MagazineState ( publisher = publisherResolved , author = authorResolved , price = this . price ?: errNull ( \"price\" ), genre = this . genre ?: errNull ( \"genre\" ), issues = this . issues ?: errNull ( \"issues\" ), title = this . title ?: errNull ( \"title\" ), published = this . published ?: errNull ( \"published\" ), linearId = this . linearId ?: errNull ( \"linearId\" ) ) } companion object { /** * Create a new DTO instance using the given [MagazineContract.MagazineState] as source. */ @Suspendable fun mapToDto ( original : MagazineContract . MagazineState , stateService : AccountsAwareStateService < MagazineContract . MagazineState > ): MagazineStateClientDto { val publisherResolved = stateService . toAccountInfoClientDtoOrNull ( original . publisher ) val authorResolved = stateService . toAccountInfoClientDto ( original . author ) return MagazineStateClientDto ( publisher = publisherResolved , author = authorResolved , price = original . price , genre = original . genre , issues = original . issues , title = original . title , published = original . published , linearId = original . linearId ) } } } Strategies \u00b6 Both @VaultaireStateDto and @VaultaireStateDtoMixin support generation strategy hints. By default the strategy used is the REST-friendly VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO . The only additional strategy provided is VaultaireDtoStrategyKeys.CORDAPP_LOCAL_DTO that supports no type conversions. Using both, as in the following example, will generate separate DTOs for each. @VaultaireStateDto ( ignoreProperties = [ \"foo\" ] , strategies = [ VaultaireDtoStrategyKeys . CORDAPP_CLIENT_DTO , VaultaireDtoStrategyKeys . CORDAPP_LOCAL_DTO ] ) data class BookState ( //... ) : LinearState , QueryableState { //... }","title":"State DTOs"},{"location":"core/state-dtos/#state-dtos","text":"","title":"State DTOs"},{"location":"core/state-dtos/#overview","text":"Maintaining Data Transfer Objects for your contract states can be a mundane, error-prone task. Vaultaire\u2019s annotation processing automates this by (re)generating those DTOs for you.","title":"Overview"},{"location":"core/state-dtos/#usage-patterns","text":"A typical use for generated DTOs is messaging over HTTP REST or RPC as input and output of Corda Flows. The provided conversion utilities can be used to create, update or even patch ContractState types they correspond to.","title":"Usage Patterns"},{"location":"core/state-dtos/#dto-to-state","text":"To convert from DTO to state, use the DTO\u2019s toTargetType() method: // Using default strategy // ---------------------- // Get the DTO val dto1 : BookStateClientDto = //... // Convert to State val state1 : BookState = dto1 . toTargetType () // Using the default strategy // ---------------------- // Get the Service val stateService : BookStateService = //... // Get the 'client' DTO val dto2 : BookStateClientDto = // ... // Convert to State val state2 : BookState = dto2 . toTargetType ( stateService )","title":"DTO to State"},{"location":"core/state-dtos/#dto-as-patch-update","text":"DTOs can be used to transfer and apply a \u201cpatch\u201d to update an existing state: // Get the Service val stateService = BookStateService ( serviceHub_or_RPCOps ) // Load state from Node Vault val state : BookState = stateService . getByLinearId ( id ) // Apply DTO as patch // ---------------------- val patchedState1 : BookState = dto1 . toPatched ( state ) // Apply 'client' DTO as patch // ---------------------- val patchedState2 : BookState = dto2 . toPatched ( state , stateService )","title":"DTO as Patch Update"},{"location":"core/state-dtos/#state-to-dto","text":"To convert from state to DTO, use the DTO\u2019s latter\u2019s alternative, state-based constructor: // Get the state val state : BookState = stateService . getByLinearId ( id ) // Convert to DTO val dto = BookStateClientDto . mapToDto ( state )","title":"State to DTO"},{"location":"core/state-dtos/#dto-generation","text":"This section explains the annotations and strategies involved in generating DTOs.","title":"DTO Generation"},{"location":"core/state-dtos/#annotations","text":"","title":"Annotations"},{"location":"core/state-dtos/#local-states","text":"To have Vaultaire generate DTOs for ContractState s within local (Gradle module) sources, annotate them with @VaultaireStateDto : @VaultaireStateDto ( // optional: properties to ignore ignoreProperties = [ \"foo\" ] , // optional, default is false includeParticipants = false ) data class BookState ( val publisher : Party , val author : Party , val price : BigDecimal , val genre : Genre , @DefaultValue ( \"1\" ) val editions : Int = 1 , val foo : String = \"foo1\" , val title : String = \"Uknown\" , val published : Date = Date (), @field : JsonProperty ( \"alias\" ) val alternativeTitle : String? = null , override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { /* ... */ }","title":"Local States"},{"location":"core/state-dtos/#dependency-states","text":"To generate DTOs for ContractState s outside the sources in context, e.g. from a contract states module or a project dependency, create a \u201cmixin\u201d class as a placeholder and annotate it with @VaultaireStateDtoMixin . This approach might be preferred or necessary even for state sources in context or under your control, e.g. when having (the good practice of) separate cordapp modules for contracts/states and flows. Mixin example: @VaultaireStateDtoMixin ( persistentStateType = PersistentBookState :: class , contractStateType = BookState :: class , // optional: properties to ignore ignoreProperties = [ \"foo\" ] ) class BookStateMixin // just a placeholder for our annotation","title":"Dependency States"},{"location":"core/state-dtos/#non-state-models","text":"@VaultaireModelDto and @VaultaireModelDtoMixin can be used for generation of DTOs for regular, non-ContractState data classes. to similarly generate REST-friendly DTOs and conversion utils focused op Corda-related types like accounts etc. @VaultaireModelDtoMixin ( baseType = SomeModel :: class ) data class SomeModelMixin","title":"Non-State Models"},{"location":"core/state-dtos/#views","text":"Some times using DTOs with a subset of the original state or model\u2019s members is desired. Vaultaire allows automating generation for those DTOs as well using the views property of the annotation in context. For example, to generate a view of SomeModel that only includes title and description : @VaultaireModelDtoMixin ( baseType = SomeModel :: class , views = [ VaultaireView ( name = \"UpdateTitleAndDesc\" , namedFields = [ \"title\" , \"description\" ] ) ] ) data class SomeModelMixin The views property is supported by @VaultaireStateDto , @VaultaireStateDtoMixin , @VaultaireModelDto and @VaultaireModelDtoMixin .","title":"Views"},{"location":"core/state-dtos/#utility-annotations","text":"The @DefaultValue can be used to provide default property initializers. It can be used equally on either ContractState or \u201cmixin\u201d properties: @VaultaireStateUtilsMixin ( /*...*/ ) @VaultaireStateDtoMixin ( /*...*/ ) data class MagazineMixin ( @DefaultValue ( \"1\" ) var issues : Int , @DefaultValue ( \"Date()\" ) val published : Date , @DefaultValue ( \"UniqueIdentifier()\" ) val linearId : UniqueIdentifier )","title":"Utility Annotations"},{"location":"core/state-dtos/#sample-dto","text":"Sample (state) client DTO: nullable var members and utilities to convert from/to or patch an instance of the target type: /** * A [MagazineContract.MagazineState]-specific * [com.github.manosbatsis.vaultaire.dto.VaultaireStateClientDto] implementation */ @CordaSerializable data class MagazineStateClientDto ( var publisher : AccountInfoStateClientDto? = null , var author : AccountInfoStateClientDto? = null , var price : BigDecimal? = null , var genre : MagazineContract . MagazineGenre ? = null , var issues : Int? = 1 , var title : String? = null , var published : Date? = Date (), var linearId : UniqueIdentifier? = UniqueIdentifier (), var customMixinField : Map < String , String >? = null ) : VaultaireAccountsAwareStateClientDto < MagazineContract . MagazineState > { /** * Create a patched copy of the given [MagazineContract.MagazineState] instance, * updated using this DTO's non-null properties. */ @Suspendable override fun toPatched ( original : MagazineContract . MagazineState , stateService : AccountsAwareStateService < MagazineContract . MagazineState > ): MagazineContract . MagazineState { val publisherResolved = stateService . toAccountPartyOrNull ( this . publisher , original . publisher ) val authorResolved = stateService . toAccountParty ( this . author , original . author ) val patched = original . copy ( publisher = publisherResolved , author = authorResolved , price = this . price ?: original . price , genre = this . genre ?: original . genre , issues = this . issues ?: original . issues , title = this . title ?: original . title , published = this . published ?: original . published , linearId = this . linearId ?: original . linearId ) return patched } /** * Create an instance of [MagazineContract.MagazineState], using this DTO's properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ @Suspendable override fun toTargetType ( stateService : AccountsAwareStateService < MagazineContract . MagazineState > ): MagazineContract . MagazineState { val publisherResolved = stateService . toAccountPartyOrNull ( this . publisher , null , false , \"publisher\" ) val authorResolved = stateService . toAccountParty ( this . author , null , false , \"author\" ) return MagazineContract . MagazineState ( publisher = publisherResolved , author = authorResolved , price = this . price ?: errNull ( \"price\" ), genre = this . genre ?: errNull ( \"genre\" ), issues = this . issues ?: errNull ( \"issues\" ), title = this . title ?: errNull ( \"title\" ), published = this . published ?: errNull ( \"published\" ), linearId = this . linearId ?: errNull ( \"linearId\" ) ) } companion object { /** * Create a new DTO instance using the given [MagazineContract.MagazineState] as source. */ @Suspendable fun mapToDto ( original : MagazineContract . MagazineState , stateService : AccountsAwareStateService < MagazineContract . MagazineState > ): MagazineStateClientDto { val publisherResolved = stateService . toAccountInfoClientDtoOrNull ( original . publisher ) val authorResolved = stateService . toAccountInfoClientDto ( original . author ) return MagazineStateClientDto ( publisher = publisherResolved , author = authorResolved , price = original . price , genre = original . genre , issues = original . issues , title = original . title , published = original . published , linearId = original . linearId ) } } }","title":"Sample DTO"},{"location":"core/state-dtos/#strategies","text":"Both @VaultaireStateDto and @VaultaireStateDtoMixin support generation strategy hints. By default the strategy used is the REST-friendly VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO . The only additional strategy provided is VaultaireDtoStrategyKeys.CORDAPP_LOCAL_DTO that supports no type conversions. Using both, as in the following example, will generate separate DTOs for each. @VaultaireStateDto ( ignoreProperties = [ \"foo\" ] , strategies = [ VaultaireDtoStrategyKeys . CORDAPP_CLIENT_DTO , VaultaireDtoStrategyKeys . CORDAPP_LOCAL_DTO ] ) data class BookState ( //... ) : LinearState , QueryableState { //... }","title":"Strategies"},{"location":"core/state-services/","text":"State Services \u00b6 Overview \u00b6 Vaultaire\u2019s StateService s provide a simple, consistent API to load, query and track vault states. StateService implementations are usually auto-generated at build time based on VaultaireStateUtils or VaultaireStateUtilsMixin annotations, i.e. specific to a single ContractState type. State Services can also decouple you code from ServiceHub and CordaRPCOps by providing constructors for either, thus helping increase code reuse between cordapps and their clients. They also support RPC connection pooling, i.e. provide a constructor that accepts a PoolBoy PoolBoyConnection . Basic Services \u00b6 Basic implementations of NodeService and StateService are more limited and/or less easy to use than generated ones but functional nevertheless: val bookStateService = BasicStateService ( serviceHubOrRpcOpsOrPoolBoy , BookContract . BookState :: class . java ) State Services \u00b6 Vaultaire\u2019s annotation processor will generate optimal StateService implementations, each specific to one of the ContractState - PersistentState pairs found at build-time based on the VaultaireStateUtils or VaultaireStateUtilsMixin annotations found in your code. Service classnames are based on the contract state classname, suffixed by \u201cService\u201d. Usage example: // Create an instance of the generated service type, // passing a ServiceHub, CordaRPCOps, NodeRpcConnection // or even a custom StateServiceDelegate val bookStateService = BookStateService ( serviceHub ) // Load a book bookStateService . getByLinearId ( identifier ) // Try finding one by UniqueIdentifier.externalId, // in this case an ISBN bookStateService . findByExternalId ( isbn ) // Count the book states that match our query criteria val booksCount = bookStateService . countBy ( queryCriteria ) // Query the vault for a results page of the same books val searchResultsPage : Vault . Page < BookState > = bookStateService . queryBy ( queryCriteria , // Optional PageSpecification or page number/size params page , // Optional Sort or vararg of Pair<String, Sort.Direction> sort ) // Track the vault for book events val trackResults = bookStateService . queryBy ( criteria ) Custom Services \u00b6 You can also subclass (or, perhaps preferably, use as delegates) generated service types or BasicNodeService , BasicStateService , ExtendedStateService etc. to create custom components. /** Extend the generated [BookStateService] */ class MyExtendedBookStateService ( delegate : StateServiceDelegate < BookState > ) : BookStateService ( delegate ){ // Add the appropriate constructors // to initialize per delegate type: /** [CordaRPCOps]-based constructor */ constructor ( rpcOps : CordaRPCOps , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceRpcDelegate ( rpcOps , BookState :: class . java , defaults )) /** [ServiceHub]-based constructor */ constructor ( serviceHub : ServiceHub , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceHubDelegate ( serviceHub , BookState :: class . java , defaults )) // Custom business methods... }","title":"State Services"},{"location":"core/state-services/#state-services","text":"","title":"State Services"},{"location":"core/state-services/#overview","text":"Vaultaire\u2019s StateService s provide a simple, consistent API to load, query and track vault states. StateService implementations are usually auto-generated at build time based on VaultaireStateUtils or VaultaireStateUtilsMixin annotations, i.e. specific to a single ContractState type. State Services can also decouple you code from ServiceHub and CordaRPCOps by providing constructors for either, thus helping increase code reuse between cordapps and their clients. They also support RPC connection pooling, i.e. provide a constructor that accepts a PoolBoy PoolBoyConnection .","title":"Overview"},{"location":"core/state-services/#basic-services","text":"Basic implementations of NodeService and StateService are more limited and/or less easy to use than generated ones but functional nevertheless: val bookStateService = BasicStateService ( serviceHubOrRpcOpsOrPoolBoy , BookContract . BookState :: class . java )","title":"Basic Services"},{"location":"core/state-services/#state-services_1","text":"Vaultaire\u2019s annotation processor will generate optimal StateService implementations, each specific to one of the ContractState - PersistentState pairs found at build-time based on the VaultaireStateUtils or VaultaireStateUtilsMixin annotations found in your code. Service classnames are based on the contract state classname, suffixed by \u201cService\u201d. Usage example: // Create an instance of the generated service type, // passing a ServiceHub, CordaRPCOps, NodeRpcConnection // or even a custom StateServiceDelegate val bookStateService = BookStateService ( serviceHub ) // Load a book bookStateService . getByLinearId ( identifier ) // Try finding one by UniqueIdentifier.externalId, // in this case an ISBN bookStateService . findByExternalId ( isbn ) // Count the book states that match our query criteria val booksCount = bookStateService . countBy ( queryCriteria ) // Query the vault for a results page of the same books val searchResultsPage : Vault . Page < BookState > = bookStateService . queryBy ( queryCriteria , // Optional PageSpecification or page number/size params page , // Optional Sort or vararg of Pair<String, Sort.Direction> sort ) // Track the vault for book events val trackResults = bookStateService . queryBy ( criteria )","title":"State Services"},{"location":"core/state-services/#custom-services","text":"You can also subclass (or, perhaps preferably, use as delegates) generated service types or BasicNodeService , BasicStateService , ExtendedStateService etc. to create custom components. /** Extend the generated [BookStateService] */ class MyExtendedBookStateService ( delegate : StateServiceDelegate < BookState > ) : BookStateService ( delegate ){ // Add the appropriate constructors // to initialize per delegate type: /** [CordaRPCOps]-based constructor */ constructor ( rpcOps : CordaRPCOps , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceRpcDelegate ( rpcOps , BookState :: class . java , defaults )) /** [ServiceHub]-based constructor */ constructor ( serviceHub : ServiceHub , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceHubDelegate ( serviceHub , BookState :: class . java , defaults )) // Custom business methods... }","title":"Custom Services"},{"location":"plugins/corda-accounts/","text":"Corda Accounts Plugin \u00b6 This plugin provides support for Corda Accounts to Vaultaire\u2019s runtime and build-time modules. Installation \u00b6 Add Vaultaire\u2019s plugin for Corda Accounts to your Cordapp\u2019s Gradle dependencies using compile, cordapp or cordaCompile to match the core Vaultaire dependency. cordaCompile \"com.github.manosbatsis.vaultaire:vaultaire-plugin-accounts:$vaultaire_version\" Depending on the above dependency type, you may also need to add the plugin to your client app and deployNodes dependency configuration. The plugin adds both new and enhanced versions of core component types. It also overrides Vaultaire\u2019s internal configuration options to effectively apply them. These include the default base types extended by components generated by the annotation processor. DTO Enhancements \u00b6 VaultaireAccountInfo Annotation \u00b6 The plugin introduces the VaultaireAccountInfo annotation as the means to mark participant or other properties of a ContractState that map to a Corda Account. Supported types include: AbstractParty AnonymousParty PublicKey AccountParty Using the annotation for the last one is optional. Accounts-Aware DTO Types \u00b6 The plugin also adds: AccountInfoStateDto as a convenient model that maps from app-level users or state properties (as supported by @VaultaireAccountInfo above) to Corda Accounts, i.e. AccountInfo states. AccountsAwareStateClientDto as the equivalent of REST/client-friendly equivalent,. All the above effectively provide the \u201clite\u201d DTO strategy with enhanced DTO<->state conversion and patching utilities, i.e. mainly with support for mapping between the applicable types (see @VaultaireAccountInfo ) and AccountInfoDto . As an example, consider the following state: data class MagazineState ( val publisher : AccountParty , @VaultaireAccountInfo val author : PublicKey , @VaultaireAccountInfo val editor : AbstractParty , //... override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { override val participants get () = listOf ( publisher . party , AbstractParty ( author ), editor ) //... } The generated client DTO for the above: data class MagazineStateClientDto ( var publisher : AccountInfoStateClientDto? = null , var author : AccountInfoStateClientDto? = null , var editor : AccountInfoStateClientDto? = null , //... var linearId : UniqueIdentifier? = null ) : AccountsAwareStateClientDto < BookContract . MagazineState > { //... } Query DSL Enhancements \u00b6 Corda 4.3 added the possibility to map any public key to an external id of type UUID. Corda Accounts uses this feature to map an account\u2019s key to the account\u2019s id. Thus, using externalIds creates query criteria aware of state participants, without the need to embed account identifiers within the state itself. This is now supported by the generated Query DSL for your contract state: val magazineStateQuery = magazineStateQuery { // Match participants using the following // AccountInfo identifiers externalIds = listOfNotNull ( publisher . identifier ) status = Vault . StateStatus . UNCONSUMED // the default // The rest of the query.. //... Service Enhancements \u00b6 The plugin also adds and applies various accounts-aware service types as replacements of their default equivalents, along with a number of utility methods around accounts. // Create an instance of the generated service type, // passing a ServiceHub, CordaRPCOps, NodeRpcConnection // or even a custom StateServiceDelegate val stateService = AccountInfoService ( serviceHub ) // Get the account that is already stored locally // and matching the given [id] if found, null otherwise val accountOrNull : AccountInfo? = stateService . findStoredAccount ( accountId ) ?: stateService . requestAccount ( accountId , accountHost ) // Get the account that is already stored locally // and matching the given [id] if found, null otherwise val account : AccountInfo = stateService . getStoredAccount ( accountId ) // Find accounts that are already stored locally // and match the given [criteria] val accountsPage : Vault . Page < AccountInfo > = stateService . findStoredAccounts ( queryCriteria ) // Create a public key for the given [accountInfo] */ val anonymousParty = stateService . createPublicKey ( accountInfo )","title":"Corda Accounts"},{"location":"plugins/corda-accounts/#corda-accounts-plugin","text":"This plugin provides support for Corda Accounts to Vaultaire\u2019s runtime and build-time modules.","title":"Corda Accounts Plugin"},{"location":"plugins/corda-accounts/#installation","text":"Add Vaultaire\u2019s plugin for Corda Accounts to your Cordapp\u2019s Gradle dependencies using compile, cordapp or cordaCompile to match the core Vaultaire dependency. cordaCompile \"com.github.manosbatsis.vaultaire:vaultaire-plugin-accounts:$vaultaire_version\" Depending on the above dependency type, you may also need to add the plugin to your client app and deployNodes dependency configuration. The plugin adds both new and enhanced versions of core component types. It also overrides Vaultaire\u2019s internal configuration options to effectively apply them. These include the default base types extended by components generated by the annotation processor.","title":"Installation"},{"location":"plugins/corda-accounts/#dto-enhancements","text":"","title":"DTO Enhancements"},{"location":"plugins/corda-accounts/#vaultaireaccountinfo-annotation","text":"The plugin introduces the VaultaireAccountInfo annotation as the means to mark participant or other properties of a ContractState that map to a Corda Account. Supported types include: AbstractParty AnonymousParty PublicKey AccountParty Using the annotation for the last one is optional.","title":"VaultaireAccountInfo Annotation"},{"location":"plugins/corda-accounts/#accounts-aware-dto-types","text":"The plugin also adds: AccountInfoStateDto as a convenient model that maps from app-level users or state properties (as supported by @VaultaireAccountInfo above) to Corda Accounts, i.e. AccountInfo states. AccountsAwareStateClientDto as the equivalent of REST/client-friendly equivalent,. All the above effectively provide the \u201clite\u201d DTO strategy with enhanced DTO<->state conversion and patching utilities, i.e. mainly with support for mapping between the applicable types (see @VaultaireAccountInfo ) and AccountInfoDto . As an example, consider the following state: data class MagazineState ( val publisher : AccountParty , @VaultaireAccountInfo val author : PublicKey , @VaultaireAccountInfo val editor : AbstractParty , //... override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { override val participants get () = listOf ( publisher . party , AbstractParty ( author ), editor ) //... } The generated client DTO for the above: data class MagazineStateClientDto ( var publisher : AccountInfoStateClientDto? = null , var author : AccountInfoStateClientDto? = null , var editor : AccountInfoStateClientDto? = null , //... var linearId : UniqueIdentifier? = null ) : AccountsAwareStateClientDto < BookContract . MagazineState > { //... }","title":"Accounts-Aware DTO Types"},{"location":"plugins/corda-accounts/#query-dsl-enhancements","text":"Corda 4.3 added the possibility to map any public key to an external id of type UUID. Corda Accounts uses this feature to map an account\u2019s key to the account\u2019s id. Thus, using externalIds creates query criteria aware of state participants, without the need to embed account identifiers within the state itself. This is now supported by the generated Query DSL for your contract state: val magazineStateQuery = magazineStateQuery { // Match participants using the following // AccountInfo identifiers externalIds = listOfNotNull ( publisher . identifier ) status = Vault . StateStatus . UNCONSUMED // the default // The rest of the query.. //...","title":"Query DSL Enhancements"},{"location":"plugins/corda-accounts/#service-enhancements","text":"The plugin also adds and applies various accounts-aware service types as replacements of their default equivalents, along with a number of utility methods around accounts. // Create an instance of the generated service type, // passing a ServiceHub, CordaRPCOps, NodeRpcConnection // or even a custom StateServiceDelegate val stateService = AccountInfoService ( serviceHub ) // Get the account that is already stored locally // and matching the given [id] if found, null otherwise val accountOrNull : AccountInfo? = stateService . findStoredAccount ( accountId ) ?: stateService . requestAccount ( accountId , accountHost ) // Get the account that is already stored locally // and matching the given [id] if found, null otherwise val account : AccountInfo = stateService . getStoredAccount ( accountId ) // Find accounts that are already stored locally // and match the given [criteria] val accountsPage : Vault . Page < AccountInfo > = stateService . findStoredAccounts ( queryCriteria ) // Create a public key for the given [accountInfo] */ val anonymousParty = stateService . createPublicKey ( accountInfo )","title":"Service Enhancements"},{"location":"plugins/rsql-support/","text":"RSQL Plugin \u00b6 Creating search endpoints in webapp is a tedious process, even with Vaultaire\u2019s query DSL. The main maintenance effort goes to mapping URL parameters to query criteria and operators. Why not evaluate those dynamically? This plugin uses jirutka/rsql-parser to provide support for RSQL and FIQL queries, which is great for REST: It\u2019s simple, compact and URL-friendly. There\u2019s no need to maintain endpoints as you add/modify state propperties/schemas. Supports complex queries with logical and comparison operators. Being able to store queries as strings allows to e.g. easily manage reports. Installation \u00b6 The plugin is mainly intended for Corda client applications using Spring, Spring Boot or Jackson. It can however be used with other JVM frameworks and even within cordapps. To use RSQL in your Corda client, add Vaultaire\u2019s plugin for RSQL to your Gradle build using an api , implementation or compile (deprecated) dependency. implementation \"com.github.manosbatsis.vaultaire:vaultaire-plugin-rsql:$vaultaire_version\" Note : To use the plugin in cordapps, follow the same rules as with the main Vaiultaire dependency. Plugin Features \u00b6 Extension Function \u00b6 The plugin introduces an extension function for generated DSL classes, i.e. subclasses of VaultQueryCriteriaCondition . Consider the following query DSL without RSQL: // Use the generated DSL to create query criteria val query = bookStateService . buildQuery { // blah and { fields . title `like` \"%Corda%\" fields . price gte 12 } // blah } bookStateService . queryBy ( query . toCriteria (), query . toSort ()) The equivalent using RSQL: // Use the generated DSL to create query criteria val query = bookStateService . buildQuery { // blah } // Use the RSQL extension function . withRsql ( \"title=like=*Corda*;price>=12\" , // Optional, default is // SimpleRsqlArgumentsConverter.Factory() converterFactory ) bookStateService . queryBy ( query . toCriteria (), query . toSort ()) If you\u2019re wondering about converterFactory , see the Value Converters section bellow. For an actual endpoint example that supports both \u201cregular\u201d and RSQL approaches above have a look at YoController.findPaged in the corbeans-yo-cordapp on Github. Operators \u00b6 The plugin supports the following operators: Operator(s) Examples Description == propName==queryValue Performs an equals query. Returns all entries where values in propName exactly equal queryValue != propName!=queryValue Performs a not equals query. Returns all entries where values in propName do not equal queryValue =like= propName=like=queryValue Performs an like query using * as a wildcard. Returns all entries where values in propName are like queryValue =unlike= , =notlike= , =nonlike= propName=unlike=queryValue Performs a not like query using * as a wildcard. Returns all entries where values in propName are not like queryValue =in= propName=in=(valueA, valueB) Performs an in query. Returns all entries where propName contains valueA OR valueB =out= propName=out=(valueA, valueB) Performs an not in query. Returns all entries where propName contains valueA OR valueB < , =lt= propName<queryValue , propName=lt=queryValue Performs a lesser than query. Returns all entries where values in propName are lesser than queryValue <= , =le= propName<=queryValue , propName=le=queryValue Performs a lesser than or equal to query. Returns all entries where values in propName are lesser than or equal to queryValue < , =gt= propName>queryValue , propName=gt=queryValue Performs a greater than query. Returns all entries where values in propName are greater than queryValue >= , =ge= propName>=queryValue , propName=ge=queryValue Performs a greater than or equal query. Returns all entries where values in propName are equal to or greater than queryValue =null= , =isnull= propName=null=true , propName=isnull=true Performs an is null or is not null query. Returns all entries where values in propName are null or not, based on the boolean argument. Argument Converters \u00b6 Since an RSQL query is basically a String , we need converters to transform criteria arguments to their intended type. For that purpose, the second parameter of the withRsql extension function accepts an optional RsqlArgumentsConverterFactory instance, with SimpleRsqlArgumentsConverter.Factory() being the default. You can create your own, custom RsqlArgumentsConverter and RsqlArgumentsConverterFactory types or use one already provided: Converter Class Nested Factory Description AbstractRsqlArgumentsConverter No Abstract base implementation, (optionally) extend to create your custom converter SimpleRsqlArgumentsConverter Yes The default. Simple, extensible, dependency-free implementation ObjectMapperAdapterRsqlArgumentsConverter Yes An implementation suitable for applications that make use of Jackson. Used as adapter for an ObjectMapper instance. ConversionServiceAdapterRsqlArgumentsConverter Yes An implementation suitable for applications that make use of Spring. Used as adapter for a ConversionService instance.","title":"RSQL Support"},{"location":"plugins/rsql-support/#rsql-plugin","text":"Creating search endpoints in webapp is a tedious process, even with Vaultaire\u2019s query DSL. The main maintenance effort goes to mapping URL parameters to query criteria and operators. Why not evaluate those dynamically? This plugin uses jirutka/rsql-parser to provide support for RSQL and FIQL queries, which is great for REST: It\u2019s simple, compact and URL-friendly. There\u2019s no need to maintain endpoints as you add/modify state propperties/schemas. Supports complex queries with logical and comparison operators. Being able to store queries as strings allows to e.g. easily manage reports.","title":"RSQL Plugin"},{"location":"plugins/rsql-support/#installation","text":"The plugin is mainly intended for Corda client applications using Spring, Spring Boot or Jackson. It can however be used with other JVM frameworks and even within cordapps. To use RSQL in your Corda client, add Vaultaire\u2019s plugin for RSQL to your Gradle build using an api , implementation or compile (deprecated) dependency. implementation \"com.github.manosbatsis.vaultaire:vaultaire-plugin-rsql:$vaultaire_version\" Note : To use the plugin in cordapps, follow the same rules as with the main Vaiultaire dependency.","title":"Installation"},{"location":"plugins/rsql-support/#plugin-features","text":"","title":"Plugin Features"},{"location":"plugins/rsql-support/#extension-function","text":"The plugin introduces an extension function for generated DSL classes, i.e. subclasses of VaultQueryCriteriaCondition . Consider the following query DSL without RSQL: // Use the generated DSL to create query criteria val query = bookStateService . buildQuery { // blah and { fields . title `like` \"%Corda%\" fields . price gte 12 } // blah } bookStateService . queryBy ( query . toCriteria (), query . toSort ()) The equivalent using RSQL: // Use the generated DSL to create query criteria val query = bookStateService . buildQuery { // blah } // Use the RSQL extension function . withRsql ( \"title=like=*Corda*;price>=12\" , // Optional, default is // SimpleRsqlArgumentsConverter.Factory() converterFactory ) bookStateService . queryBy ( query . toCriteria (), query . toSort ()) If you\u2019re wondering about converterFactory , see the Value Converters section bellow. For an actual endpoint example that supports both \u201cregular\u201d and RSQL approaches above have a look at YoController.findPaged in the corbeans-yo-cordapp on Github.","title":"Extension Function"},{"location":"plugins/rsql-support/#operators","text":"The plugin supports the following operators: Operator(s) Examples Description == propName==queryValue Performs an equals query. Returns all entries where values in propName exactly equal queryValue != propName!=queryValue Performs a not equals query. Returns all entries where values in propName do not equal queryValue =like= propName=like=queryValue Performs an like query using * as a wildcard. Returns all entries where values in propName are like queryValue =unlike= , =notlike= , =nonlike= propName=unlike=queryValue Performs a not like query using * as a wildcard. Returns all entries where values in propName are not like queryValue =in= propName=in=(valueA, valueB) Performs an in query. Returns all entries where propName contains valueA OR valueB =out= propName=out=(valueA, valueB) Performs an not in query. Returns all entries where propName contains valueA OR valueB < , =lt= propName<queryValue , propName=lt=queryValue Performs a lesser than query. Returns all entries where values in propName are lesser than queryValue <= , =le= propName<=queryValue , propName=le=queryValue Performs a lesser than or equal to query. Returns all entries where values in propName are lesser than or equal to queryValue < , =gt= propName>queryValue , propName=gt=queryValue Performs a greater than query. Returns all entries where values in propName are greater than queryValue >= , =ge= propName>=queryValue , propName=ge=queryValue Performs a greater than or equal query. Returns all entries where values in propName are equal to or greater than queryValue =null= , =isnull= propName=null=true , propName=isnull=true Performs an is null or is not null query. Returns all entries where values in propName are null or not, based on the boolean argument.","title":"Operators"},{"location":"plugins/rsql-support/#argument-converters","text":"Since an RSQL query is basically a String , we need converters to transform criteria arguments to their intended type. For that purpose, the second parameter of the withRsql extension function accepts an optional RsqlArgumentsConverterFactory instance, with SimpleRsqlArgumentsConverter.Factory() being the default. You can create your own, custom RsqlArgumentsConverter and RsqlArgumentsConverterFactory types or use one already provided: Converter Class Nested Factory Description AbstractRsqlArgumentsConverter No Abstract base implementation, (optionally) extend to create your custom converter SimpleRsqlArgumentsConverter Yes The default. Simple, extensible, dependency-free implementation ObjectMapperAdapterRsqlArgumentsConverter Yes An implementation suitable for applications that make use of Jackson. Used as adapter for an ObjectMapper instance. ConversionServiceAdapterRsqlArgumentsConverter Yes An implementation suitable for applications that make use of Spring. Used as adapter for a ConversionService instance.","title":"Argument Converters"}]}