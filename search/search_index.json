{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Vaultaire Query DSL and data access utilities for Corda developers. Query DSL Use DSL will make your queries much easier to read and maintain. Each query DSL is automatically generated and maintaind for you based on your states. al query = booksQuery { and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` Corda Books Ltd. or { fields . title ` == ` A book on Corda fields . author ` != ` John Doe } } orderBy { fields . title sort DESC } }. toCriteria () For more info on query DSL, checkout https://manosbatsis.github.io/vaultaire/query-dsl/ State Services Vaultaire s annotation processor will automatically subclass ExtendedStateService to generate an Fields aware state service service per annotated element. The generated service name is ${contractStateTypeName}Service . Usage example: // Create an instance of the generated service type val bookStateService = BookStateService ( serviceHub , // Service hub or RPC ops serviceDefaults ) // Optional: criteria, paging, sort defaults // Load a book bookStateService . getByLinearId ( identifier ) // Try finding one by ISBN bookStateService . findByExternalId ( identifier ) // query the vault for books val searchResults = bookStateService . queryBy ( criteria , paging , Pair ( published , DESC ), Pair ( title , DESC )) For more info on state services, checkout https://manosbatsis.github.io/vaultaire/state-services/ Other Utils Vaultaire includes a few other utilities like annotations to generate Data Transfer Objects for your contract states and responding flows from commonly used supertypes. For more info on these utilities, checkout https://manosbatsis.github.io/vaultaire/other-utils/","title":"Overview"},{"location":"#vaultaire","text":"Query DSL and data access utilities for Corda developers.","title":"Vaultaire"},{"location":"#query-dsl","text":"Use DSL will make your queries much easier to read and maintain. Each query DSL is automatically generated and maintaind for you based on your states. al query = booksQuery { and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` Corda Books Ltd. or { fields . title ` == ` A book on Corda fields . author ` != ` John Doe } } orderBy { fields . title sort DESC } }. toCriteria () For more info on query DSL, checkout https://manosbatsis.github.io/vaultaire/query-dsl/","title":"Query DSL"},{"location":"#state-services","text":"Vaultaire s annotation processor will automatically subclass ExtendedStateService to generate an Fields aware state service service per annotated element. The generated service name is ${contractStateTypeName}Service . Usage example: // Create an instance of the generated service type val bookStateService = BookStateService ( serviceHub , // Service hub or RPC ops serviceDefaults ) // Optional: criteria, paging, sort defaults // Load a book bookStateService . getByLinearId ( identifier ) // Try finding one by ISBN bookStateService . findByExternalId ( identifier ) // query the vault for books val searchResults = bookStateService . queryBy ( criteria , paging , Pair ( published , DESC ), Pair ( title , DESC )) For more info on state services, checkout https://manosbatsis.github.io/vaultaire/state-services/","title":"State Services"},{"location":"#other-utils","text":"Vaultaire includes a few other utilities like annotations to generate Data Transfer Objects for your contract states and responding flows from commonly used supertypes. For more info on these utilities, checkout https://manosbatsis.github.io/vaultaire/other-utils/","title":"Other Utils"},{"location":"changelog/","text":"Changelog The following sections describe major changes per version and can be helpful with version upgrades. 0.25 Bumped Corda to OS 4.4 Added support for lite DTO strategy 0.24 Added default parameter value false to VaultQueryCriteriaCondition.toCriteria(boolean) , so that aggregates are not ignored by default. 0.23 Fixed corda API design issue, where a secondary VaultCustomQueryCriteria s implicit/default status of UNCONSUMED (VS null) is applied, overriding the root DSL status 0.22 Bumped kotlin-utils, fixing issue with DTO generation including companion object members of the source type. 0.21 Bumped KotlinPoet, util versions Added @DefaultValue example in the docs 0.20 Added CordaSerializable annotation to generated DTOs Added ignoreProperties to VaultaireGenerateDto and VaultaireGenerateDtoForDependency , useful with derived/backed properties like participants 0.19 Added [NodeRpcConnection] interface and [StateServiceRpcConnectionDelegate] for libraries in need of more flexible [StateServiceDelegate] integration e.g. Corbeans/Spring or other IoC containers 0.18 Bumped deps i.e. Corda to OS 4.3 0.17 Added support for sorting based on standard attributes and aliases of those, i.e. enum values of Sort.CommonStateAttribute , Sort.VaultStateAttribute , Sort.LinearStateAttribute and Sort.FungibleStateAttribute . 0.16 Added copyAnnotationPackages property to VaultaireGenerateDto and VaultaireGenerateDtoForDependency . The property can be used to define a list of base packages for matching annotations to be copied automatically from a source ContractState to it s generated DTO. This is useful when replication of e.g. Jackson or Bean Validation annotations can be useful. 0.15 Replaced com.github.manosbatsis.vaultaire.dto.Dto and com.github.manosbatsis.vaultaire.util.DtoInsufficientStateMappingException with kotlin-utils equivalents extracted there. You may need to update package/method names in your code if you make use of generated DTOs. 0.14 Vaultaire s *ForDependency annotations now use the annotated element s package (suffixed with .generated ) for output. This leaves the original (state) packages exclusive to their modules if needed, avoiding when cordapp package conflicts while testing. 0.13 Add support for final responder flow supertypes in VaultaireGenerateResponder 0.12 Fixed dependency scope for kotlin-utils 0.11 Added VaultaireGenerateDto , VaultaireGenerateDtoForDependency annotations for generating DTOs for contract states Added VaultaireGenerateResponder annotation for generating responder flows extending common supertypes Refactored to extract kotlin-utils 0.10 Added @VaultaireGenerateForDependency to support generation (of DSL, Services etc.) for states contributed to the classpath by project dependencies Enhanced generated subclasses of ExtendedStateService with DSL-aware buildQuery , queryBy and trackBy Fixed typo from VaultaireGenerate.constractStateType to VaultaireGenerate.contractStateType 0.9 0.8 re-release fix 0.8 Allow annotation processing to generate code to another Gradle module or location using the kapt.kotlin.vaultaire.generated kapt argument, see installation docs. 0.7 Fixed, improved and added tests for StateService get/find by id/externalId methods StateService get by id/externalId will throw a StateNotFoundException when no match is found 0.6 Added support for aggregate functions . Added getByExternalId and findByExternalId methods to StateService Added optional Vault.RelevancyStatus parameter to StateService getByLinearId and findByLinearId methods 0.5 Removed param from String.asUniqueIdentifier() 0.4 Fixed handling of nullable fields Added string input signatures for getByLinearId , findByLinearId 0.3 Refactored StateService to an interface 0.2 Renamed VaultQueryDsl annotation to VaultaireGenerate Renamed StateService to BasicStateService , added extended StateService type. The annotation processor will now generate a subclass of StateService per annotated PersistentState 0.1 Initial release","title":"Change Log"},{"location":"changelog/#changelog","text":"The following sections describe major changes per version and can be helpful with version upgrades.","title":"Changelog"},{"location":"changelog/#025","text":"Bumped Corda to OS 4.4 Added support for lite DTO strategy","title":"0.25"},{"location":"changelog/#024","text":"Added default parameter value false to VaultQueryCriteriaCondition.toCriteria(boolean) , so that aggregates are not ignored by default.","title":"0.24"},{"location":"changelog/#023","text":"Fixed corda API design issue, where a secondary VaultCustomQueryCriteria s implicit/default status of UNCONSUMED (VS null) is applied, overriding the root DSL status","title":"0.23"},{"location":"changelog/#022","text":"Bumped kotlin-utils, fixing issue with DTO generation including companion object members of the source type.","title":"0.22"},{"location":"changelog/#021","text":"Bumped KotlinPoet, util versions Added @DefaultValue example in the docs","title":"0.21"},{"location":"changelog/#020","text":"Added CordaSerializable annotation to generated DTOs Added ignoreProperties to VaultaireGenerateDto and VaultaireGenerateDtoForDependency , useful with derived/backed properties like participants","title":"0.20"},{"location":"changelog/#019","text":"Added [NodeRpcConnection] interface and [StateServiceRpcConnectionDelegate] for libraries in need of more flexible [StateServiceDelegate] integration e.g. Corbeans/Spring or other IoC containers","title":"0.19"},{"location":"changelog/#018","text":"Bumped deps i.e. Corda to OS 4.3","title":"0.18"},{"location":"changelog/#017","text":"Added support for sorting based on standard attributes and aliases of those, i.e. enum values of Sort.CommonStateAttribute , Sort.VaultStateAttribute , Sort.LinearStateAttribute and Sort.FungibleStateAttribute .","title":"0.17"},{"location":"changelog/#016","text":"Added copyAnnotationPackages property to VaultaireGenerateDto and VaultaireGenerateDtoForDependency . The property can be used to define a list of base packages for matching annotations to be copied automatically from a source ContractState to it s generated DTO. This is useful when replication of e.g. Jackson or Bean Validation annotations can be useful.","title":"0.16"},{"location":"changelog/#015","text":"Replaced com.github.manosbatsis.vaultaire.dto.Dto and com.github.manosbatsis.vaultaire.util.DtoInsufficientStateMappingException with kotlin-utils equivalents extracted there. You may need to update package/method names in your code if you make use of generated DTOs.","title":"0.15"},{"location":"changelog/#014","text":"Vaultaire s *ForDependency annotations now use the annotated element s package (suffixed with .generated ) for output. This leaves the original (state) packages exclusive to their modules if needed, avoiding when cordapp package conflicts while testing.","title":"0.14"},{"location":"changelog/#013","text":"Add support for final responder flow supertypes in VaultaireGenerateResponder","title":"0.13"},{"location":"changelog/#012","text":"Fixed dependency scope for kotlin-utils","title":"0.12"},{"location":"changelog/#011","text":"Added VaultaireGenerateDto , VaultaireGenerateDtoForDependency annotations for generating DTOs for contract states Added VaultaireGenerateResponder annotation for generating responder flows extending common supertypes Refactored to extract kotlin-utils","title":"0.11"},{"location":"changelog/#010","text":"Added @VaultaireGenerateForDependency to support generation (of DSL, Services etc.) for states contributed to the classpath by project dependencies Enhanced generated subclasses of ExtendedStateService with DSL-aware buildQuery , queryBy and trackBy Fixed typo from VaultaireGenerate.constractStateType to VaultaireGenerate.contractStateType","title":"0.10"},{"location":"changelog/#09","text":"0.8 re-release fix","title":"0.9"},{"location":"changelog/#08","text":"Allow annotation processing to generate code to another Gradle module or location using the kapt.kotlin.vaultaire.generated kapt argument, see installation docs.","title":"0.8"},{"location":"changelog/#07","text":"Fixed, improved and added tests for StateService get/find by id/externalId methods StateService get by id/externalId will throw a StateNotFoundException when no match is found","title":"0.7"},{"location":"changelog/#06","text":"Added support for aggregate functions . Added getByExternalId and findByExternalId methods to StateService Added optional Vault.RelevancyStatus parameter to StateService getByLinearId and findByLinearId methods","title":"0.6"},{"location":"changelog/#05","text":"Removed param from String.asUniqueIdentifier()","title":"0.5"},{"location":"changelog/#04","text":"Fixed handling of nullable fields Added string input signatures for getByLinearId , findByLinearId","title":"0.4"},{"location":"changelog/#03","text":"Refactored StateService to an interface","title":"0.3"},{"location":"changelog/#02","text":"Renamed VaultQueryDsl annotation to VaultaireGenerate Renamed StateService to BasicStateService , added extended StateService type. The annotation processor will now generate a subclass of StateService per annotated PersistentState","title":"0.2"},{"location":"changelog/#01","text":"Initial release","title":"0.1"},{"location":"credits/","text":"Credits The following projects where of great help in creating my first DSL: AutoDsl , SqlDsl and of course the amazing KotlinPoet","title":"Credits"},{"location":"credits/#credits","text":"The following projects where of great help in creating my first DSL: AutoDsl , SqlDsl and of course the amazing KotlinPoet","title":"Credits"},{"location":"faq/","text":"Frequently Asked Questions Answers to common questions. License Vaultaire is distributed under the GNU Lesser General Public License or LGPL. This is the same license adopted by Corda dependencies like Hibernate. It allows Vaultaire to be used as a library with no effect to your project. Use with Corda Enterprise To use Vaultaire with Corda Enterprise, you will have to update your build to use the CE release . After switching to the appropriate corda_release_group and corda_release_version in your ext section, you can instruct your build to substitute transitive Corda OS dependencies with their CE equivalents: allprojects { //... configurations { all { //... resolutionStrategy { // ... eachDependency { DependencyResolveDetails details - // Exclude from substitutions as appropriate, e.g. def exclusions = [ corda-finance-contracts ] // Substitute the rest, assumes `ext.corda_release_group` and `ext.corda_release_version` are set if ( details . requested . group == net.corda ! exclusions . contains ( details . requested . name )) { // Force Corda Enterprise details . useTarget group: corda_release_group , name: details . requested . name , version: corda_release_version } } } } } } Note : The above assumes ext.corda_release_group and ext.corda_release_version are already set, e.g. to com.r3.corda and 4.2 respectively.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"Answers to common questions.","title":"Frequently Asked Questions"},{"location":"faq/#license","text":"Vaultaire is distributed under the GNU Lesser General Public License or LGPL. This is the same license adopted by Corda dependencies like Hibernate. It allows Vaultaire to be used as a library with no effect to your project.","title":"License"},{"location":"faq/#use-with-corda-enterprise","text":"To use Vaultaire with Corda Enterprise, you will have to update your build to use the CE release . After switching to the appropriate corda_release_group and corda_release_version in your ext section, you can instruct your build to substitute transitive Corda OS dependencies with their CE equivalents: allprojects { //... configurations { all { //... resolutionStrategy { // ... eachDependency { DependencyResolveDetails details - // Exclude from substitutions as appropriate, e.g. def exclusions = [ corda-finance-contracts ] // Substitute the rest, assumes `ext.corda_release_group` and `ext.corda_release_version` are set if ( details . requested . group == net.corda ! exclusions . contains ( details . requested . name )) { // Force Corda Enterprise details . useTarget group: corda_release_group , name: details . requested . name , version: corda_release_version } } } } } } Note : The above assumes ext.corda_release_group and ext.corda_release_version are already set, e.g. to com.r3.corda and 4.2 respectively.","title":"Use with Corda Enterprise"},{"location":"installation/","text":"Installation For Cordapps Add to your Cordapp s Gradle dependencies: // apply the kapt plugin apply plugin: kotlin-kapt // Optional: for IntelliJ users, see also sourceSets bellow apply plugin: idea dependencies { // Core dependency cordaCompile com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version // Annotation processing kapt com.github.manosbatsis.vaultaire:vaultaire-processor:$vaultaire_version // Corda dependencies etc. // ... } You may also want to add the generated sources to your build s sourceSets // Define an extra sources variable def generatedSourcesDir = project . file ( build/generated/source/kaptKotlin/main ) // Tell Gradle about the extra source set sourceSets { main { kotlin . srcDirs += generatedSourcesDir } } // Optional: Tell IntelliJ about the extra source set idea { module { sourceDirs += generatedSourcesDir generatedSourceDirs += generatedSourcesDir } } Note that setting kotlin.incremental=true in gradle.properties may break non-clean builds earlier versions of kotlin like 1.2.71 - if you enable incremental then you ll need to ./gradlew clean when building. For Client Apps The core module can also be useful outside a cordapp, e.g. in a Spring application interacting with Corda nodes via RPC: // Core dependency compile com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version // Corda dependencies etc. // ...","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#for-cordapps","text":"Add to your Cordapp s Gradle dependencies: // apply the kapt plugin apply plugin: kotlin-kapt // Optional: for IntelliJ users, see also sourceSets bellow apply plugin: idea dependencies { // Core dependency cordaCompile com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version // Annotation processing kapt com.github.manosbatsis.vaultaire:vaultaire-processor:$vaultaire_version // Corda dependencies etc. // ... } You may also want to add the generated sources to your build s sourceSets // Define an extra sources variable def generatedSourcesDir = project . file ( build/generated/source/kaptKotlin/main ) // Tell Gradle about the extra source set sourceSets { main { kotlin . srcDirs += generatedSourcesDir } } // Optional: Tell IntelliJ about the extra source set idea { module { sourceDirs += generatedSourcesDir generatedSourceDirs += generatedSourcesDir } } Note that setting kotlin.incremental=true in gradle.properties may break non-clean builds earlier versions of kotlin like 1.2.71 - if you enable incremental then you ll need to ./gradlew clean when building.","title":"For Cordapps"},{"location":"installation/#for-client-apps","text":"The core module can also be useful outside a cordapp, e.g. in a Spring application interacting with Corda nodes via RPC: // Core dependency compile com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version // Corda dependencies etc. // ...","title":"For Client Apps"},{"location":"other-utils/","text":"Other Utilities Miscellaneous utilities provides by Vaultaire Generated Responders Some times you might want to use the same responding flow with multiple initiating flows. Since @InitiatedBy is not a repeatable annotation, the only option would be to subclass the same responder for each initiating flow, adding the appropriate @InitiatedBy . Vaultaire s annotation processor can help you automate this using a @VaultaireGenerateResponder instead of maintaning such responders manually. Usage example: // or simply: @VaultaireGenerateResponder(BaseBookFlowResponder::class) @VaultaireGenerateResponder ( value = BaseBookFlowResponder :: class , comment = A basic responder to listen for finality ) @InitiatingFlow @StartableByRPC class CreateBookFlow ( input : BookMessage ) : FlowLogic SignedTransaction The above will automatically generate a responder flow: /** * A basic responder to listen for finality */ @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( otherPartySession : FlowSession ) : BaseBookFlowResponder ( otherPartySession ) Note : if the base responder flow is a final type, the generated responder will attempt to call it as a subflow instead of extending it: @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( val otherPartySession : FlowSession ) : FlowLogic Unit () { @Suspendable override fun call () { subFlow ( BaseBookFlowResponder ( otherPartySession )) } } Generated DTOs Maintaining Data Transfer Objects (e.g. for REST) of your contract states can be a very mundane task. You can have Vaultaire generate those for you either using @VaultaireGenerateDto on the contract state class directly: @VaultaireGenerateDto ( // optional: properties to ignore ignoreProperties = [ participants ] ) data class BookState ( val publisher : Party , val author : Party , val price : BigDecimal , val genre : Genre , @DefaultValue ( 1 ) val editions : Int = 1 , val title : String = Uknown , val published : Date = Date (), @field : JsonProperty ( alias ) val alternativeTitle : String ? = null , override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { /* ... */ } or @VaultaireGenerateDtoForDependency when targetting a contract state within your dependencies e.g. from your contract states module or a third party class: @VaultaireGenerateDtoForDependency ( persistentStateType = PersistentBookState :: class , contractStateType = BookState :: class , // optional: properties to ignore ignoreProperties = [ participants ] ) class Dummy // just a placeholder for our annotation In both cases the following DTO will be generated, along with proper implementations of [Dto] s mapping/patching utility methods: /** * A [BookState]-specific [Dto] implementation */ @CordaSerializable data class BookStateDto ( var publisher : Party ? = null , var author : Party ? = null , var price : BigDecimal ? = null , var genre : BookContract . Genre ? = null , var editions : Int ? = 1 , var title : String ? = null , var published : Date ? = null , @field : JsonProperty ( value = alias ) var alternativeTitle : String ? = null , var linearId : UniqueIdentifier ? = null ) : Dto BookState { /** * Alternative constructor, used to map * from the given [BookState] instance. */ constructor ( original : BookState ) : this ( publisher = original . publisher , author = original . author , price = original . price , genre = original . genre , editions = original . editions , title = original . title , published = original . published , alternativeTitle = original . alternativeTitle , linearId = original . linearId ) /** * Create a patched copy of the given [BookState] instance, * updated using this DTO s non-null properties. */ override fun toPatched ( original : BookState ): BookState { val patched = BookState ( publisher = this . publisher ?: original . publisher , author = this . author ?: original . author , price = this . price ?: original . price , genre = this . genre ?: original . genre , editions = this . editions ?: original . editions , title = this . title ?: original . title , published = this . published ?: original . published , alternativeTitle = this . alternativeTitle ?: original . alternativeTitle , linearId = this . linearId ?: original . linearId ) return patched } /** * Create an instance of [BookState], using this DTO s properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ override fun toState (): BookState { try { val state = BookState ( publisher = this . publisher !! , author = this . author !! , price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return state } catch ( e : Exception ) { throw DtoInsufficientStateMappingException ( exception = e ) } } } DTO Strategies Both @VaultaireGenerateDto and @VaultaireGenerateDtoForDependency support generation strategies. By default the strategy used is VaultaireDtoStrategyKeys.DEFAULT . @VaultaireGenerateDto ( // optional: properties to ignore ignoreProperties = [ participants ], // Default is [VaultaireDtoStrategyKeys.DEFAULT] strategies = [ VaultaireDtoStrategyKeys . DEFAULT , VaultaireDtoStrategyKeys . LITE ]) ) data class BookState ( val publisher : Party , val author : Party , val price : BigDecimal , val genre : Genre , @DefaultValue ( 1 ) val editions : Int = 1 , val title : String = Uknown , val published : Date = Date (), @field : JsonProperty ( alias ) val alternativeTitle : String ? = null , override val linearId : UniqueIdentifier = UniqueIdentifier ()) : LinearState , QueryableState { //... } The lite strategy is provided to help where deserialization would normally require either a ServiceHub or RpcOps , e.g. when the target property is a Party , in which case the DTO will use a more accessible type like CordaX500Name , and require a service to convert to or patch a ContractState instance. Note that lite DTO classname also have a LiteDto suffix. Here s the lite DTO generated for the above example: /** * A [BookContract.BookState]-specific [com.github.manotbatsis.kotlin.utils.api.Dto] implementation */ data class BookStateLiteDto ( var publisher : CordaX500Name ? = null , var author : CordaX500Name ? = null , var price : BigDecimal ? = null , var genre : BookContract . Genre ? = null , var editions : Int ? = 1 , var title : String ? = null , var published : Date ? = null , @field : JsonProperty ( value = alias ) var alternativeTitle : String ? = null , var linearId : UniqueIdentifier ? = null ) : VaultaireDto BookContract . BookState { /** * Alternative constructor, used to map * from the given [BookContract.BookState] instance. */ constructor ( original : BookContract . BookState ) : this ( publisher = original . publisher . name , author = original . author . name , price = original . price , genre = original . genre , editions = original . editions , title = original . title , published = original . published , alternativeTitle = original . alternativeTitle , linearId = original . linearId ) /** * Create a patched copy of the given [BookContract.BookState] instance, * updated using this DTO s non-null properties. */ override fun toPatched ( original : BookContract . BookState , stateService : StateService BookContract . BookState ): BookContract . BookState { val patched = BookContract . BookState ( publisher = if ( this . publisher != null ) stateService . wellKnownPartyFromX500Name ( this . publisher !! ) !! else original . publisher !! , author = if ( this . author != null ) stateService . wellKnownPartyFromX500Name ( this . author !! ) !! else original . author !! , price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return patched } /** * Create an instance of [BookContract.BookState], using this DTO s properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ override fun toTargetType ( stateService : StateService BookContract . BookState ): BookContract . BookState { try { val originalTypeInstance = BookContract . BookState ( publisher = if ( this . publisher != null ) stateService . wellKnownPartyFromX500Name ( this . publisher !! ) !! else throw DtoInsufficientMappingException ( No value given for property publisher ), author = if ( this . author != null ) stateService . wellKnownPartyFromX500Name ( this . author !! ) !! else throw DtoInsufficientMappingException ( No value given for property author ), price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return originalTypeInstance } catch ( e : Exception ) { throw DtoInsufficientMappingException ( exception = e ) } } }","title":"Other Utilities"},{"location":"other-utils/#other-utilities","text":"Miscellaneous utilities provides by Vaultaire","title":"Other Utilities"},{"location":"other-utils/#generated-responders","text":"Some times you might want to use the same responding flow with multiple initiating flows. Since @InitiatedBy is not a repeatable annotation, the only option would be to subclass the same responder for each initiating flow, adding the appropriate @InitiatedBy . Vaultaire s annotation processor can help you automate this using a @VaultaireGenerateResponder instead of maintaning such responders manually. Usage example: // or simply: @VaultaireGenerateResponder(BaseBookFlowResponder::class) @VaultaireGenerateResponder ( value = BaseBookFlowResponder :: class , comment = A basic responder to listen for finality ) @InitiatingFlow @StartableByRPC class CreateBookFlow ( input : BookMessage ) : FlowLogic SignedTransaction The above will automatically generate a responder flow: /** * A basic responder to listen for finality */ @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( otherPartySession : FlowSession ) : BaseBookFlowResponder ( otherPartySession ) Note : if the base responder flow is a final type, the generated responder will attempt to call it as a subflow instead of extending it: @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( val otherPartySession : FlowSession ) : FlowLogic Unit () { @Suspendable override fun call () { subFlow ( BaseBookFlowResponder ( otherPartySession )) } }","title":"Generated Responders"},{"location":"other-utils/#generated-dtos","text":"Maintaining Data Transfer Objects (e.g. for REST) of your contract states can be a very mundane task. You can have Vaultaire generate those for you either using @VaultaireGenerateDto on the contract state class directly: @VaultaireGenerateDto ( // optional: properties to ignore ignoreProperties = [ participants ] ) data class BookState ( val publisher : Party , val author : Party , val price : BigDecimal , val genre : Genre , @DefaultValue ( 1 ) val editions : Int = 1 , val title : String = Uknown , val published : Date = Date (), @field : JsonProperty ( alias ) val alternativeTitle : String ? = null , override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { /* ... */ } or @VaultaireGenerateDtoForDependency when targetting a contract state within your dependencies e.g. from your contract states module or a third party class: @VaultaireGenerateDtoForDependency ( persistentStateType = PersistentBookState :: class , contractStateType = BookState :: class , // optional: properties to ignore ignoreProperties = [ participants ] ) class Dummy // just a placeholder for our annotation In both cases the following DTO will be generated, along with proper implementations of [Dto] s mapping/patching utility methods: /** * A [BookState]-specific [Dto] implementation */ @CordaSerializable data class BookStateDto ( var publisher : Party ? = null , var author : Party ? = null , var price : BigDecimal ? = null , var genre : BookContract . Genre ? = null , var editions : Int ? = 1 , var title : String ? = null , var published : Date ? = null , @field : JsonProperty ( value = alias ) var alternativeTitle : String ? = null , var linearId : UniqueIdentifier ? = null ) : Dto BookState { /** * Alternative constructor, used to map * from the given [BookState] instance. */ constructor ( original : BookState ) : this ( publisher = original . publisher , author = original . author , price = original . price , genre = original . genre , editions = original . editions , title = original . title , published = original . published , alternativeTitle = original . alternativeTitle , linearId = original . linearId ) /** * Create a patched copy of the given [BookState] instance, * updated using this DTO s non-null properties. */ override fun toPatched ( original : BookState ): BookState { val patched = BookState ( publisher = this . publisher ?: original . publisher , author = this . author ?: original . author , price = this . price ?: original . price , genre = this . genre ?: original . genre , editions = this . editions ?: original . editions , title = this . title ?: original . title , published = this . published ?: original . published , alternativeTitle = this . alternativeTitle ?: original . alternativeTitle , linearId = this . linearId ?: original . linearId ) return patched } /** * Create an instance of [BookState], using this DTO s properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ override fun toState (): BookState { try { val state = BookState ( publisher = this . publisher !! , author = this . author !! , price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return state } catch ( e : Exception ) { throw DtoInsufficientStateMappingException ( exception = e ) } } }","title":"Generated DTOs"},{"location":"other-utils/#dto-strategies","text":"Both @VaultaireGenerateDto and @VaultaireGenerateDtoForDependency support generation strategies. By default the strategy used is VaultaireDtoStrategyKeys.DEFAULT . @VaultaireGenerateDto ( // optional: properties to ignore ignoreProperties = [ participants ], // Default is [VaultaireDtoStrategyKeys.DEFAULT] strategies = [ VaultaireDtoStrategyKeys . DEFAULT , VaultaireDtoStrategyKeys . LITE ]) ) data class BookState ( val publisher : Party , val author : Party , val price : BigDecimal , val genre : Genre , @DefaultValue ( 1 ) val editions : Int = 1 , val title : String = Uknown , val published : Date = Date (), @field : JsonProperty ( alias ) val alternativeTitle : String ? = null , override val linearId : UniqueIdentifier = UniqueIdentifier ()) : LinearState , QueryableState { //... } The lite strategy is provided to help where deserialization would normally require either a ServiceHub or RpcOps , e.g. when the target property is a Party , in which case the DTO will use a more accessible type like CordaX500Name , and require a service to convert to or patch a ContractState instance. Note that lite DTO classname also have a LiteDto suffix. Here s the lite DTO generated for the above example: /** * A [BookContract.BookState]-specific [com.github.manotbatsis.kotlin.utils.api.Dto] implementation */ data class BookStateLiteDto ( var publisher : CordaX500Name ? = null , var author : CordaX500Name ? = null , var price : BigDecimal ? = null , var genre : BookContract . Genre ? = null , var editions : Int ? = 1 , var title : String ? = null , var published : Date ? = null , @field : JsonProperty ( value = alias ) var alternativeTitle : String ? = null , var linearId : UniqueIdentifier ? = null ) : VaultaireDto BookContract . BookState { /** * Alternative constructor, used to map * from the given [BookContract.BookState] instance. */ constructor ( original : BookContract . BookState ) : this ( publisher = original . publisher . name , author = original . author . name , price = original . price , genre = original . genre , editions = original . editions , title = original . title , published = original . published , alternativeTitle = original . alternativeTitle , linearId = original . linearId ) /** * Create a patched copy of the given [BookContract.BookState] instance, * updated using this DTO s non-null properties. */ override fun toPatched ( original : BookContract . BookState , stateService : StateService BookContract . BookState ): BookContract . BookState { val patched = BookContract . BookState ( publisher = if ( this . publisher != null ) stateService . wellKnownPartyFromX500Name ( this . publisher !! ) !! else original . publisher !! , author = if ( this . author != null ) stateService . wellKnownPartyFromX500Name ( this . author !! ) !! else original . author !! , price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return patched } /** * Create an instance of [BookContract.BookState], using this DTO s properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ override fun toTargetType ( stateService : StateService BookContract . BookState ): BookContract . BookState { try { val originalTypeInstance = BookContract . BookState ( publisher = if ( this . publisher != null ) stateService . wellKnownPartyFromX500Name ( this . publisher !! ) !! else throw DtoInsufficientMappingException ( No value given for property publisher ), author = if ( this . author != null ) stateService . wellKnownPartyFromX500Name ( this . author !! ) !! else throw DtoInsufficientMappingException ( No value given for property author ), price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return originalTypeInstance } catch ( e : Exception ) { throw DtoInsufficientMappingException ( exception = e ) } } }","title":"DTO Strategies"},{"location":"query-dsl/","text":"Query DSL Vaultaire uses an annotation processor at build-time to create a query DSL for your contract/persistent states. Quick Example Consider the following Contract/Persistent States: /** Book ContractState */ data class BookState ( val publisher : Party , val author : Party , val title : String , val published : Date = Date () ) : ContractState , QueryableState { // ... } // Use Vaultaire s code generation! @VaultaireGenerate ( name = booksQuery , contractStateType = BookState :: class ) @Entity @Table ( name = books ) data class PersistentBookState ( @Column ( name = publisher ) var publisher : String = , @Column ( name = author ) var author : String = , @Column ( name = title ) var title : String = , @Column ( name = published ) var published : Date ) : PersistentState () Before Vaultaire Before Vaultaire, you probably had to create query criteria with something like: val query = VaultQueryCriteria ( contractStateTypes = setOf ( BookState :: class . java ), status = Vault . StateStatus . ALL ) // Check publisher? if ( checkPublisher ) query = query . and ( VaultCustomQueryCriteria ( PersistentBookState :: publisher . equal ( Corda Books Ltd. ))) // Add more criteria query . and ( VaultCustomQueryCriteria ( PersistentBookState :: title . equal ( A book on Corda )) . or ( VaultCustomQueryCriteria ( PersistentBookState :: author . notEqual ( John Doe )))) val sort = Sort ( listOf ( Sort . SortColumn ( SortAttribute . Custom ( PersistentBookState :: class . java , published ), Sort . Direction . DESC ))) // Finally! queryBy ( query , sort ) A bit verbose so get s difficult to read as the query becomes more complex. Let s try to simplify things bellow. With Vaultaire DSL With Vaultaire s @VaultaireGenerate and the generated DSL this becomes: // Use the generated DSL to create query criteria val query = booksQuery { status = Vault . StateStatus . ALL and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` Corda Books Ltd. or { fields . title ` == ` A book on Corda fields . author ` != ` John Doe } } orderBy { fields . title sort DESC } }. toCriteria () queryBy ( query . toCriteria (), query . toSort ()) Create a DSL Project Module States To create a query DSL for your state after installing Vaultaire, annotate the corresponding PersistentState with @VaultaireGenerate : // Use Vaultaire s DSL generation! @VaultaireGenerate ( // If you omit the name, the DSL function will be named by appending Query // to the decapitalized contract state name, e.g. bookStateQuery name = booksQuery , contractStateType = BookState :: class ) @Entity @Table ( name = books ) data class PersistentBookState ( // state properties... ) : PersistentState () Project Dependency States To create a query DSL for a state from your project dependencies, annotate the any class in your project using the special @VaultaireGenerateFor annotation, providing the state s ContractState and PersistentState : @VaultaireGenerateForDependency ( name = fungibleTokenConditions , persistentStateType = PersistentFungibleToken :: class , contractStateType = FungibleToken :: class ) class Fungible Query Settings The generated DSL allows setting QueryCriteria.VaultQueryCriteria members. Here s an example using the defaults: val query = booksQuery { // settings status = Vault . StateStatus . UNCONSUMED stateRefs = null notary = null softLockingCondition = null timeCondition = null relevancyStatus = Vault . RelevancyStatus . ALL constraintTypes = emptySet () constraints = emptySet () participants = null // criteria and sorting... } Adding Criteria Query riteria are defined within the and / or functions. Both functions can be nested and mixed with criteria like: val query = booksQuery { // settings... // criteria or { // Match at least one fields . foo1 ` == ` someValue and { // Match all fields . foo1 . isNull () fields . foo2 ` == ` someOtherValue and { // ... } or { // ... } } } // sorting... } Adding Aggregates Aggregates can be specified within the and / or functions: val bookStateQuery = bookStateQuery { // settings... // criteria and { fields . title `like` %Corda Foundation% fields . genre ` == ` BookContract . BookGenre . SCIENCE_FICTION } // aggregates aggregate { // add some aggregates fields . externalId . count () fields . id . count () fields . editions . sum () fields . price . min () fields . price . avg () fields . price . max () } } Note : Corda paged queries can include either query results or other results based on the above aggregates. For that purpose, the toCriteria functions accepts an optional boolean to ignore aggregates, thus allowing the reuse of the same query to obtain either paged state or aggregate results. Accessing Fields Fields can be accessed via the generated DSL s fields object within and , or , or orderBy functions using dot notation e.g. fields.foo . You can also retrieve fields by name with e.g. fields[\"foo\"] or fields.get(\"foo\") and use non typesafe functions like _equal , _notEqual , _like , _notLike but this may change in a future release. Functions and Operators Name Aliases Examples isNull fields.foo.isNull() notNull fields.foo.notNull() equal `==` fields.foo `==` bar fields.foo equal bar fields.foo.equal(bar) notEqual `!=` fields.foo `!=` bar fields.foo notEqual bar fields.foo.notEqual(bar) lessThan lt fields.foo lt bar fields.foo lessThan bar fields.foo.lessThan(bar) lessThanOrEqual lte fields.foo lte bar fields.foo lessThanOrEqual bar fields.foo.lessThanOrEqual(bar) greaterThan gt fields.foo gt bar fields.foo greaterThan bar fields.foo.greaterThan(bar) greaterThanOrEqual gte fields.foo gte bar fields.foo greaterThanOrEqual bar fields.foo.greaterThanOrEqual(bar) between btw fields.foo btw Pair(bar1, bar2) fields.foo between Pair(bar1, bar2) fields.foo.between(bar1, bar2) like fields.foo like bar fields.foo.like(bar) notLike fields.foo notLike bar fields.foo.notLike(bar) isIn `in` fields.foo `in` bars fields.foo isIn bars fields.foo.isIn(bars) notIn `!in` fields.foo `!in` bars fields.foo notIn bars fields.foo.notIn(bars) Aggregate Functions Name Examples avg fields.foo.avg() fields.foo.avg(groupByColumns) fields.foo.avg(groupByColumns, sortDirection) count fields.foo.count() max fields.foo.max() fields.foo.max(groupByColumns) fields.foo.max(groupByColumns, sortDirection) min fields.foo.min() fields.foo.min(groupByColumns) fields.foo.min(groupByColumns, sortDirection) sum fields.foo.sum() fields.foo.sum(groupByColumns) fields.foo.sum(groupByColumns, sortDirection) Sorting Sorting is defined using the orderBy function. Both custom fields and standard attributes are supported, while aliases for standard attributes are provided for convenience: val criteria = bookConditions { // settings and criteria... // sorting orderBy { // Sort by standard attribute alias, same as // Sort.VaultStateAttribute.RECORDED_TIME sort ASC recordedTime sort ASC // Sort by custom field fields . title sort DESC } } The following standard attribute aliases are provided: Alias Standard Attribute stateRef Sort.CommonStateAttribute.STATE_REF stateRefTxnId Sort.CommonStateAttribute.STATE_REF_TXN_ID stateRefIndex Sort.CommonStateAttribute.STATE_REF_INDEX notaryName Sort.VaultStateAttribute.NOTARY_NAME contractStateType Sort.VaultStateAttribute.CONTRACT_STATE_TYPE stateStatus Sort.VaultStateAttribute.STATE_STATUS recordedTime Sort.VaultStateAttribute.RECORDED_TIME consumedTime Sort.VaultStateAttribute.CONSUMED_TIME lockId Sort.VaultStateAttribute.LOCK_ID constraintType Sort.VaultStateAttribute.CONSTRAINT_TYPE uuid Sort.LinearStateAttribute.UUID externalId Sort.LinearStateAttribute.EXTERNAL_ID quantity Sort.FungibleStateAttribute.QUANTITY issuerRef Sort.FungibleStateAttribute.ISSUER_REF","title":"Query DSL"},{"location":"query-dsl/#query-dsl","text":"Vaultaire uses an annotation processor at build-time to create a query DSL for your contract/persistent states.","title":"Query DSL"},{"location":"query-dsl/#quick-example","text":"Consider the following Contract/Persistent States: /** Book ContractState */ data class BookState ( val publisher : Party , val author : Party , val title : String , val published : Date = Date () ) : ContractState , QueryableState { // ... } // Use Vaultaire s code generation! @VaultaireGenerate ( name = booksQuery , contractStateType = BookState :: class ) @Entity @Table ( name = books ) data class PersistentBookState ( @Column ( name = publisher ) var publisher : String = , @Column ( name = author ) var author : String = , @Column ( name = title ) var title : String = , @Column ( name = published ) var published : Date ) : PersistentState ()","title":"Quick Example"},{"location":"query-dsl/#before-vaultaire","text":"Before Vaultaire, you probably had to create query criteria with something like: val query = VaultQueryCriteria ( contractStateTypes = setOf ( BookState :: class . java ), status = Vault . StateStatus . ALL ) // Check publisher? if ( checkPublisher ) query = query . and ( VaultCustomQueryCriteria ( PersistentBookState :: publisher . equal ( Corda Books Ltd. ))) // Add more criteria query . and ( VaultCustomQueryCriteria ( PersistentBookState :: title . equal ( A book on Corda )) . or ( VaultCustomQueryCriteria ( PersistentBookState :: author . notEqual ( John Doe )))) val sort = Sort ( listOf ( Sort . SortColumn ( SortAttribute . Custom ( PersistentBookState :: class . java , published ), Sort . Direction . DESC ))) // Finally! queryBy ( query , sort ) A bit verbose so get s difficult to read as the query becomes more complex. Let s try to simplify things bellow.","title":"Before Vaultaire"},{"location":"query-dsl/#with-vaultaire-dsl","text":"With Vaultaire s @VaultaireGenerate and the generated DSL this becomes: // Use the generated DSL to create query criteria val query = booksQuery { status = Vault . StateStatus . ALL and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` Corda Books Ltd. or { fields . title ` == ` A book on Corda fields . author ` != ` John Doe } } orderBy { fields . title sort DESC } }. toCriteria () queryBy ( query . toCriteria (), query . toSort ())","title":"With Vaultaire DSL"},{"location":"query-dsl/#create-a-dsl","text":"","title":"Create a DSL"},{"location":"query-dsl/#project-module-states","text":"To create a query DSL for your state after installing Vaultaire, annotate the corresponding PersistentState with @VaultaireGenerate : // Use Vaultaire s DSL generation! @VaultaireGenerate ( // If you omit the name, the DSL function will be named by appending Query // to the decapitalized contract state name, e.g. bookStateQuery name = booksQuery , contractStateType = BookState :: class ) @Entity @Table ( name = books ) data class PersistentBookState ( // state properties... ) : PersistentState ()","title":"Project Module States"},{"location":"query-dsl/#project-dependency-states","text":"To create a query DSL for a state from your project dependencies, annotate the any class in your project using the special @VaultaireGenerateFor annotation, providing the state s ContractState and PersistentState : @VaultaireGenerateForDependency ( name = fungibleTokenConditions , persistentStateType = PersistentFungibleToken :: class , contractStateType = FungibleToken :: class ) class Fungible","title":"Project Dependency States"},{"location":"query-dsl/#query-settings","text":"The generated DSL allows setting QueryCriteria.VaultQueryCriteria members. Here s an example using the defaults: val query = booksQuery { // settings status = Vault . StateStatus . UNCONSUMED stateRefs = null notary = null softLockingCondition = null timeCondition = null relevancyStatus = Vault . RelevancyStatus . ALL constraintTypes = emptySet () constraints = emptySet () participants = null // criteria and sorting... }","title":"Query Settings"},{"location":"query-dsl/#adding-criteria","text":"Query riteria are defined within the and / or functions. Both functions can be nested and mixed with criteria like: val query = booksQuery { // settings... // criteria or { // Match at least one fields . foo1 ` == ` someValue and { // Match all fields . foo1 . isNull () fields . foo2 ` == ` someOtherValue and { // ... } or { // ... } } } // sorting... }","title":"Adding Criteria"},{"location":"query-dsl/#adding-aggregates","text":"Aggregates can be specified within the and / or functions: val bookStateQuery = bookStateQuery { // settings... // criteria and { fields . title `like` %Corda Foundation% fields . genre ` == ` BookContract . BookGenre . SCIENCE_FICTION } // aggregates aggregate { // add some aggregates fields . externalId . count () fields . id . count () fields . editions . sum () fields . price . min () fields . price . avg () fields . price . max () } } Note : Corda paged queries can include either query results or other results based on the above aggregates. For that purpose, the toCriteria functions accepts an optional boolean to ignore aggregates, thus allowing the reuse of the same query to obtain either paged state or aggregate results.","title":"Adding Aggregates"},{"location":"query-dsl/#accessing-fields","text":"Fields can be accessed via the generated DSL s fields object within and , or , or orderBy functions using dot notation e.g. fields.foo . You can also retrieve fields by name with e.g. fields[\"foo\"] or fields.get(\"foo\") and use non typesafe functions like _equal , _notEqual , _like , _notLike but this may change in a future release.","title":"Accessing Fields"},{"location":"query-dsl/#functions-and-operators","text":"Name Aliases Examples isNull fields.foo.isNull() notNull fields.foo.notNull() equal `==` fields.foo `==` bar fields.foo equal bar fields.foo.equal(bar) notEqual `!=` fields.foo `!=` bar fields.foo notEqual bar fields.foo.notEqual(bar) lessThan lt fields.foo lt bar fields.foo lessThan bar fields.foo.lessThan(bar) lessThanOrEqual lte fields.foo lte bar fields.foo lessThanOrEqual bar fields.foo.lessThanOrEqual(bar) greaterThan gt fields.foo gt bar fields.foo greaterThan bar fields.foo.greaterThan(bar) greaterThanOrEqual gte fields.foo gte bar fields.foo greaterThanOrEqual bar fields.foo.greaterThanOrEqual(bar) between btw fields.foo btw Pair(bar1, bar2) fields.foo between Pair(bar1, bar2) fields.foo.between(bar1, bar2) like fields.foo like bar fields.foo.like(bar) notLike fields.foo notLike bar fields.foo.notLike(bar) isIn `in` fields.foo `in` bars fields.foo isIn bars fields.foo.isIn(bars) notIn `!in` fields.foo `!in` bars fields.foo notIn bars fields.foo.notIn(bars)","title":"Functions and Operators"},{"location":"query-dsl/#aggregate-functions","text":"Name Examples avg fields.foo.avg() fields.foo.avg(groupByColumns) fields.foo.avg(groupByColumns, sortDirection) count fields.foo.count() max fields.foo.max() fields.foo.max(groupByColumns) fields.foo.max(groupByColumns, sortDirection) min fields.foo.min() fields.foo.min(groupByColumns) fields.foo.min(groupByColumns, sortDirection) sum fields.foo.sum() fields.foo.sum(groupByColumns) fields.foo.sum(groupByColumns, sortDirection)","title":"Aggregate Functions"},{"location":"query-dsl/#sorting","text":"Sorting is defined using the orderBy function. Both custom fields and standard attributes are supported, while aliases for standard attributes are provided for convenience: val criteria = bookConditions { // settings and criteria... // sorting orderBy { // Sort by standard attribute alias, same as // Sort.VaultStateAttribute.RECORDED_TIME sort ASC recordedTime sort ASC // Sort by custom field fields . title sort DESC } } The following standard attribute aliases are provided: Alias Standard Attribute stateRef Sort.CommonStateAttribute.STATE_REF stateRefTxnId Sort.CommonStateAttribute.STATE_REF_TXN_ID stateRefIndex Sort.CommonStateAttribute.STATE_REF_INDEX notaryName Sort.VaultStateAttribute.NOTARY_NAME contractStateType Sort.VaultStateAttribute.CONTRACT_STATE_TYPE stateStatus Sort.VaultStateAttribute.STATE_STATUS recordedTime Sort.VaultStateAttribute.RECORDED_TIME consumedTime Sort.VaultStateAttribute.CONSUMED_TIME lockId Sort.VaultStateAttribute.LOCK_ID constraintType Sort.VaultStateAttribute.CONSTRAINT_TYPE uuid Sort.LinearStateAttribute.UUID externalId Sort.LinearStateAttribute.EXTERNAL_ID quantity Sort.FungibleStateAttribute.QUANTITY issuerRef Sort.FungibleStateAttribute.ISSUER_REF","title":"Sorting"},{"location":"state-services/","text":"State Services Vaultaire s state services provide a simple API for DAO-style loading, querying and event tracking of vault states. State services will help you decouple your your components from Corda s ServiceHub and CordaRPCOps and reuse them both in and/or out of a Corda node. Generated State Service Vaultaire s annotation processor will automatically subclass ExtendedStateService to generate an Fields aware state service service per annotated element. The generated service name is ${contractStateTypeName}Service . Usage example: // Create an instance of the generated service type val bookStateService = BookStateService ( serviceHub , // Service hub or RPC ops serviceDefaults ) // Optional: criteria, paging, sort defaults // Load a book bookStateService . getByLinearId ( identifier ) // Try finding one by ISBN bookStateService . findByExternalId ( identifier ) // query the vault for books val searchResults = bookStateService . queryBy ( criteria , paging , Pair ( published , DESC ), Pair ( title , DESC )) You can see the basic state services API for details. Custom Services You can also subclass BasicStateService , ExtendedStateService or even generated service types to create custom components. /** Extend the generated [BookStateService] */ class MyExtendedBookStateService ( delegate : StateServiceDelegate BookState ) : BookStateService ( delegate ){ // Add the appropriate constructors // to initialize per delegate type: /** [CordaRPCOps]-based constructor */ constructor ( rpcOps : CordaRPCOps , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceRpcDelegate ( rpcOps , BookState :: class . java , defaults )) /** [ServiceHub]-based constructor */ constructor ( serviceHub : ServiceHub , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceHubDelegate ( serviceHub , BookState :: class . java , defaults )) // Custom business methods... }","title":"State Services"},{"location":"state-services/#state-services","text":"Vaultaire s state services provide a simple API for DAO-style loading, querying and event tracking of vault states. State services will help you decouple your your components from Corda s ServiceHub and CordaRPCOps and reuse them both in and/or out of a Corda node.","title":"State Services"},{"location":"state-services/#generated-state-service","text":"Vaultaire s annotation processor will automatically subclass ExtendedStateService to generate an Fields aware state service service per annotated element. The generated service name is ${contractStateTypeName}Service . Usage example: // Create an instance of the generated service type val bookStateService = BookStateService ( serviceHub , // Service hub or RPC ops serviceDefaults ) // Optional: criteria, paging, sort defaults // Load a book bookStateService . getByLinearId ( identifier ) // Try finding one by ISBN bookStateService . findByExternalId ( identifier ) // query the vault for books val searchResults = bookStateService . queryBy ( criteria , paging , Pair ( published , DESC ), Pair ( title , DESC )) You can see the basic state services API for details.","title":"Generated State Service"},{"location":"state-services/#custom-services","text":"You can also subclass BasicStateService , ExtendedStateService or even generated service types to create custom components. /** Extend the generated [BookStateService] */ class MyExtendedBookStateService ( delegate : StateServiceDelegate BookState ) : BookStateService ( delegate ){ // Add the appropriate constructors // to initialize per delegate type: /** [CordaRPCOps]-based constructor */ constructor ( rpcOps : CordaRPCOps , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceRpcDelegate ( rpcOps , BookState :: class . java , defaults )) /** [ServiceHub]-based constructor */ constructor ( serviceHub : ServiceHub , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceHubDelegate ( serviceHub , BookState :: class . java , defaults )) // Custom business methods... }","title":"Custom Services"},{"location":"0.x/","text":"Packages Name Summary com.github.manosbatsis.vaultaire.annotation com.github.manosbatsis.vaultaire.dsl.contract com.github.manosbatsis.vaultaire.dsl.query com.github.manosbatsis.vaultaire.dto com.github.manosbatsis.vaultaire.registry com.github.manosbatsis.vaultaire.rpc com.github.manosbatsis.vaultaire.service com.github.manosbatsis.vaultaire.service.dao com.github.manosbatsis.vaultaire.service.node com.github.manosbatsis.vaultaire.util Index All Types","title":"Home"},{"location":"0.x/#packages","text":"Name Summary com.github.manosbatsis.vaultaire.annotation com.github.manosbatsis.vaultaire.dsl.contract com.github.manosbatsis.vaultaire.dsl.query com.github.manosbatsis.vaultaire.dto com.github.manosbatsis.vaultaire.registry com.github.manosbatsis.vaultaire.rpc com.github.manosbatsis.vaultaire.service com.github.manosbatsis.vaultaire.service.dao com.github.manosbatsis.vaultaire.service.node com.github.manosbatsis.vaultaire.util","title":"Packages"},{"location":"0.x/#index","text":"All Types","title":"Index"},{"location":"0.x/alltypes/","text":"All Types Name Summary com.github.manosbatsis.vaultaire.dsl.query.Aggregates Used to define aggregation criteria com.github.manosbatsis.vaultaire.dsl.query.AndCondition Defines a set of conditions where all items must be matched com.github.manosbatsis.vaultaire.service.node.BasicNodeService Basic NodeService implementation com.github.manosbatsis.vaultaire.service.dao.BasicStateService Basic StateService implementation, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.dsl.query.CompositeCondition A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. com.github.manosbatsis.vaultaire.dsl.query.Condition Condition interface com.github.manosbatsis.vaultaire.dsl.query.ConditionsCondition A Condition that contains other conditions. Allows for nested and/or condition groups com.github.manosbatsis.vaultaire.dsl.contract.ContractConditions com.github.manosbatsis.vaultaire.service.dao.ExtendedStateService Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . com.github.manosbatsis.vaultaire.annotation.ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type com.github.manosbatsis.vaultaire.util.Fields Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type com.github.manosbatsis.vaultaire.util.FieldWrapper com.github.manosbatsis.vaultaire.util.GenericFieldWrapper Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.rpc.NodeRpcConnection Wraps a Corda Node RPC connection proxy com.github.manosbatsis.vaultaire.service.node.NodeService Short-lived helper, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.service.node.NodeServiceDelegate NodeService delegate for vault operations com.github.manosbatsis.vaultaire.service.node.NodeServiceHubDelegate ServiceHub -based NodeServiceDelegate implementation com.github.manosbatsis.vaultaire.service.node.NodeServiceRpcConnectionDelegate NodeRpcConnection -based NodeServiceDelegate implementation com.github.manosbatsis.vaultaire.service.node.NodeServiceRpcDelegate CordaRPCOps -based NodeServiceDelegate implementation com.github.manosbatsis.vaultaire.service.node.NodeServiceRpcDelegateBase RPC implementation base com.github.manosbatsis.vaultaire.util.NullableGenericFieldWrapper Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.dsl.query.OrCondition Defines a set of conditions where at least a single item must be matched com.github.manosbatsis.vaultaire.registry.Registry com.github.manosbatsis.vaultaire.dsl.query.RootCondition com.github.manosbatsis.vaultaire.service.ServiceDefaults Define option defaults for StateService instances com.github.manosbatsis.vaultaire.dsl.query.SortColumns Used to define Sort.SortColumn s com.github.manosbatsis.vaultaire.service.node.StateNotFoundException com.github.manosbatsis.vaultaire.service.dao.StateService Short-lived helper, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.service.dao.StateServiceDelegate StateService delegate for vault operations com.github.manosbatsis.vaultaire.service.dao.StateServiceHubDelegate ServiceHub -based StateServiceDelegate implementation com.github.manosbatsis.vaultaire.service.dao.StateServiceRpcConnectionDelegate NodeRpcConnection -based StateServiceDelegate implementation com.github.manosbatsis.vaultaire.service.dao.StateServiceRpcDelegate CordaRPCOps -based StateServiceDelegate implementation kotlin.String (extensions in package com.github.manosbatsis.vaultaire.util) com.github.manosbatsis.vaultaire.dsl.query.TimeConsumedCondition com.github.manosbatsis.vaultaire.dsl.query.TimeInstantTypeCondition com.github.manosbatsis.vaultaire.dsl.query.TimeRecordedCondition com.github.manosbatsis.vaultaire.util.TypedFieldWrapper Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.annotation.VaultaireDependencyAnnotationConvention com.github.manosbatsis.vaultaire.annotation.VaultaireDtoStrategyKeys com.github.manosbatsis.vaultaire.annotation.VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateResponder Generate a responser flow that extends the given type. com.github.manosbatsis.vaultaire.dto.VaultaireLiteDto Modeled after com.github.manosbatsis.kotlin.utils.api.Dto only bringing a StateService in-context for toTargetType and toPatched . com.github.manosbatsis.vaultaire.dsl.query.VaultCustomQueryCriteriaWrapperCondition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. com.github.manosbatsis.vaultaire.dsl.query.VaultQueryCriteriaCondition A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort com.github.manosbatsis.vaultaire.dsl.contract.When","title":"Home"},{"location":"0.x/alltypes/#all-types","text":"Name Summary com.github.manosbatsis.vaultaire.dsl.query.Aggregates Used to define aggregation criteria com.github.manosbatsis.vaultaire.dsl.query.AndCondition Defines a set of conditions where all items must be matched com.github.manosbatsis.vaultaire.service.node.BasicNodeService Basic NodeService implementation com.github.manosbatsis.vaultaire.service.dao.BasicStateService Basic StateService implementation, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.dsl.query.CompositeCondition A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. com.github.manosbatsis.vaultaire.dsl.query.Condition Condition interface com.github.manosbatsis.vaultaire.dsl.query.ConditionsCondition A Condition that contains other conditions. Allows for nested and/or condition groups com.github.manosbatsis.vaultaire.dsl.contract.ContractConditions com.github.manosbatsis.vaultaire.service.dao.ExtendedStateService Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . com.github.manosbatsis.vaultaire.annotation.ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type com.github.manosbatsis.vaultaire.util.Fields Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type com.github.manosbatsis.vaultaire.util.FieldWrapper com.github.manosbatsis.vaultaire.util.GenericFieldWrapper Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.rpc.NodeRpcConnection Wraps a Corda Node RPC connection proxy com.github.manosbatsis.vaultaire.service.node.NodeService Short-lived helper, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.service.node.NodeServiceDelegate NodeService delegate for vault operations com.github.manosbatsis.vaultaire.service.node.NodeServiceHubDelegate ServiceHub -based NodeServiceDelegate implementation com.github.manosbatsis.vaultaire.service.node.NodeServiceRpcConnectionDelegate NodeRpcConnection -based NodeServiceDelegate implementation com.github.manosbatsis.vaultaire.service.node.NodeServiceRpcDelegate CordaRPCOps -based NodeServiceDelegate implementation com.github.manosbatsis.vaultaire.service.node.NodeServiceRpcDelegateBase RPC implementation base com.github.manosbatsis.vaultaire.util.NullableGenericFieldWrapper Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.dsl.query.OrCondition Defines a set of conditions where at least a single item must be matched com.github.manosbatsis.vaultaire.registry.Registry com.github.manosbatsis.vaultaire.dsl.query.RootCondition com.github.manosbatsis.vaultaire.service.ServiceDefaults Define option defaults for StateService instances com.github.manosbatsis.vaultaire.dsl.query.SortColumns Used to define Sort.SortColumn s com.github.manosbatsis.vaultaire.service.node.StateNotFoundException com.github.manosbatsis.vaultaire.service.dao.StateService Short-lived helper, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.service.dao.StateServiceDelegate StateService delegate for vault operations com.github.manosbatsis.vaultaire.service.dao.StateServiceHubDelegate ServiceHub -based StateServiceDelegate implementation com.github.manosbatsis.vaultaire.service.dao.StateServiceRpcConnectionDelegate NodeRpcConnection -based StateServiceDelegate implementation com.github.manosbatsis.vaultaire.service.dao.StateServiceRpcDelegate CordaRPCOps -based StateServiceDelegate implementation kotlin.String (extensions in package com.github.manosbatsis.vaultaire.util) com.github.manosbatsis.vaultaire.dsl.query.TimeConsumedCondition com.github.manosbatsis.vaultaire.dsl.query.TimeInstantTypeCondition com.github.manosbatsis.vaultaire.dsl.query.TimeRecordedCondition com.github.manosbatsis.vaultaire.util.TypedFieldWrapper Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.annotation.VaultaireDependencyAnnotationConvention com.github.manosbatsis.vaultaire.annotation.VaultaireDtoStrategyKeys com.github.manosbatsis.vaultaire.annotation.VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateResponder Generate a responser flow that extends the given type. com.github.manosbatsis.vaultaire.dto.VaultaireLiteDto Modeled after com.github.manosbatsis.kotlin.utils.api.Dto only bringing a StateService in-context for toTargetType and toPatched . com.github.manosbatsis.vaultaire.dsl.query.VaultCustomQueryCriteriaWrapperCondition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. com.github.manosbatsis.vaultaire.dsl.query.VaultQueryCriteriaCondition A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort com.github.manosbatsis.vaultaire.dsl.contract.When","title":"All Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/","text":"com.github.manosbatsis.vaultaire.annotation Package com.github.manosbatsis.vaultaire.annotation Types Name Summary VaultaireDependencyAnnotationConvention interface VaultaireDependencyAnnotationConvention VaultaireDtoStrategyKeys object VaultaireDtoStrategyKeys Annotations Name Summary ExtendedStateServiceBean annotation class ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type VaultaireGenerate annotation class VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. VaultaireGenerateDto annotation class VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. VaultaireGenerateDtoForDependency annotation class VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. VaultaireGenerateForDependency annotation class VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. VaultaireGenerateResponder annotation class VaultaireGenerateResponder Generate a responser flow that extends the given type.","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/#package-comgithubmanosbatsisvaultaireannotation","text":"","title":"Package com.github.manosbatsis.vaultaire.annotation"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/#types","text":"Name Summary VaultaireDependencyAnnotationConvention interface VaultaireDependencyAnnotationConvention VaultaireDtoStrategyKeys object VaultaireDtoStrategyKeys","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/#annotations","text":"Name Summary ExtendedStateServiceBean annotation class ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type VaultaireGenerate annotation class VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. VaultaireGenerateDto annotation class VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. VaultaireGenerateDtoForDependency annotation class VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. VaultaireGenerateForDependency annotation class VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. VaultaireGenerateResponder annotation class VaultaireGenerateResponder Generate a responser flow that extends the given type.","title":"Annotations"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/","text":"com.github.manosbatsis.vaultaire.annotation / ExtendedStateServiceBean ExtendedStateServiceBean @Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type Constructors Name Summary init ExtendedStateServiceBean() Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/#extendedstateservicebean","text":"@Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":"ExtendedStateServiceBean"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/#constructors","text":"Name Summary init ExtendedStateServiceBean() Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / ExtendedStateServiceBean / init init ExtendedStateServiceBean() Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/-init-/#init","text":"ExtendedStateServiceBean() Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDependencyAnnotationConvention VaultaireDependencyAnnotationConvention interface VaultaireDependencyAnnotationConvention Properties Name Summary contractStateType abstract val contractStateType: KClass out ContractState persistentStateType abstract val persistentStateType: KClass out PersistentState","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/#vaultairedependencyannotationconvention","text":"interface VaultaireDependencyAnnotationConvention","title":"VaultaireDependencyAnnotationConvention"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/#properties","text":"Name Summary contractStateType abstract val contractStateType: KClass out ContractState persistentStateType abstract val persistentStateType: KClass out PersistentState","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDependencyAnnotationConvention / contractStateType contractStateType abstract val contractStateType: KClass out ContractState","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/contract-state-type/#contractstatetype","text":"abstract val contractStateType: KClass out ContractState","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/persistent-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDependencyAnnotationConvention / persistentStateType persistentStateType abstract val persistentStateType: KClass out PersistentState","title":"Persistent state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/persistent-state-type/#persistentstatetype","text":"abstract val persistentStateType: KClass out PersistentState","title":"persistentStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys VaultaireDtoStrategyKeys object VaultaireDtoStrategyKeys Properties Name Summary DEFAULT const val DEFAULT: String LITE const val LITE: String","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/#vaultairedtostrategykeys","text":"object VaultaireDtoStrategyKeys","title":"VaultaireDtoStrategyKeys"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/#properties","text":"Name Summary DEFAULT const val DEFAULT: String LITE const val LITE: String","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-d-e-f-a-u-l-t/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys / DEFAULT DEFAULT const val DEFAULT: String","title":" d e f a u l t"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-d-e-f-a-u-l-t/#default","text":"const val DEFAULT: String","title":"DEFAULT"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-l-i-t-e/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys / LITE LITE const val LITE: String","title":" l i t e"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-l-i-t-e/#lite","text":"const val LITE: String","title":"LITE"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerate VaultaireGenerate @Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. Constructors Name Summary init VaultaireGenerate(name: String = \"\", contractStateType: KClass out ContractState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. Properties Name Summary contractStateType val contractStateType: KClass out ContractState name val name: String","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/#vaultairegenerate","text":"@Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor.","title":"VaultaireGenerate"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/#constructors","text":"Name Summary init VaultaireGenerate(name: String = \"\", contractStateType: KClass out ContractState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/#properties","text":"Name Summary contractStateType val contractStateType: KClass out ContractState name val name: String","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerate / init init VaultaireGenerate(name: String = \"\", contractStateType: KClass out ContractState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/-init-/#init","text":"VaultaireGenerate(name: String = \"\", contractStateType: KClass out ContractState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerate / contractStateType contractStateType val contractStateType: KClass out ContractState","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/contract-state-type/#contractstatetype","text":"val contractStateType: KClass out ContractState","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/name/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerate / name name val name: String","title":"Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/name/#name","text":"val name: String","title":"name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDto VaultaireGenerateDto @Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. Constructors Name Summary init VaultaireGenerateDto(ignoreProperties: Array String = [], copyAnnotationPackages: Array String = [], strategies: Array String = [VaultaireDtoStrategyKeys.DEFAULT]) Generate a DTO for the annotated ContractState class or constructor. Properties Name Summary copyAnnotationPackages val copyAnnotationPackages: Array String ignoreProperties val ignoreProperties: Array String strategies val strategies: Array String","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/#vaultairegeneratedto","text":"@Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor.","title":"VaultaireGenerateDto"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/#constructors","text":"Name Summary init VaultaireGenerateDto(ignoreProperties: Array String = [], copyAnnotationPackages: Array String = [], strategies: Array String = [VaultaireDtoStrategyKeys.DEFAULT]) Generate a DTO for the annotated ContractState class or constructor.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/#properties","text":"Name Summary copyAnnotationPackages val copyAnnotationPackages: Array String ignoreProperties val ignoreProperties: Array String strategies val strategies: Array String","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDto / init init VaultaireGenerateDto(ignoreProperties: Array String = [], copyAnnotationPackages: Array String = [], strategies: Array String = [VaultaireDtoStrategyKeys.DEFAULT]) Generate a DTO for the annotated ContractState class or constructor.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/-init-/#init","text":"VaultaireGenerateDto(ignoreProperties: Array String = [], copyAnnotationPackages: Array String = [], strategies: Array String = [VaultaireDtoStrategyKeys.DEFAULT]) Generate a DTO for the annotated ContractState class or constructor.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/copy-annotation-packages/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDto / copyAnnotationPackages copyAnnotationPackages val copyAnnotationPackages: Array String","title":"Copy annotation packages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/copy-annotation-packages/#copyannotationpackages","text":"val copyAnnotationPackages: Array String","title":"copyAnnotationPackages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/ignore-properties/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDto / ignoreProperties ignoreProperties val ignoreProperties: Array String","title":"Ignore properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/ignore-properties/#ignoreproperties","text":"val ignoreProperties: Array String","title":"ignoreProperties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/strategies/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDto / strategies strategies val strategies: Array String","title":"Strategies"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/strategies/#strategies","text":"val strategies: Array String","title":"strategies"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency VaultaireGenerateDtoForDependency @Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. Constructors Name Summary init VaultaireGenerateDtoForDependency(ignoreProperties: Array String = [], contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState , copyAnnotationPackages: Array String = [], strategies: Array String = [VaultaireDtoStrategyKeys.DEFAULT]) Generate a DTO for the ContractState of a project dependency. Properties Name Summary contractStateType val contractStateType: KClass out ContractState copyAnnotationPackages val copyAnnotationPackages: Array String ignoreProperties val ignoreProperties: Array String persistentStateType val persistentStateType: KClass out PersistentState strategies val strategies: Array String","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/#vaultairegeneratedtofordependency","text":"@Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency.","title":"VaultaireGenerateDtoForDependency"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/#constructors","text":"Name Summary init VaultaireGenerateDtoForDependency(ignoreProperties: Array String = [], contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState , copyAnnotationPackages: Array String = [], strategies: Array String = [VaultaireDtoStrategyKeys.DEFAULT]) Generate a DTO for the ContractState of a project dependency.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/#properties","text":"Name Summary contractStateType val contractStateType: KClass out ContractState copyAnnotationPackages val copyAnnotationPackages: Array String ignoreProperties val ignoreProperties: Array String persistentStateType val persistentStateType: KClass out PersistentState strategies val strategies: Array String","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / init init VaultaireGenerateDtoForDependency(ignoreProperties: Array String = [], contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState , copyAnnotationPackages: Array String = [], strategies: Array String = [VaultaireDtoStrategyKeys.DEFAULT]) Generate a DTO for the ContractState of a project dependency.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/-init-/#init","text":"VaultaireGenerateDtoForDependency(ignoreProperties: Array String = [], contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState , copyAnnotationPackages: Array String = [], strategies: Array String = [VaultaireDtoStrategyKeys.DEFAULT]) Generate a DTO for the ContractState of a project dependency.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / contractStateType contractStateType val contractStateType: KClass out ContractState","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/contract-state-type/#contractstatetype","text":"val contractStateType: KClass out ContractState","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/copy-annotation-packages/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / copyAnnotationPackages copyAnnotationPackages val copyAnnotationPackages: Array String","title":"Copy annotation packages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/copy-annotation-packages/#copyannotationpackages","text":"val copyAnnotationPackages: Array String","title":"copyAnnotationPackages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/ignore-properties/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / ignoreProperties ignoreProperties val ignoreProperties: Array String","title":"Ignore properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/ignore-properties/#ignoreproperties","text":"val ignoreProperties: Array String","title":"ignoreProperties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/persistent-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / persistentStateType persistentStateType val persistentStateType: KClass out PersistentState","title":"Persistent state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/persistent-state-type/#persistentstatetype","text":"val persistentStateType: KClass out PersistentState","title":"persistentStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/strategies/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / strategies strategies val strategies: Array String","title":"Strategies"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/strategies/#strategies","text":"val strategies: Array String","title":"strategies"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency VaultaireGenerateForDependency @Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. Constructors Name Summary init VaultaireGenerateForDependency(name: String = \"\", contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. Properties Name Summary contractStateType val contractStateType: KClass out ContractState name val name: String persistentStateType val persistentStateType: KClass out PersistentState","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/#vaultairegeneratefordependency","text":"@Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency.","title":"VaultaireGenerateForDependency"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/#constructors","text":"Name Summary init VaultaireGenerateForDependency(name: String = \"\", contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/#properties","text":"Name Summary contractStateType val contractStateType: KClass out ContractState name val name: String persistentStateType val persistentStateType: KClass out PersistentState","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency / init init VaultaireGenerateForDependency(name: String = \"\", contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/-init-/#init","text":"VaultaireGenerateForDependency(name: String = \"\", contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency / contractStateType contractStateType val contractStateType: KClass out ContractState","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/contract-state-type/#contractstatetype","text":"val contractStateType: KClass out ContractState","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/name/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency / name name val name: String","title":"Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/name/#name","text":"val name: String","title":"name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/persistent-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency / persistentStateType persistentStateType val persistentStateType: KClass out PersistentState","title":"Persistent state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/persistent-state-type/#persistentstatetype","text":"val persistentStateType: KClass out PersistentState","title":"persistentStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateResponder VaultaireGenerateResponder @Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateResponder Generate a responser flow that extends the given type. Constructors Name Summary init VaultaireGenerateResponder(value: KClass out FlowLogic * , comment: String = \"\") Generate a responser flow that extends the given type. Properties Name Summary comment val comment: String value val value: KClass out FlowLogic *","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/#vaultairegenerateresponder","text":"@Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateResponder Generate a responser flow that extends the given type.","title":"VaultaireGenerateResponder"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/#constructors","text":"Name Summary init VaultaireGenerateResponder(value: KClass out FlowLogic * , comment: String = \"\") Generate a responser flow that extends the given type.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/#properties","text":"Name Summary comment val comment: String value val value: KClass out FlowLogic *","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateResponder / init init VaultaireGenerateResponder(value: KClass out FlowLogic * , comment: String = \"\") Generate a responser flow that extends the given type.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/-init-/#init","text":"VaultaireGenerateResponder(value: KClass out FlowLogic * , comment: String = \"\") Generate a responser flow that extends the given type.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/comment/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateResponder / comment comment val comment: String","title":"Comment"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/comment/#comment","text":"val comment: String","title":"comment"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/value/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateResponder / value value val value: KClass out FlowLogic *","title":"Value"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/value/#value","text":"val value: KClass out FlowLogic *","title":"value"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/","text":"com.github.manosbatsis.vaultaire.dsl.contract Package com.github.manosbatsis.vaultaire.dsl.contract Types Name Summary ContractConditions abstract class ContractConditions When class When","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/#package-comgithubmanosbatsisvaultairedslcontract","text":"","title":"Package com.github.manosbatsis.vaultaire.dsl.contract"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/#types","text":"Name Summary ContractConditions abstract class ContractConditions When class When","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions ContractConditions abstract class ContractConditions Constructors Name Summary init ContractConditions(tx: LedgerTransaction) Properties Name Summary commandTypes abstract val commandTypes: Any fields abstract val T : ContractState InOutGroup T , * .fields: Fields T groups abstract val groups: Any roles abstract val roles: Any stateTypeFields abstract val stateTypeFields: Any stateTypes abstract val stateTypes: Any tx val tx: LedgerTransaction","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/#contractconditions","text":"abstract class ContractConditions","title":"ContractConditions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/#constructors","text":"Name Summary init ContractConditions(tx: LedgerTransaction)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/#properties","text":"Name Summary commandTypes abstract val commandTypes: Any fields abstract val T : ContractState InOutGroup T , * .fields: Fields T groups abstract val groups: Any roles abstract val roles: Any stateTypeFields abstract val stateTypeFields: Any stateTypes abstract val stateTypes: Any tx val tx: LedgerTransaction","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / init init ContractConditions(tx: LedgerTransaction)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/-init-/#init","text":"ContractConditions(tx: LedgerTransaction)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/command-types/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / commandTypes commandTypes abstract val commandTypes: Any","title":"Command types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/command-types/#commandtypes","text":"abstract val commandTypes: Any","title":"commandTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/fields/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / fields fields abstract val T : ContractState InOutGroup T , * .fields: Fields T","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/fields/#fields","text":"abstract val T : ContractState InOutGroup T , * .fields: Fields T","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/groups/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / groups groups abstract val groups: Any","title":"Groups"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/groups/#groups","text":"abstract val groups: Any","title":"groups"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/roles/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / roles roles abstract val roles: Any","title":"Roles"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/roles/#roles","text":"abstract val roles: Any","title":"roles"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-type-fields/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / stateTypeFields stateTypeFields abstract val stateTypeFields: Any","title":"State type fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-type-fields/#statetypefields","text":"abstract val stateTypeFields: Any","title":"stateTypeFields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-types/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / stateTypes stateTypes abstract val stateTypes: Any","title":"State types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-types/#statetypes","text":"abstract val stateTypes: Any","title":"stateTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/tx/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / tx tx val tx: LedgerTransaction","title":"Tx"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/tx/#tx","text":"val tx: LedgerTransaction","title":"tx"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/","text":"com.github.manosbatsis.vaultaire.dsl.contract / When When class When Constructors Name Summary init When(vararg conditions: Boolean)","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/#when","text":"class When","title":"When"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/#constructors","text":"Name Summary init When(vararg conditions: Boolean)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.contract / When / init init When(vararg conditions: Boolean)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/-init-/#init","text":"When(vararg conditions: Boolean)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/","text":"com.github.manosbatsis.vaultaire.dsl.query Package com.github.manosbatsis.vaultaire.dsl.query Types Name Summary Aggregates class Aggregates P : StatePersistable Used to define aggregation criteria AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Condition interface Condition Condition interface ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched RootCondition interface RootCondition P : StatePersistable : Condition SortColumns class SortColumns P : StatePersistable Used to define Sort.SortColumn s TimeConsumedCondition class TimeConsumedCondition : TimeInstantTypeCondition TimeInstantTypeCondition abstract class TimeInstantTypeCondition TimeRecordedCondition class TimeRecordedCondition : TimeInstantTypeCondition VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/#package-comgithubmanosbatsisvaultairedslquery","text":"","title":"Package com.github.manosbatsis.vaultaire.dsl.query"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/#types","text":"Name Summary Aggregates class Aggregates P : StatePersistable Used to define aggregation criteria AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Condition interface Condition Condition interface ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched RootCondition interface RootCondition P : StatePersistable : Condition SortColumns class SortColumns P : StatePersistable Used to define Sort.SortColumn s TimeConsumedCondition class TimeConsumedCondition : TimeInstantTypeCondition TimeInstantTypeCondition abstract class TimeInstantTypeCondition TimeRecordedCondition class TimeRecordedCondition : TimeInstantTypeCondition VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates Aggregates class Aggregates P : StatePersistable Used to define aggregation criteria Constructors Name Summary init Aggregates(rootCondition: RootCondition P ) Used to define aggregation criteria Properties Name Summary rootCondition val rootCondition: RootCondition P Functions Name Summary avg fun S : Comparable S TypedFieldWrapper P , S .avg(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean count fun FieldWrapper P .count(): Boolean max fun S : Comparable S TypedFieldWrapper P , S .max(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean min fun S : Comparable S TypedFieldWrapper P , S .min(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean sum fun S : Comparable S TypedFieldWrapper P , S .sum(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#aggregates","text":"class Aggregates P : StatePersistable Used to define aggregation criteria","title":"Aggregates"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#constructors","text":"Name Summary init Aggregates(rootCondition: RootCondition P ) Used to define aggregation criteria","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#properties","text":"Name Summary rootCondition val rootCondition: RootCondition P","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#functions","text":"Name Summary avg fun S : Comparable S TypedFieldWrapper P , S .avg(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean count fun FieldWrapper P .count(): Boolean max fun S : Comparable S TypedFieldWrapper P , S .max(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean min fun S : Comparable S TypedFieldWrapper P , S .min(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean sum fun S : Comparable S TypedFieldWrapper P , S .sum(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / init init Aggregates(rootCondition: RootCondition P ) Used to define aggregation criteria","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/-init-/#init","text":"Aggregates(rootCondition: RootCondition P ) Used to define aggregation criteria","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/avg/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / avg avg fun S : Comparable S TypedFieldWrapper P , S .avg(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Avg"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/avg/#avg","text":"fun S : Comparable S TypedFieldWrapper P , S .avg(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"avg"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/count/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / count count fun FieldWrapper P .count(): Boolean","title":"Count"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/count/#count","text":"fun FieldWrapper P .count(): Boolean","title":"count"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/max/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / max max fun S : Comparable S TypedFieldWrapper P , S .max(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Max"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/max/#max","text":"fun S : Comparable S TypedFieldWrapper P , S .max(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"max"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/min/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / min min fun S : Comparable S TypedFieldWrapper P , S .min(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Min"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/min/#min","text":"fun S : Comparable S TypedFieldWrapper P , S .min(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"min"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/root-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / rootCondition rootCondition val rootCondition: RootCondition P","title":"Root condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/root-condition/#rootcondition","text":"val rootCondition: RootCondition P","title":"rootCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/sum/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / sum sum fun S : Comparable S TypedFieldWrapper P , S .sum(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Sum"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/sum/#sum","text":"fun S : Comparable S TypedFieldWrapper P , S .sum(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"sum"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / AndCondition AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched Constructors Name Summary init AndCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where all items must be matched Inherited Properties Name Summary fields open val fields: F The fields of the target StatePersistable type P Functions Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inherited Functions Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#andcondition","text":"class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched","title":"AndCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#constructors","text":"Name Summary init AndCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where all items must be matched","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#inherited-properties","text":"Name Summary fields open val fields: F The fields of the target StatePersistable type P","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#functions","text":"Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#inherited-functions","text":"Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / AndCondition / init init AndCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where all items must be matched","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/-init-/#init","text":"AndCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where all items must be matched","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / AndCondition / toCriteria toCriteria fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/to-criteria/#tocriteria","text":"fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Constructors Name Summary init CompositeCondition(fields: F , rootCondition: RootCondition P ) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Properties Name Summary fields open val fields: F The fields of the target StatePersistable type P Functions Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit Inherited Functions Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit Inheritors Name Summary AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#compositecondition","text":"abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":"CompositeCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#constructors","text":"Name Summary init CompositeCondition(fields: F , rootCondition: RootCondition P ) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#properties","text":"Name Summary fields open val fields: F The fields of the target StatePersistable type P","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#functions","text":"Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#inherited-functions","text":"Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#inheritors","text":"Name Summary AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/!=/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / != != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit","title":"!="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/!=/#_1","text":"infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit","title":"!="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/!in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / !in !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit","title":"!in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/!in/#in","text":"fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit","title":"!in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / init init CompositeCondition(fields: F , rootCondition: RootCondition P ) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/-init-/#init","text":"CompositeCondition(fields: F , rootCondition: RootCondition P ) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/==/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / == == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit","title":"=="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/==/#_1","text":"infix fun S TypedFieldWrapper P , S .==(value: S ): Unit","title":"=="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _equal _equal infix fun FieldWrapper P ._equal(value: Any): Unit","title":" equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_equal/#_equal","text":"infix fun FieldWrapper P ._equal(value: Any): Unit","title":"_equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _like _like infix fun FieldWrapper P ._like(value: String): Unit","title":" like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_like/#_like","text":"infix fun FieldWrapper P ._like(value: String): Unit","title":"_like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _notEqual _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit","title":" not equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-equal/#_notequal","text":"infix fun FieldWrapper P ._notEqual(value: Any): Unit","title":"_notEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _notLike _notLike infix fun FieldWrapper P ._notLike(value: String): Unit","title":" not like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-like/#_notlike","text":"infix fun FieldWrapper P ._notLike(value: String): Unit","title":"_notLike"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/as-string-property/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / asStringProperty asStringProperty protected fun FieldWrapper P .asStringProperty(): KProperty1 P , String","title":"As string property"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/as-string-property/#asstringproperty","text":"protected fun FieldWrapper P .asStringProperty(): KProperty1 P , String","title":"asStringProperty"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/between/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / between between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit","title":"Between"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/between/#between","text":"fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit","title":"between"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/btw/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / btw btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit","title":"Btw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/btw/#btw","text":"infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit","title":"btw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / equal equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit","title":"Equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/equal/#equal","text":"infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit","title":"equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/fields/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / fields fields open val fields: F Overrides ConditionsCondition.fields The fields of the target StatePersistable type P","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/fields/#fields","text":"open val fields: F Overrides ConditionsCondition.fields The fields of the target StatePersistable type P","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than-or-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / greaterThanOrEqual greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit","title":"Greater than or equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than-or-equal/#greaterthanorequal","text":"infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit","title":"greaterThanOrEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / greaterThan greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit","title":"Greater than"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than/#greaterthan","text":"infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit","title":"greaterThan"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gt/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / gt gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit","title":"Gt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gt/#gt","text":"infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit","title":"gt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gte/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / gte gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit","title":"Gte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gte/#gte","text":"infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit","title":"gte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / in in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit","title":"In"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/in/#in","text":"infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit","title":"in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / isIn isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit","title":"Is in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-in/#isin","text":"infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit","title":"isIn"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-null/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / isNull isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit","title":"Is null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-null/#isnull","text":"fun S NullableGenericFieldWrapper P , S .isNull(): Unit","title":"isNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than-or-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lessThanOrEqual lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit","title":"Less than or equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than-or-equal/#lessthanorequal","text":"infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit","title":"lessThanOrEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lessThan lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit","title":"Less than"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than/#lessthan","text":"infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit","title":"lessThan"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / like like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit","title":"Like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/like/#like","text":"infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit","title":"like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lt/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lt lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit","title":"Lt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lt/#lt","text":"infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit","title":"lt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lte/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lte lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit","title":"Lte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lte/#lte","text":"infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit","title":"lte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notEqual notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit","title":"Not equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-equal/#notequal","text":"infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit","title":"notEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notIn notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit","title":"Not in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-in/#notin","text":"infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit","title":"notIn"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notLike notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit","title":"Not like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-like/#notlike","text":"infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit","title":"notLike"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-null/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notNull notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Not null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-null/#notnull","text":"fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"notNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / Condition Condition interface Condition Condition interface Functions Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inheritors Name Summary ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups RootCondition interface RootCondition P : StatePersistable : Condition VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/#condition","text":"interface Condition Condition interface","title":"Condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/#functions","text":"Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/#inheritors","text":"Name Summary ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups RootCondition interface RootCondition P : StatePersistable : Condition VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / Condition / toCriteria toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/to-criteria/#tocriteria","text":"abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups Constructors Name Summary init ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups Properties Name Summary fields abstract val fields: F The fields of the target StatePersistable type P Functions Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit Inherited Functions Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inheritors Name Summary CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#conditionscondition","text":"abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups","title":"ConditionsCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#constructors","text":"Name Summary init ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#properties","text":"Name Summary fields abstract val fields: F The fields of the target StatePersistable type P","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#functions","text":"Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#inherited-functions","text":"Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#inheritors","text":"Name Summary CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / init init ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/-init-/#init","text":"ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/add-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / addCondition addCondition fun addCondition(condition: Condition ): Unit","title":"Add condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/add-condition/#addcondition","text":"fun addCondition(condition: Condition ): Unit","title":"addCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/and/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / and and fun and(initializer: CompositeCondition P , F .() - Unit): Unit","title":"And"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/and/#and","text":"fun and(initializer: CompositeCondition P , F .() - Unit): Unit","title":"and"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/fields/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / fields fields abstract val fields: F The fields of the target StatePersistable type P","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/fields/#fields","text":"abstract val fields: F The fields of the target StatePersistable type P","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/or/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / or or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Or"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/or/#or","text":"fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"or"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / OrCondition OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched Constructors Name Summary init OrCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where at least a single item must be matched Inherited Properties Name Summary fields open val fields: F The fields of the target StatePersistable type P Functions Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inherited Functions Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#orcondition","text":"class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched","title":"OrCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#constructors","text":"Name Summary init OrCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where at least a single item must be matched","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#inherited-properties","text":"Name Summary fields open val fields: F The fields of the target StatePersistable type P","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#functions","text":"Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#inherited-functions","text":"Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / OrCondition / init init OrCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where at least a single item must be matched","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/-init-/#init","text":"OrCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where at least a single item must be matched","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / OrCondition / toCriteria toCriteria fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/to-criteria/#tocriteria","text":"fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition RootCondition interface RootCondition P : StatePersistable : Condition Properties Name Summary constraints abstract var constraints: Set ConstraintInfo constraintTypes abstract var constraintTypes: Set Type notary abstract var notary: List AbstractParty ? participants abstract var participants: List AbstractParty ? relevancyStatus abstract var relevancyStatus: RelevancyStatus softLockingCondition abstract var softLockingCondition: SoftLockingCondition? stateRefs abstract var stateRefs: List StateRef ? status abstract var status: StateStatus timeCondition abstract var timeCondition: TimeCondition? Inherited Functions Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inheritors Name Summary VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/#rootcondition","text":"interface RootCondition P : StatePersistable : Condition","title":"RootCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/#properties","text":"Name Summary constraints abstract var constraints: Set ConstraintInfo constraintTypes abstract var constraintTypes: Set Type notary abstract var notary: List AbstractParty ? participants abstract var participants: List AbstractParty ? relevancyStatus abstract var relevancyStatus: RelevancyStatus softLockingCondition abstract var softLockingCondition: SoftLockingCondition? stateRefs abstract var stateRefs: List StateRef ? status abstract var status: StateStatus timeCondition abstract var timeCondition: TimeCondition?","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/#inherited-functions","text":"Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/#inheritors","text":"Name Summary VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/constraint-types/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / constraintTypes constraintTypes abstract var constraintTypes: Set Type","title":"Constraint types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/constraint-types/#constrainttypes","text":"abstract var constraintTypes: Set Type","title":"constraintTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/constraints/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / constraints constraints abstract var constraints: Set ConstraintInfo","title":"Constraints"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/constraints/#constraints","text":"abstract var constraints: Set ConstraintInfo","title":"constraints"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/notary/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / notary notary abstract var notary: List AbstractParty ?","title":"Notary"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/notary/#notary","text":"abstract var notary: List AbstractParty ?","title":"notary"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/participants/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / participants participants abstract var participants: List AbstractParty ?","title":"Participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/participants/#participants","text":"abstract var participants: List AbstractParty ?","title":"participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/relevancy-status/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / relevancyStatus relevancyStatus abstract var relevancyStatus: RelevancyStatus","title":"Relevancy status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/relevancy-status/#relevancystatus","text":"abstract var relevancyStatus: RelevancyStatus","title":"relevancyStatus"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/soft-locking-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / softLockingCondition softLockingCondition abstract var softLockingCondition: SoftLockingCondition?","title":"Soft locking condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/soft-locking-condition/#softlockingcondition","text":"abstract var softLockingCondition: SoftLockingCondition?","title":"softLockingCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/state-refs/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / stateRefs stateRefs abstract var stateRefs: List StateRef ?","title":"State refs"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/state-refs/#staterefs","text":"abstract var stateRefs: List StateRef ?","title":"stateRefs"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/status/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / status status abstract var status: StateStatus","title":"Status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/status/#status","text":"abstract var status: StateStatus","title":"status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/time-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / timeCondition timeCondition abstract var timeCondition: TimeCondition?","title":"Time condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/time-condition/#timecondition","text":"abstract var timeCondition: TimeCondition?","title":"timeCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns SortColumns class SortColumns P : StatePersistable Used to define Sort.SortColumn s Constructors Name Summary init SortColumns(statePersistableType: Class P ) Used to define Sort.SortColumn s Properties Name Summary ASC val ASC: Direction constraintType val constraintType: VaultStateAttribute consumedTime val consumedTime: VaultStateAttribute contractStateType val contractStateType: VaultStateAttribute DESC val DESC: Direction entries val entries: LinkedHashSet SortColumn externalId val externalId: LinearStateAttribute issuerRef val issuerRef: FungibleStateAttribute lockId val lockId: VaultStateAttribute notaryName val notaryName: VaultStateAttribute quantity val quantity: FungibleStateAttribute recordedTime val recordedTime: VaultStateAttribute statePersistableType val statePersistableType: Class P stateRef val stateRef: CommonStateAttribute stateRefIndex val stateRefIndex: CommonStateAttribute stateRefTxnId val stateRefTxnId: CommonStateAttribute stateStatus val stateStatus: VaultStateAttribute uuid val uuid: LinearStateAttribute Functions Name Summary sort infix fun CommonStateAttribute.sort(value: Direction): Boolean infix fun FungibleStateAttribute.sort(value: Direction): Boolean infix fun LinearStateAttribute.sort(value: Direction): Boolean infix fun VaultStateAttribute.sort(value: Direction): Boolean infix fun FieldWrapper P .sort(value: Direction): Unit","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#sortcolumns","text":"class SortColumns P : StatePersistable Used to define Sort.SortColumn s","title":"SortColumns"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#constructors","text":"Name Summary init SortColumns(statePersistableType: Class P ) Used to define Sort.SortColumn s","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#properties","text":"Name Summary ASC val ASC: Direction constraintType val constraintType: VaultStateAttribute consumedTime val consumedTime: VaultStateAttribute contractStateType val contractStateType: VaultStateAttribute DESC val DESC: Direction entries val entries: LinkedHashSet SortColumn externalId val externalId: LinearStateAttribute issuerRef val issuerRef: FungibleStateAttribute lockId val lockId: VaultStateAttribute notaryName val notaryName: VaultStateAttribute quantity val quantity: FungibleStateAttribute recordedTime val recordedTime: VaultStateAttribute statePersistableType val statePersistableType: Class P stateRef val stateRef: CommonStateAttribute stateRefIndex val stateRefIndex: CommonStateAttribute stateRefTxnId val stateRefTxnId: CommonStateAttribute stateStatus val stateStatus: VaultStateAttribute uuid val uuid: LinearStateAttribute","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#functions","text":"Name Summary sort infix fun CommonStateAttribute.sort(value: Direction): Boolean infix fun FungibleStateAttribute.sort(value: Direction): Boolean infix fun LinearStateAttribute.sort(value: Direction): Boolean infix fun VaultStateAttribute.sort(value: Direction): Boolean infix fun FieldWrapper P .sort(value: Direction): Unit","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-a-s-c/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / ASC ASC val ASC: Direction","title":" a s c"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-a-s-c/#asc","text":"val ASC: Direction","title":"ASC"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-d-e-s-c/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / DESC DESC val DESC: Direction","title":" d e s c"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-d-e-s-c/#desc","text":"val DESC: Direction","title":"DESC"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / init init SortColumns(statePersistableType: Class P ) Used to define Sort.SortColumn s","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-init-/#init","text":"SortColumns(statePersistableType: Class P ) Used to define Sort.SortColumn s","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/constraint-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / constraintType constraintType val constraintType: VaultStateAttribute","title":"Constraint type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/constraint-type/#constrainttype","text":"val constraintType: VaultStateAttribute","title":"constraintType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/consumed-time/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / consumedTime consumedTime val consumedTime: VaultStateAttribute","title":"Consumed time"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/consumed-time/#consumedtime","text":"val consumedTime: VaultStateAttribute","title":"consumedTime"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/contract-state-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / contractStateType contractStateType val contractStateType: VaultStateAttribute","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/contract-state-type/#contractstatetype","text":"val contractStateType: VaultStateAttribute","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/entries/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / entries entries val entries: LinkedHashSet SortColumn","title":"Entries"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/entries/#entries","text":"val entries: LinkedHashSet SortColumn","title":"entries"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/external-id/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / externalId externalId val externalId: LinearStateAttribute","title":"External id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/external-id/#externalid","text":"val externalId: LinearStateAttribute","title":"externalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/issuer-ref/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / issuerRef issuerRef val issuerRef: FungibleStateAttribute","title":"Issuer ref"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/issuer-ref/#issuerref","text":"val issuerRef: FungibleStateAttribute","title":"issuerRef"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/lock-id/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / lockId lockId val lockId: VaultStateAttribute","title":"Lock id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/lock-id/#lockid","text":"val lockId: VaultStateAttribute","title":"lockId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/notary-name/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / notaryName notaryName val notaryName: VaultStateAttribute","title":"Notary name"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/notary-name/#notaryname","text":"val notaryName: VaultStateAttribute","title":"notaryName"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/quantity/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / quantity quantity val quantity: FungibleStateAttribute","title":"Quantity"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/quantity/#quantity","text":"val quantity: FungibleStateAttribute","title":"quantity"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/recorded-time/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / recordedTime recordedTime val recordedTime: VaultStateAttribute","title":"Recorded time"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/recorded-time/#recordedtime","text":"val recordedTime: VaultStateAttribute","title":"recordedTime"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/sort/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / sort sort infix fun CommonStateAttribute.sort(value: Direction): Boolean infix fun FungibleStateAttribute.sort(value: Direction): Boolean infix fun LinearStateAttribute.sort(value: Direction): Boolean infix fun VaultStateAttribute.sort(value: Direction): Boolean infix fun FieldWrapper P .sort(value: Direction): Unit","title":"Sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/sort/#sort","text":"infix fun CommonStateAttribute.sort(value: Direction): Boolean infix fun FungibleStateAttribute.sort(value: Direction): Boolean infix fun LinearStateAttribute.sort(value: Direction): Boolean infix fun VaultStateAttribute.sort(value: Direction): Boolean infix fun FieldWrapper P .sort(value: Direction): Unit","title":"sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-persistable-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / statePersistableType statePersistableType val statePersistableType: Class P","title":"State persistable type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-persistable-type/#statepersistabletype","text":"val statePersistableType: Class P","title":"statePersistableType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref-index/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / stateRefIndex stateRefIndex val stateRefIndex: CommonStateAttribute","title":"State ref index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref-index/#staterefindex","text":"val stateRefIndex: CommonStateAttribute","title":"stateRefIndex"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref-txn-id/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / stateRefTxnId stateRefTxnId val stateRefTxnId: CommonStateAttribute","title":"State ref txn id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref-txn-id/#statereftxnid","text":"val stateRefTxnId: CommonStateAttribute","title":"stateRefTxnId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / stateRef stateRef val stateRef: CommonStateAttribute","title":"State ref"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref/#stateref","text":"val stateRef: CommonStateAttribute","title":"stateRef"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-status/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / stateStatus stateStatus val stateStatus: VaultStateAttribute","title":"State status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-status/#statestatus","text":"val stateStatus: VaultStateAttribute","title":"stateStatus"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/uuid/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / uuid uuid val uuid: LinearStateAttribute","title":"Uuid"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/uuid/#uuid","text":"val uuid: LinearStateAttribute","title":"uuid"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeConsumedCondition TimeConsumedCondition class TimeConsumedCondition : TimeInstantTypeCondition Constructors Name Summary init TimeConsumedCondition()","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/#timeconsumedcondition","text":"class TimeConsumedCondition : TimeInstantTypeCondition","title":"TimeConsumedCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/#constructors","text":"Name Summary init TimeConsumedCondition()","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeConsumedCondition / init init TimeConsumedCondition()","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/-init-/#init","text":"TimeConsumedCondition()","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeInstantTypeCondition TimeInstantTypeCondition abstract class TimeInstantTypeCondition Constructors Name Summary init TimeInstantTypeCondition(type: TimeInstantType) Inheritors Name Summary TimeConsumedCondition class TimeConsumedCondition : TimeInstantTypeCondition TimeRecordedCondition class TimeRecordedCondition : TimeInstantTypeCondition","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/#timeinstanttypecondition","text":"abstract class TimeInstantTypeCondition","title":"TimeInstantTypeCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/#constructors","text":"Name Summary init TimeInstantTypeCondition(type: TimeInstantType)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/#inheritors","text":"Name Summary TimeConsumedCondition class TimeConsumedCondition : TimeInstantTypeCondition TimeRecordedCondition class TimeRecordedCondition : TimeInstantTypeCondition","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeInstantTypeCondition / init init TimeInstantTypeCondition(type: TimeInstantType)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/-init-/#init","text":"TimeInstantTypeCondition(type: TimeInstantType)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeRecordedCondition TimeRecordedCondition class TimeRecordedCondition : TimeInstantTypeCondition Constructors Name Summary init TimeRecordedCondition()","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/#timerecordedcondition","text":"class TimeRecordedCondition : TimeInstantTypeCondition","title":"TimeRecordedCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/#constructors","text":"Name Summary init TimeRecordedCondition()","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeRecordedCondition / init init TimeRecordedCondition()","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/-init-/#init","text":"TimeRecordedCondition()","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultCustomQueryCriteriaWrapperCondition VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. Constructors Name Summary init VaultCustomQueryCriteriaWrapperCondition(criterion: VaultCustomQueryCriteria * ) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. Functions Name Summary toCriteria fun toCriteria(): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/#vaultcustomquerycriteriawrappercondition","text":"open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"VaultCustomQueryCriteriaWrapperCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/#constructors","text":"Name Summary init VaultCustomQueryCriteriaWrapperCondition(criterion: VaultCustomQueryCriteria * ) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/#functions","text":"Name Summary toCriteria fun toCriteria(): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultCustomQueryCriteriaWrapperCondition / init init VaultCustomQueryCriteriaWrapperCondition(criterion: VaultCustomQueryCriteria * ) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/-init-/#init","text":"VaultCustomQueryCriteriaWrapperCondition(criterion: VaultCustomQueryCriteria * ) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultCustomQueryCriteriaWrapperCondition / toCriteria toCriteria fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/to-criteria/#tocriteria","text":"fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort Constructors Name Summary init VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List StateRef ? = null, notary: List AbstractParty ? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set Type = emptySet(), constraints: Set ConstraintInfo = emptySet(), participants: List AbstractParty ? = null) A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort Properties Name Summary constraints open var constraints: Set ConstraintInfo constraintTypes open var constraintTypes: Set Type contractStateType abstract val contractStateType: Class out ContractState The target ContractState type notary open var notary: List AbstractParty ? participants open var participants: List AbstractParty ? relevancyStatus open var relevancyStatus: RelevancyStatus softLockingCondition open var softLockingCondition: SoftLockingCondition? statePersistableType abstract val statePersistableType: Class P The target StatePersistable type stateRefs open var stateRefs: List StateRef ? status open var status: StateStatus timeCondition open var timeCondition: TimeCondition? timeConsumed val timeConsumed: TimeConsumedCondition timeRecorded val timeRecorded: TimeRecordedCondition Inherited Properties Name Summary fields abstract val fields: F The fields of the target StatePersistable type P Functions Name Summary aggregate fun aggregate(initializer: Aggregates P .() - Unit): Unit greaterThan infix fun TimeInstantTypeCondition .greaterThan(instant: Instant): Unit greaterThanOrEqual infix fun TimeInstantTypeCondition .greaterThanOrEqual(instant: Instant): Unit gt infix fun TimeInstantTypeCondition .gt(instant: Instant): Unit gtw infix fun TimeInstantTypeCondition .gtw(instant: Instant): Unit lessThan infix fun TimeInstantTypeCondition .lessThan(instant: Instant): Unit lessThanOrEqual infix fun TimeInstantTypeCondition .lessThanOrEqual(instant: Instant): Unit lt infix fun TimeInstantTypeCondition .lt(instant: Instant): Unit ltw infix fun TimeInstantTypeCondition .ltw(instant: Instant): Unit orderBy fun orderBy(initializer: SortColumns P .() - Unit): Unit toCriteria open fun toCriteria(): QueryCriteria fun toCriteria(ignoreAggregates: Boolean = false): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise toSort fun toSort(): Sort Inherited Functions Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#vaultquerycriteriacondition","text":"abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"VaultQueryCriteriaCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#constructors","text":"Name Summary init VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List StateRef ? = null, notary: List AbstractParty ? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set Type = emptySet(), constraints: Set ConstraintInfo = emptySet(), participants: List AbstractParty ? = null) A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#properties","text":"Name Summary constraints open var constraints: Set ConstraintInfo constraintTypes open var constraintTypes: Set Type contractStateType abstract val contractStateType: Class out ContractState The target ContractState type notary open var notary: List AbstractParty ? participants open var participants: List AbstractParty ? relevancyStatus open var relevancyStatus: RelevancyStatus softLockingCondition open var softLockingCondition: SoftLockingCondition? statePersistableType abstract val statePersistableType: Class P The target StatePersistable type stateRefs open var stateRefs: List StateRef ? status open var status: StateStatus timeCondition open var timeCondition: TimeCondition? timeConsumed val timeConsumed: TimeConsumedCondition timeRecorded val timeRecorded: TimeRecordedCondition","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#inherited-properties","text":"Name Summary fields abstract val fields: F The fields of the target StatePersistable type P","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#functions","text":"Name Summary aggregate fun aggregate(initializer: Aggregates P .() - Unit): Unit greaterThan infix fun TimeInstantTypeCondition .greaterThan(instant: Instant): Unit greaterThanOrEqual infix fun TimeInstantTypeCondition .greaterThanOrEqual(instant: Instant): Unit gt infix fun TimeInstantTypeCondition .gt(instant: Instant): Unit gtw infix fun TimeInstantTypeCondition .gtw(instant: Instant): Unit lessThan infix fun TimeInstantTypeCondition .lessThan(instant: Instant): Unit lessThanOrEqual infix fun TimeInstantTypeCondition .lessThanOrEqual(instant: Instant): Unit lt infix fun TimeInstantTypeCondition .lt(instant: Instant): Unit ltw infix fun TimeInstantTypeCondition .ltw(instant: Instant): Unit orderBy fun orderBy(initializer: SortColumns P .() - Unit): Unit toCriteria open fun toCriteria(): QueryCriteria fun toCriteria(ignoreAggregates: Boolean = false): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise toSort fun toSort(): Sort","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#inherited-functions","text":"Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / init init VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List StateRef ? = null, notary: List AbstractParty ? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set Type = emptySet(), constraints: Set ConstraintInfo = emptySet(), participants: List AbstractParty ? = null) A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/-init-/#init","text":"VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List StateRef ? = null, notary: List AbstractParty ? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set Type = emptySet(), constraints: Set ConstraintInfo = emptySet(), participants: List AbstractParty ? = null) A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/aggregate/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / aggregate aggregate fun aggregate(initializer: Aggregates P .() - Unit): Unit","title":"Aggregate"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/aggregate/#aggregate","text":"fun aggregate(initializer: Aggregates P .() - Unit): Unit","title":"aggregate"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraint-types/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / constraintTypes constraintTypes open var constraintTypes: Set Type Overrides RootCondition.constraintTypes","title":"Constraint types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraint-types/#constrainttypes","text":"open var constraintTypes: Set Type Overrides RootCondition.constraintTypes","title":"constraintTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraints/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / constraints constraints open var constraints: Set ConstraintInfo Overrides RootCondition.constraints","title":"Constraints"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraints/#constraints","text":"open var constraints: Set ConstraintInfo Overrides RootCondition.constraints","title":"constraints"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/contract-state-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / contractStateType contractStateType abstract val contractStateType: Class out ContractState The target ContractState type","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/contract-state-type/#contractstatetype","text":"abstract val contractStateType: Class out ContractState The target ContractState type","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/greater-than-or-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / greaterThanOrEqual greaterThanOrEqual infix fun TimeInstantTypeCondition .greaterThanOrEqual(instant: Instant): Unit","title":"Greater than or equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/greater-than-or-equal/#greaterthanorequal","text":"infix fun TimeInstantTypeCondition .greaterThanOrEqual(instant: Instant): Unit","title":"greaterThanOrEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/greater-than/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / greaterThan greaterThan infix fun TimeInstantTypeCondition .greaterThan(instant: Instant): Unit","title":"Greater than"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/greater-than/#greaterthan","text":"infix fun TimeInstantTypeCondition .greaterThan(instant: Instant): Unit","title":"greaterThan"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/gt/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / gt gt infix fun TimeInstantTypeCondition .gt(instant: Instant): Unit","title":"Gt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/gt/#gt","text":"infix fun TimeInstantTypeCondition .gt(instant: Instant): Unit","title":"gt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/gtw/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / gtw gtw infix fun TimeInstantTypeCondition .gtw(instant: Instant): Unit","title":"Gtw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/gtw/#gtw","text":"infix fun TimeInstantTypeCondition .gtw(instant: Instant): Unit","title":"gtw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/less-than-or-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / lessThanOrEqual lessThanOrEqual infix fun TimeInstantTypeCondition .lessThanOrEqual(instant: Instant): Unit","title":"Less than or equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/less-than-or-equal/#lessthanorequal","text":"infix fun TimeInstantTypeCondition .lessThanOrEqual(instant: Instant): Unit","title":"lessThanOrEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/less-than/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / lessThan lessThan infix fun TimeInstantTypeCondition .lessThan(instant: Instant): Unit","title":"Less than"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/less-than/#lessthan","text":"infix fun TimeInstantTypeCondition .lessThan(instant: Instant): Unit","title":"lessThan"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/lt/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / lt lt infix fun TimeInstantTypeCondition .lt(instant: Instant): Unit","title":"Lt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/lt/#lt","text":"infix fun TimeInstantTypeCondition .lt(instant: Instant): Unit","title":"lt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/ltw/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / ltw ltw infix fun TimeInstantTypeCondition .ltw(instant: Instant): Unit","title":"Ltw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/ltw/#ltw","text":"infix fun TimeInstantTypeCondition .ltw(instant: Instant): Unit","title":"ltw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/notary/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / notary notary open var notary: List AbstractParty ? Overrides RootCondition.notary","title":"Notary"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/notary/#notary","text":"open var notary: List AbstractParty ? Overrides RootCondition.notary","title":"notary"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/order-by/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / orderBy orderBy fun orderBy(initializer: SortColumns P .() - Unit): Unit","title":"Order by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/order-by/#orderby","text":"fun orderBy(initializer: SortColumns P .() - Unit): Unit","title":"orderBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/participants/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / participants participants open var participants: List AbstractParty ? Overrides RootCondition.participants","title":"Participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/participants/#participants","text":"open var participants: List AbstractParty ? Overrides RootCondition.participants","title":"participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/relevancy-status/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / relevancyStatus relevancyStatus open var relevancyStatus: RelevancyStatus Overrides RootCondition.relevancyStatus","title":"Relevancy status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/relevancy-status/#relevancystatus","text":"open var relevancyStatus: RelevancyStatus Overrides RootCondition.relevancyStatus","title":"relevancyStatus"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/soft-locking-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / softLockingCondition softLockingCondition open var softLockingCondition: SoftLockingCondition? Overrides RootCondition.softLockingCondition","title":"Soft locking condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/soft-locking-condition/#softlockingcondition","text":"open var softLockingCondition: SoftLockingCondition? Overrides RootCondition.softLockingCondition","title":"softLockingCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-persistable-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / statePersistableType statePersistableType abstract val statePersistableType: Class P The target StatePersistable type","title":"State persistable type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-persistable-type/#statepersistabletype","text":"abstract val statePersistableType: Class P The target StatePersistable type","title":"statePersistableType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-refs/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / stateRefs stateRefs open var stateRefs: List StateRef ? Overrides RootCondition.stateRefs","title":"State refs"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-refs/#staterefs","text":"open var stateRefs: List StateRef ? Overrides RootCondition.stateRefs","title":"stateRefs"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/status/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / status status open var status: StateStatus Overrides RootCondition.status","title":"Status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/status/#status","text":"open var status: StateStatus Overrides RootCondition.status","title":"status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / timeCondition timeCondition open var timeCondition: TimeCondition? Overrides RootCondition.timeCondition","title":"Time condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-condition/#timecondition","text":"open var timeCondition: TimeCondition? Overrides RootCondition.timeCondition","title":"timeCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-consumed/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / timeConsumed timeConsumed val timeConsumed: TimeConsumedCondition","title":"Time consumed"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-consumed/#timeconsumed","text":"val timeConsumed: TimeConsumedCondition","title":"timeConsumed"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-recorded/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / timeRecorded timeRecorded val timeRecorded: TimeRecordedCondition","title":"Time recorded"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-recorded/#timerecorded","text":"val timeRecorded: TimeRecordedCondition","title":"timeRecorded"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / toCriteria toCriteria open fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise fun toCriteria(ignoreAggregates: Boolean = false): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise Parameters ignoreAggregates - whether to ignore aggregate functions. Corda paged queries can have either state or aggregate results, but not both.","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-criteria/#tocriteria","text":"open fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise fun toCriteria(ignoreAggregates: Boolean = false): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-criteria/#parameters","text":"ignoreAggregates - whether to ignore aggregate functions. Corda paged queries can have either state or aggregate results, but not both.","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-sort/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / toSort toSort fun toSort(): Sort","title":"To sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-sort/#tosort","text":"fun toSort(): Sort","title":"toSort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/","text":"com.github.manosbatsis.vaultaire.dto Package com.github.manosbatsis.vaultaire.dto Types Name Summary VaultaireLiteDto interface VaultaireLiteDto T : ContractState Modeled after com.github.manosbatsis.kotlin.utils.api.Dto only bringing a StateService in-context for toTargetType and toPatched .","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/#package-comgithubmanosbatsisvaultairedto","text":"","title":"Package com.github.manosbatsis.vaultaire.dto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/#types","text":"Name Summary VaultaireLiteDto interface VaultaireLiteDto T : ContractState Modeled after com.github.manosbatsis.kotlin.utils.api.Dto only bringing a StateService in-context for toTargetType and toPatched .","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireLiteDto VaultaireLiteDto interface VaultaireLiteDto T : ContractState Modeled after com.github.manosbatsis.kotlin.utils.api.Dto only bringing a StateService in-context for toTargetType and toPatched . Functions Name Summary toName open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name toNameOrNull open fun toNameOrNull(party: Party?): CordaX500Name? toParty open fun toParty(partyName: CordaX500Name?, stateService: StateService T , propertyName: String = \"unknown\"): Party toPartyOrDefault open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: StateService T , propertyName: String = \"unknown\"): Party toPartyOrDefaultNullable open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: StateService T , propertyName: String = \"unknown\"): Party? toPartyOrNull open fun toPartyOrNull(partyName: CordaX500Name?, stateService: StateService T , propertyName: String = \"unknown\"): Party? toPatched abstract fun toPatched(original: T , stateService: StateService T ): T Create a patched copy of the given T instance, updated using this DTO s non-null properties toTargetType abstract fun toTargetType(stateService: StateService T ): T Create an instance of T , using this DTO s properties. May throw a DtoInsufficientMappingException if there is mot enough information to do so.","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/#vaultairelitedto","text":"interface VaultaireLiteDto T : ContractState Modeled after com.github.manosbatsis.kotlin.utils.api.Dto only bringing a StateService in-context for toTargetType and toPatched .","title":"VaultaireLiteDto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/#functions","text":"Name Summary toName open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name toNameOrNull open fun toNameOrNull(party: Party?): CordaX500Name? toParty open fun toParty(partyName: CordaX500Name?, stateService: StateService T , propertyName: String = \"unknown\"): Party toPartyOrDefault open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: StateService T , propertyName: String = \"unknown\"): Party toPartyOrDefaultNullable open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: StateService T , propertyName: String = \"unknown\"): Party? toPartyOrNull open fun toPartyOrNull(partyName: CordaX500Name?, stateService: StateService T , propertyName: String = \"unknown\"): Party? toPatched abstract fun toPatched(original: T , stateService: StateService T ): T Create a patched copy of the given T instance, updated using this DTO s non-null properties toTargetType abstract fun toTargetType(stateService: StateService T ): T Create an instance of T , using this DTO s properties. May throw a DtoInsufficientMappingException if there is mot enough information to do so.","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-name-or-null/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireLiteDto / toNameOrNull toNameOrNull open fun toNameOrNull(party: Party?): CordaX500Name?","title":"To name or null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-name-or-null/#tonameornull","text":"open fun toNameOrNull(party: Party?): CordaX500Name?","title":"toNameOrNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-name/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireLiteDto / toName toName open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name","title":"To name"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-name/#toname","text":"open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name","title":"toName"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-party-or-default-nullable/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireLiteDto / toPartyOrDefaultNullable toPartyOrDefaultNullable open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: StateService T , propertyName: String = \"unknown\"): Party?","title":"To party or default nullable"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-party-or-default-nullable/#topartyordefaultnullable","text":"open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: StateService T , propertyName: String = \"unknown\"): Party?","title":"toPartyOrDefaultNullable"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-party-or-default/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireLiteDto / toPartyOrDefault toPartyOrDefault open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: StateService T , propertyName: String = \"unknown\"): Party","title":"To party or default"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-party-or-default/#topartyordefault","text":"open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: StateService T , propertyName: String = \"unknown\"): Party","title":"toPartyOrDefault"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-party-or-null/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireLiteDto / toPartyOrNull toPartyOrNull open fun toPartyOrNull(partyName: CordaX500Name?, stateService: StateService T , propertyName: String = \"unknown\"): Party?","title":"To party or null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-party-or-null/#topartyornull","text":"open fun toPartyOrNull(partyName: CordaX500Name?, stateService: StateService T , propertyName: String = \"unknown\"): Party?","title":"toPartyOrNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-party/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireLiteDto / toParty toParty open fun toParty(partyName: CordaX500Name?, stateService: StateService T , propertyName: String = \"unknown\"): Party","title":"To party"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-party/#toparty","text":"open fun toParty(partyName: CordaX500Name?, stateService: StateService T , propertyName: String = \"unknown\"): Party","title":"toParty"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-patched/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireLiteDto / toPatched toPatched abstract fun toPatched(original: T , stateService: StateService T ): T Create a patched copy of the given T instance, updated using this DTO s non-null properties","title":"To patched"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-patched/#topatched","text":"abstract fun toPatched(original: T , stateService: StateService T ): T Create a patched copy of the given T instance, updated using this DTO s non-null properties","title":"toPatched"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-target-type/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireLiteDto / toTargetType toTargetType abstract fun toTargetType(stateService: StateService T ): T Create an instance of T , using this DTO s properties. May throw a DtoInsufficientMappingException if there is mot enough information to do so.","title":"To target type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/to-target-type/#totargettype","text":"abstract fun toTargetType(stateService: StateService T ): T Create an instance of T , using this DTO s properties. May throw a DtoInsufficientMappingException if there is mot enough information to do so.","title":"toTargetType"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/","text":"com.github.manosbatsis.vaultaire.registry Package com.github.manosbatsis.vaultaire.registry Types Name Summary Registry object Registry","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/#package-comgithubmanosbatsisvaultaireregistry","text":"","title":"Package com.github.manosbatsis.vaultaire.registry"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/#types","text":"Name Summary Registry object Registry","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/","text":"com.github.manosbatsis.vaultaire.registry / Registry Registry object Registry Functions Name Summary registerQueryDsl fun P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F registerQueryDsl(keyType: KClass P , queryCriteriaType: KClass Q ): KClass * ? registerService fun T : ContractState, P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F , S : ExtendedStateService T , P , F , Q registerService(keyType: KClass T , serviceType: KClass S ): KClass * ?","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/#registry","text":"object Registry","title":"Registry"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/#functions","text":"Name Summary registerQueryDsl fun P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F registerQueryDsl(keyType: KClass P , queryCriteriaType: KClass Q ): KClass * ? registerService fun T : ContractState, P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F , S : ExtendedStateService T , P , F , Q registerService(keyType: KClass T , serviceType: KClass S ): KClass * ?","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-query-dsl/","text":"com.github.manosbatsis.vaultaire.registry / Registry / registerQueryDsl registerQueryDsl fun P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F registerQueryDsl(keyType: KClass P , queryCriteriaType: KClass Q ): KClass * ?","title":"Register query dsl"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-query-dsl/#registerquerydsl","text":"fun P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F registerQueryDsl(keyType: KClass P , queryCriteriaType: KClass Q ): KClass * ?","title":"registerQueryDsl"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-service/","text":"com.github.manosbatsis.vaultaire.registry / Registry / registerService registerService fun T : ContractState, P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F , S : ExtendedStateService T , P , F , Q registerService(keyType: KClass T , serviceType: KClass S ): KClass * ?","title":"Register service"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-service/#registerservice","text":"fun T : ContractState, P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F , S : ExtendedStateService T , P , F , Q registerService(keyType: KClass T , serviceType: KClass S ): KClass * ?","title":"registerService"},{"location":"0.x/com.github.manosbatsis.vaultaire.rpc/","text":"com.github.manosbatsis.vaultaire.rpc Package com.github.manosbatsis.vaultaire.rpc Types Name Summary NodeRpcConnection interface NodeRpcConnection Wraps a Corda Node RPC connection proxy","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.rpc/#package-comgithubmanosbatsisvaultairerpc","text":"","title":"Package com.github.manosbatsis.vaultaire.rpc"},{"location":"0.x/com.github.manosbatsis.vaultaire.rpc/#types","text":"Name Summary NodeRpcConnection interface NodeRpcConnection Wraps a Corda Node RPC connection proxy","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.rpc/-node-rpc-connection/","text":"com.github.manosbatsis.vaultaire.rpc / NodeRpcConnection NodeRpcConnection interface NodeRpcConnection Wraps a Corda Node RPC connection proxy Properties Name Summary proxy abstract val proxy: CordaRPCOps Obtain a CordaRPCOps proxy for this connection Functions Name Summary skipInfo abstract fun skipInfo(): Boolean Whether this connection should be kept private e.g. from actuator","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.rpc/-node-rpc-connection/#noderpcconnection","text":"interface NodeRpcConnection Wraps a Corda Node RPC connection proxy","title":"NodeRpcConnection"},{"location":"0.x/com.github.manosbatsis.vaultaire.rpc/-node-rpc-connection/#properties","text":"Name Summary proxy abstract val proxy: CordaRPCOps Obtain a CordaRPCOps proxy for this connection","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.rpc/-node-rpc-connection/#functions","text":"Name Summary skipInfo abstract fun skipInfo(): Boolean Whether this connection should be kept private e.g. from actuator","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.rpc/-node-rpc-connection/proxy/","text":"com.github.manosbatsis.vaultaire.rpc / NodeRpcConnection / proxy proxy abstract val proxy: CordaRPCOps Obtain a CordaRPCOps proxy for this connection","title":"Proxy"},{"location":"0.x/com.github.manosbatsis.vaultaire.rpc/-node-rpc-connection/proxy/#proxy","text":"abstract val proxy: CordaRPCOps Obtain a CordaRPCOps proxy for this connection","title":"proxy"},{"location":"0.x/com.github.manosbatsis.vaultaire.rpc/-node-rpc-connection/skip-info/","text":"com.github.manosbatsis.vaultaire.rpc / NodeRpcConnection / skipInfo skipInfo abstract fun skipInfo(): Boolean Whether this connection should be kept private e.g. from actuator","title":"Skip info"},{"location":"0.x/com.github.manosbatsis.vaultaire.rpc/-node-rpc-connection/skip-info/#skipinfo","text":"abstract fun skipInfo(): Boolean Whether this connection should be kept private e.g. from actuator","title":"skipInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/","text":"com.github.manosbatsis.vaultaire.service Package com.github.manosbatsis.vaultaire.service Types Name Summary ServiceDefaults data class ServiceDefaults Define option defaults for StateService instances","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/#package-comgithubmanosbatsisvaultaireservice","text":"","title":"Package com.github.manosbatsis.vaultaire.service"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/#types","text":"Name Summary ServiceDefaults data class ServiceDefaults Define option defaults for StateService instances","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults ServiceDefaults data class ServiceDefaults Define option defaults for StateService instances Constructors Name Summary init ServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances Properties Name Summary criteria val criteria: QueryCriteria pageNumber val pageNumber: Int pageSize val pageSize: Int paging val paging: PageSpecification sort val sort: Sort","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/#servicedefaults","text":"data class ServiceDefaults Define option defaults for StateService instances","title":"ServiceDefaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/#constructors","text":"Name Summary init ServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/#properties","text":"Name Summary criteria val criteria: QueryCriteria pageNumber val pageNumber: Int pageSize val pageSize: Int paging val paging: PageSpecification sort val sort: Sort","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/-init-/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / init init ServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/-init-/#init","text":"ServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/criteria/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / criteria criteria val criteria: QueryCriteria","title":"Criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/criteria/#criteria","text":"val criteria: QueryCriteria","title":"criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/page-number/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / pageNumber pageNumber val pageNumber: Int","title":"Page number"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/page-number/#pagenumber","text":"val pageNumber: Int","title":"pageNumber"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/page-size/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / pageSize pageSize val pageSize: Int","title":"Page size"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/page-size/#pagesize","text":"val pageSize: Int","title":"pageSize"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/paging/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / paging paging val paging: PageSpecification","title":"Paging"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/paging/#paging","text":"val paging: PageSpecification","title":"paging"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/sort/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / sort sort val sort: Sort","title":"Sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/sort/#sort","text":"val sort: Sort","title":"sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/","text":"com.github.manosbatsis.vaultaire.service.dao Package com.github.manosbatsis.vaultaire.service.dao Types Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type ExtendedStateService abstract class ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . StateService interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type StateServiceDelegate interface StateServiceDelegate T : ContractState : NodeServiceDelegate StateService delegate for vault operations StateServiceHubDelegate open class StateServiceHubDelegate T : ContractState : NodeServiceHubDelegate , StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate T : ContractState : NodeServiceRpcConnectionDelegate , StateServiceDelegate T NodeRpcConnection -based StateServiceDelegate implementation StateServiceRpcDelegate open class StateServiceRpcDelegate T : ContractState : NodeServiceRpcDelegate , StateServiceDelegate T CordaRPCOps -based StateServiceDelegate implementation","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/#package-comgithubmanosbatsisvaultaireservicedao","text":"","title":"Package com.github.manosbatsis.vaultaire.service.dao"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/#types","text":"Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type ExtendedStateService abstract class ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . StateService interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type StateServiceDelegate interface StateServiceDelegate T : ContractState : NodeServiceDelegate StateService delegate for vault operations StateServiceHubDelegate open class StateServiceHubDelegate T : ContractState : NodeServiceHubDelegate , StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate T : ContractState : NodeServiceRpcConnectionDelegate , StateServiceDelegate T NodeRpcConnection -based StateServiceDelegate implementation StateServiceRpcDelegate open class StateServiceRpcDelegate T : ContractState : NodeServiceRpcDelegate , StateServiceDelegate T CordaRPCOps -based StateServiceDelegate implementation","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/","text":"com.github.manosbatsis.vaultaire.service.dao / BasicStateService BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type Parameters T - the ContractState type Constructors Name Summary init BasicStateService(nodeRpcConnection: NodeRpcConnection , contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based constructor BasicStateService(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate T ) Basic StateService implementation, used for vault operations on a specific ContractState type Properties Name Summary ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean Inherited Functions Name Summary countBy open fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria countBy open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByExternalId open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inheritors Name Summary ExtendedStateService abstract class ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields .","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#basicstateservice","text":"open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type","title":"BasicStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#constructors","text":"Name Summary init BasicStateService(nodeRpcConnection: NodeRpcConnection , contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based constructor BasicStateService(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate T ) Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#properties","text":"Name Summary ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#inherited-functions","text":"Name Summary countBy open fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria countBy open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByExternalId open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#inheritors","text":"Name Summary ExtendedStateService abstract class ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields .","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / BasicStateService / init init BasicStateService(nodeRpcConnection: NodeRpcConnection , contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based constructor BasicStateService(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate T ) Basic StateService implementation, used for vault operations on a specific ContractState type Parameters T - the ContractState type","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/-init-/#init","text":"BasicStateService(nodeRpcConnection: NodeRpcConnection , contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based constructor BasicStateService(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate T ) Basic StateService implementation, used for vault operations on a specific ContractState type","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/-init-/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/of-linear-state/","text":"com.github.manosbatsis.vaultaire.service.dao / BasicStateService / ofLinearState ofLinearState open val ofLinearState: Boolean Overrides StateService.ofLinearState","title":"Of linear state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/of-linear-state/#oflinearstate","text":"open val ofLinearState: Boolean Overrides StateService.ofLinearState","title":"ofLinearState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/of-queryable-state/","text":"com.github.manosbatsis.vaultaire.service.dao / BasicStateService / ofQueryableState ofQueryableState open val ofQueryableState: Boolean Overrides StateService.ofQueryableState","title":"Of queryable state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/of-queryable-state/#ofqueryablestate","text":"open val ofQueryableState: Boolean Overrides StateService.ofQueryableState","title":"ofQueryableState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService ExtendedStateService abstract class ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Subclassed by Vaultaire s annotation processing to generate service components. Constructors Name Summary init ExtendedStateService(delegate: StateServiceDelegate T ) Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Properties Name Summary criteriaConditionsType lateinit var criteriaConditionsType: Class Q The fields of the target StatePersistable type P fields abstract val fields: F The fields of the target StatePersistable type P statePersistableType abstract val statePersistableType: Class P The type of the target state s StatePersistable Inherited Properties Name Summary ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean Functions Name Summary buildQuery abstract fun buildQuery(block: Q .() - Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q queryBy fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page T Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): Page T fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any toSort fun toSort(vararg sort: Pair String, Direction ): Sort Build a sort from the given string/direction pairs trackBy fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): DataFeed Page T , Update T fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed Page T , Update T Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates.","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#extendedstateservice","text":"abstract class ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Subclassed by Vaultaire s annotation processing to generate service components.","title":"ExtendedStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#constructors","text":"Name Summary init ExtendedStateService(delegate: StateServiceDelegate T ) Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields .","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#properties","text":"Name Summary criteriaConditionsType lateinit var criteriaConditionsType: Class Q The fields of the target StatePersistable type P fields abstract val fields: F The fields of the target StatePersistable type P statePersistableType abstract val statePersistableType: Class P The type of the target state s StatePersistable","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#inherited-properties","text":"Name Summary ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#functions","text":"Name Summary buildQuery abstract fun buildQuery(block: Q .() - Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q queryBy fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page T Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): Page T fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any toSort fun toSort(vararg sort: Pair String, Direction ): Sort Build a sort from the given string/direction pairs trackBy fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): DataFeed Page T , Update T fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed Page T , Update T Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates.","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / init init ExtendedStateService(delegate: StateServiceDelegate T ) Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Subclassed by Vaultaire s annotation processing to generate service components.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/-init-/#init","text":"ExtendedStateService(delegate: StateServiceDelegate T ) Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Subclassed by Vaultaire s annotation processing to generate service components.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/build-query/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / buildQuery buildQuery abstract fun buildQuery(block: Q .() - Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q","title":"Build query"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/build-query/#buildquery","text":"abstract fun buildQuery(block: Q .() - Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q","title":"buildQuery"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/criteria-conditions-type/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / criteriaConditionsType criteriaConditionsType lateinit var criteriaConditionsType: Class Q The fields of the target StatePersistable type P","title":"Criteria conditions type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/criteria-conditions-type/#criteriaconditionstype","text":"lateinit var criteriaConditionsType: Class Q The fields of the target StatePersistable type P","title":"criteriaConditionsType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/fields/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / fields fields abstract val fields: F The fields of the target StatePersistable type P","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/fields/#fields","text":"abstract val fields: F The fields of the target StatePersistable type P","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/query-by/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / queryBy queryBy fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page T Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): Page T fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/query-by/#queryby","text":"fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page T Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): Page T fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/state-persistable-type/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / statePersistableType statePersistableType abstract val statePersistableType: Class P The type of the target state s StatePersistable","title":"State persistable type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/state-persistable-type/#statepersistabletype","text":"abstract val statePersistableType: Class P The type of the target state s StatePersistable","title":"statePersistableType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/to-sort/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / toSort toSort fun toSort(vararg sort: Pair String, Direction ): Sort Build a sort from the given string/direction pairs","title":"To sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/to-sort/#tosort","text":"fun toSort(vararg sort: Pair String, Direction ): Sort Build a sort from the given string/direction pairs","title":"toSort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/track-by/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / trackBy trackBy fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): DataFeed Page T , Update T fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed Page T , Update T Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates.","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/track-by/#trackby","text":"fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): DataFeed Page T , Update T fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed Page T , Update T Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates.","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService StateService interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type Parameters T - the ContractState type Properties Name Summary ofLinearState abstract val ofLinearState: Boolean ofQueryableState abstract val ofQueryableState: Boolean Inherited Properties Name Summary contractStateType abstract val contractStateType: Class T Functions Name Summary countBy open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inherited Functions Name Summary countBy abstract fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId abstract fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? abstract fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any Inheritors Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#stateservice","text":"interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type","title":"StateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#properties","text":"Name Summary ofLinearState abstract val ofLinearState: Boolean ofQueryableState abstract val ofQueryableState: Boolean","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#inherited-properties","text":"Name Summary contractStateType abstract val contractStateType: Class T","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#functions","text":"Name Summary countBy open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#inherited-functions","text":"Name Summary countBy abstract fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId abstract fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? abstract fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#inheritors","text":"Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/count-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / countBy countBy open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria","title":"Count by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/count-by/#countby","text":"open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria","title":"countBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/find-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / findByExternalId findByExternalId open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"Find by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/find-by-external-id/#findbyexternalid","text":"open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"findByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/find-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / findByLinearId findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any","title":"Find by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/find-by-linear-id/#findbylinearid","text":"open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any","title":"findByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / getByExternalId getByExternalId open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise Exceptions StateNotFoundException - if no match is found","title":"Get by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-external-id/#getbyexternalid","text":"open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise","title":"getByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-external-id/#exceptions","text":"StateNotFoundException - if no match is found","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / getByLinearId getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise Exceptions StateNotFoundException - if no match is found open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise Exceptions StateNotFoundException - if no match is found","title":"Get by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-linear-id/#getbylinearid","text":"open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise","title":"getByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-linear-id/#exceptions","text":"StateNotFoundException - if no match is found open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-linear-id/#exceptions_1","text":"StateNotFoundException - if no match is found","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/of-linear-state/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / ofLinearState ofLinearState abstract val ofLinearState: Boolean","title":"Of linear state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/of-linear-state/#oflinearstate","text":"abstract val ofLinearState: Boolean","title":"ofLinearState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/of-queryable-state/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / ofQueryableState ofQueryableState abstract val ofQueryableState: Boolean","title":"Of queryable state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/of-queryable-state/#ofqueryablestate","text":"abstract val ofQueryableState: Boolean","title":"ofQueryableState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/query-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / queryBy queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/query-by/#queryby","text":"open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/track-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / trackBy trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/track-by/#trackby","text":"open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceDelegate StateServiceDelegate interface StateServiceDelegate T : ContractState : NodeServiceDelegate StateService delegate for vault operations Properties Name Summary contractStateType abstract val contractStateType: Class T Inherited Properties Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name Functions Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any Inherited Functions Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inheritors Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type StateService interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type StateServiceHubDelegate open class StateServiceHubDelegate T : ContractState : NodeServiceHubDelegate , StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate T : ContractState : NodeServiceRpcConnectionDelegate , StateServiceDelegate T NodeRpcConnection -based StateServiceDelegate implementation StateServiceRpcDelegate open class StateServiceRpcDelegate T : ContractState : NodeServiceRpcDelegate , StateServiceDelegate T CordaRPCOps -based StateServiceDelegate implementation","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#stateservicedelegate","text":"interface StateServiceDelegate T : ContractState : NodeServiceDelegate StateService delegate for vault operations","title":"StateServiceDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#properties","text":"Name Summary contractStateType abstract val contractStateType: Class T","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#inherited-properties","text":"Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#functions","text":"Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#inherited-functions","text":"Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#inheritors","text":"Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type StateService interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type StateServiceHubDelegate open class StateServiceHubDelegate T : ContractState : NodeServiceHubDelegate , StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate T : ContractState : NodeServiceRpcConnectionDelegate , StateServiceDelegate T NodeRpcConnection -based StateServiceDelegate implementation StateServiceRpcDelegate open class StateServiceRpcDelegate T : ContractState : NodeServiceRpcDelegate , StateServiceDelegate T CordaRPCOps -based StateServiceDelegate implementation","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceDelegate / contractStateType contractStateType abstract val contractStateType: Class T","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/contract-state-type/#contractstatetype","text":"abstract val contractStateType: Class T","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/query-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceDelegate / queryBy queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/query-by/#queryby","text":"open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/track-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceDelegate / trackBy trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/track-by/#trackby","text":"open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceHubDelegate StateServiceHubDelegate open class StateServiceHubDelegate T : ContractState : NodeServiceHubDelegate , StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation Constructors Name Summary init StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based StateServiceDelegate implementation Properties Name Summary contractStateType open val contractStateType: Class T Inherited Properties Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name serviceHub val serviceHub: ServiceHub Inherited Functions Name Summary partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/#stateservicehubdelegate","text":"open class StateServiceHubDelegate T : ContractState : NodeServiceHubDelegate , StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation","title":"StateServiceHubDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/#constructors","text":"Name Summary init StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based StateServiceDelegate implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/#properties","text":"Name Summary contractStateType open val contractStateType: Class T","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/#inherited-properties","text":"Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name serviceHub val serviceHub: ServiceHub","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/#inherited-functions","text":"Name Summary partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceHubDelegate / init init StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based StateServiceDelegate implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/-init-/#init","text":"StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based StateServiceDelegate implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceHubDelegate / contractStateType contractStateType open val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/contract-state-type/#contractstatetype","text":"open val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceRpcConnectionDelegate StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate T : ContractState : NodeServiceRpcConnectionDelegate , StateServiceDelegate T NodeRpcConnection -based StateServiceDelegate implementation Constructors Name Summary init StateServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection , contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based StateServiceDelegate implementation Properties Name Summary contractStateType open val contractStateType: Class T Inherited Properties Name Summary defaults open val defaults: ServiceDefaults rpcOps open val rpcOps: CordaRPCOps Inherited Functions Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/#stateservicerpcconnectiondelegate","text":"open class StateServiceRpcConnectionDelegate T : ContractState : NodeServiceRpcConnectionDelegate , StateServiceDelegate T NodeRpcConnection -based StateServiceDelegate implementation","title":"StateServiceRpcConnectionDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/#constructors","text":"Name Summary init StateServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection , contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based StateServiceDelegate implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/#properties","text":"Name Summary contractStateType open val contractStateType: Class T","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/#inherited-properties","text":"Name Summary defaults open val defaults: ServiceDefaults rpcOps open val rpcOps: CordaRPCOps","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/#inherited-functions","text":"Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceRpcConnectionDelegate / init init StateServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection , contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based StateServiceDelegate implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/-init-/#init","text":"StateServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection , contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based StateServiceDelegate implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceRpcConnectionDelegate / contractStateType contractStateType open val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/contract-state-type/#contractstatetype","text":"open val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceRpcDelegate StateServiceRpcDelegate open class StateServiceRpcDelegate T : ContractState : NodeServiceRpcDelegate , StateServiceDelegate T CordaRPCOps -based StateServiceDelegate implementation Constructors Name Summary init StateServiceRpcDelegate(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based StateServiceDelegate implementation Properties Name Summary contractStateType open val contractStateType: Class T Inherited Properties Name Summary rpcOps open val rpcOps: CordaRPCOps Inherited Functions Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-delegate/#stateservicerpcdelegate","text":"open class StateServiceRpcDelegate T : ContractState : NodeServiceRpcDelegate , StateServiceDelegate T CordaRPCOps -based StateServiceDelegate implementation","title":"StateServiceRpcDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-delegate/#constructors","text":"Name Summary init StateServiceRpcDelegate(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based StateServiceDelegate implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-delegate/#properties","text":"Name Summary contractStateType open val contractStateType: Class T","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-delegate/#inherited-properties","text":"Name Summary rpcOps open val rpcOps: CordaRPCOps","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-delegate/#inherited-functions","text":"Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceRpcDelegate / init init StateServiceRpcDelegate(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based StateServiceDelegate implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-delegate/-init-/#init","text":"StateServiceRpcDelegate(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based StateServiceDelegate implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceRpcDelegate / contractStateType contractStateType open val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-delegate/contract-state-type/#contractstatetype","text":"open val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/","text":"com.github.manosbatsis.vaultaire.service.node Package com.github.manosbatsis.vaultaire.service.node Types Name Summary BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation NodeService interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type NodeServiceDelegate interface NodeServiceDelegate NodeService delegate for vault operations NodeServiceHubDelegate open class NodeServiceHubDelegate : NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation NodeServiceRpcConnectionDelegate open class NodeServiceRpcConnectionDelegate : NodeServiceRpcDelegateBase NodeRpcConnection -based NodeServiceDelegate implementation NodeServiceRpcDelegate open class NodeServiceRpcDelegate : NodeServiceRpcDelegateBase CordaRPCOps -based NodeServiceDelegate implementation NodeServiceRpcDelegateBase abstract class NodeServiceRpcDelegateBase : NodeServiceDelegate RPC implementation base Exceptions Name Summary StateNotFoundException class StateNotFoundException : RuntimeException","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/#package-comgithubmanosbatsisvaultaireservicenode","text":"","title":"Package com.github.manosbatsis.vaultaire.service.node"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/#types","text":"Name Summary BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation NodeService interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type NodeServiceDelegate interface NodeServiceDelegate NodeService delegate for vault operations NodeServiceHubDelegate open class NodeServiceHubDelegate : NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation NodeServiceRpcConnectionDelegate open class NodeServiceRpcConnectionDelegate : NodeServiceRpcDelegateBase NodeRpcConnection -based NodeServiceDelegate implementation NodeServiceRpcDelegate open class NodeServiceRpcDelegate : NodeServiceRpcDelegateBase CordaRPCOps -based NodeServiceDelegate implementation NodeServiceRpcDelegateBase abstract class NodeServiceRpcDelegateBase : NodeServiceDelegate RPC implementation base","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/#exceptions","text":"Name Summary StateNotFoundException class StateNotFoundException : RuntimeException","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation Constructors Name Summary init BasicNodeService(nodeRpcConnection: NodeRpcConnection , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based constructor BasicNodeService(rpcOps: CordaRPCOps, defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based constructor BasicNodeService(serviceHub: ServiceHub, defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based constructor BasicNodeService(delegate: NodeServiceDelegate ) Basic NodeService implementation Functions Name Summary countBy open fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inherited Functions Name Summary findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise Inheritors Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#basicnodeservice","text":"open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation","title":"BasicNodeService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#constructors","text":"Name Summary init BasicNodeService(nodeRpcConnection: NodeRpcConnection , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based constructor BasicNodeService(rpcOps: CordaRPCOps, defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based constructor BasicNodeService(serviceHub: ServiceHub, defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based constructor BasicNodeService(delegate: NodeServiceDelegate ) Basic NodeService implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#functions","text":"Name Summary countBy open fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#inherited-functions","text":"Name Summary findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#inheritors","text":"Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / init init BasicNodeService(nodeRpcConnection: NodeRpcConnection , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based constructor BasicNodeService(rpcOps: CordaRPCOps, defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based constructor BasicNodeService(serviceHub: ServiceHub, defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based constructor BasicNodeService(delegate: NodeServiceDelegate ) Basic NodeService implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/-init-/#init","text":"BasicNodeService(nodeRpcConnection: NodeRpcConnection , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based constructor BasicNodeService(rpcOps: CordaRPCOps, defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based constructor BasicNodeService(serviceHub: ServiceHub, defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based constructor BasicNodeService(delegate: NodeServiceDelegate ) Basic NodeService implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/count-by/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / countBy countBy open fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria): Long Overrides NodeService.countBy Count states of type T matching stored in the vault and matching any given criteria","title":"Count by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/count-by/#countby","text":"open fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria): Long Overrides NodeService.countBy Count states of type T matching stored in the vault and matching any given criteria","title":"countBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/find-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / findByExternalId findByExternalId open fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Overrides NodeService.findByExternalId Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"Find by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/find-by-external-id/#findbyexternalid","text":"open fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Overrides NodeService.findByExternalId Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"findByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/find-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / findByLinearId findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Overrides NodeService.findByLinearId Find the state of type T matching the given UniqueIdentifier if any","title":"Find by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/find-by-linear-id/#findbylinearid","text":"open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Overrides NodeService.findByLinearId Find the state of type T matching the given UniqueIdentifier if any","title":"findByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / queryBy queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Overrides NodeService.queryBy Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/query-by/#queryby","text":"open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Overrides NodeService.queryBy Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / trackBy trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Overrides NodeService.trackBy Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/track-by/#trackby","text":"open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Overrides NodeService.trackBy Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService NodeService interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type Parameters T - the ContractState type Inherited Properties Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name Functions Name Summary countBy abstract fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId abstract fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? abstract fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inherited Functions Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inheritors Name Summary BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation StateService interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#nodeservice","text":"interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type","title":"NodeService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#inherited-properties","text":"Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#functions","text":"Name Summary countBy abstract fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId abstract fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? abstract fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#inherited-functions","text":"Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#inheritors","text":"Name Summary BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation StateService interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/count-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / countBy countBy abstract fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria","title":"Count by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/count-by/#countby","text":"abstract fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria","title":"countBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/find-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / findByExternalId findByExternalId abstract fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"Find by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/find-by-external-id/#findbyexternalid","text":"abstract fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"findByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/find-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / findByLinearId findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? abstract fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any","title":"Find by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/find-by-linear-id/#findbylinearid","text":"open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? abstract fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any","title":"findByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / getByExternalId getByExternalId open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise Exceptions StateNotFoundException - if no match is found","title":"Get by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-external-id/#getbyexternalid","text":"open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise","title":"getByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-external-id/#exceptions","text":"StateNotFoundException - if no match is found","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / getByLinearId getByLinearId open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise Exceptions StateNotFoundException - if no match is found open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise Exceptions StateNotFoundException - if no match is found","title":"Get by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-linear-id/#getbylinearid","text":"open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise","title":"getByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-linear-id/#exceptions","text":"StateNotFoundException - if no match is found open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-linear-id/#exceptions_1","text":"StateNotFoundException - if no match is found","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / queryBy queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/query-by/#queryby","text":"abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / trackBy trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/track-by/#trackby","text":"abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate NodeServiceDelegate interface NodeServiceDelegate NodeService delegate for vault operations Properties Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name Functions Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inheritors Name Summary BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation NodeService interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type NodeServiceHubDelegate open class NodeServiceHubDelegate : NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation NodeServiceRpcDelegateBase abstract class NodeServiceRpcDelegateBase : NodeServiceDelegate RPC implementation base StateServiceDelegate interface StateServiceDelegate T : ContractState : NodeServiceDelegate StateService delegate for vault operations","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/#nodeservicedelegate","text":"interface NodeServiceDelegate NodeService delegate for vault operations","title":"NodeServiceDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/#properties","text":"Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/#functions","text":"Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/#inheritors","text":"Name Summary BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation NodeService interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type NodeServiceHubDelegate open class NodeServiceHubDelegate : NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation NodeServiceRpcDelegateBase abstract class NodeServiceRpcDelegateBase : NodeServiceDelegate RPC implementation base StateServiceDelegate interface StateServiceDelegate T : ContractState : NodeServiceDelegate StateService delegate for vault operations","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/defaults/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / defaults defaults abstract val defaults: ServiceDefaults","title":"Defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/defaults/#defaults","text":"abstract val defaults: ServiceDefaults","title":"defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/find-party-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / findPartyFromName findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. Parameters name - The name to convert to a party","title":"Find party from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/find-party-from-name/#findpartyfromname","text":"open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching.","title":"findPartyFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/find-party-from-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-party-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / getPartyFromName getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. Parameters name - The name to convert to a party","title":"Get party from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-party-from-name/#getpartyfromname","text":"open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown.","title":"getPartyFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-party-from-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/is-linear-state/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / isLinearState isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean","title":"Is linear state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/is-linear-state/#islinearstate","text":"open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean","title":"isLinearState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/is-queryable-state/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / isQueryableState isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean","title":"Is queryable state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/is-queryable-state/#isqueryablestate","text":"open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean","title":"isQueryableState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-identity-criteria/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / nodeIdentityCriteria nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria","title":"Node identity criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-identity-criteria/#nodeidentitycriteria","text":"abstract val nodeIdentityCriteria: LinearStateQueryCriteria","title":"nodeIdentityCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-identity/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / nodeIdentity nodeIdentity abstract val nodeIdentity: Party","title":"Node identity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-identity/#nodeidentity","text":"abstract val nodeIdentity: Party","title":"nodeIdentity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-legal-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / nodeLegalName nodeLegalName abstract val nodeLegalName: CordaX500Name","title":"Node legal name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-legal-name/#nodelegalname","text":"abstract val nodeLegalName: CordaX500Name","title":"nodeLegalName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/parties-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / partiesFromName partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. Parameters query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parties from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/parties-from-name/#partiesfromname","text":"abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted.","title":"partiesFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/parties-from-name/#parameters","text":"query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / queryBy queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/query-by/#queryby","text":"abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/to-corda-x500-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / toCordaX500Name toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name","title":"To corda x500 name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/to-corda-x500-name/#tocordax500name","text":"open fun toCordaX500Name(query: String): CordaX500Name","title":"toCordaX500Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / trackBy trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/track-by/#trackby","text":"abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/well-known-party-from-x500-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / wellKnownPartyFromX500Name wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Parameters name - The name to convert to a party","title":"Well known party from x500 name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/well-known-party-from-x500-name/#wellknownpartyfromx500name","text":"abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"wellKnownPartyFromX500Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/well-known-party-from-x500-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceHubDelegate NodeServiceHubDelegate open class NodeServiceHubDelegate : NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation Constructors Name Summary init NodeServiceHubDelegate(serviceHub: ServiceHub, defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based NodeServiceDelegate implementation Properties Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name serviceHub val serviceHub: ServiceHub Functions Name Summary partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inherited Functions Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name Inheritors Name Summary StateServiceHubDelegate open class StateServiceHubDelegate T : ContractState : NodeServiceHubDelegate , StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/#nodeservicehubdelegate","text":"open class NodeServiceHubDelegate : NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation","title":"NodeServiceHubDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/#constructors","text":"Name Summary init NodeServiceHubDelegate(serviceHub: ServiceHub, defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based NodeServiceDelegate implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/#properties","text":"Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name serviceHub val serviceHub: ServiceHub","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/#functions","text":"Name Summary partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/#inherited-functions","text":"Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/#inheritors","text":"Name Summary StateServiceHubDelegate open class StateServiceHubDelegate T : ContractState : NodeServiceHubDelegate , StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceHubDelegate / init init NodeServiceHubDelegate(serviceHub: ServiceHub, defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based NodeServiceDelegate implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/-init-/#init","text":"NodeServiceHubDelegate(serviceHub: ServiceHub, defaults: ServiceDefaults = ServiceDefaults()) ServiceHub -based NodeServiceDelegate implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/defaults/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceHubDelegate / defaults defaults open val defaults: ServiceDefaults Overrides NodeServiceDelegate.defaults","title":"Defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/defaults/#defaults","text":"open val defaults: ServiceDefaults Overrides NodeServiceDelegate.defaults","title":"defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/node-identity-criteria/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceHubDelegate / nodeIdentityCriteria nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria Overrides NodeServiceDelegate.nodeIdentityCriteria","title":"Node identity criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/node-identity-criteria/#nodeidentitycriteria","text":"open val nodeIdentityCriteria: LinearStateQueryCriteria Overrides NodeServiceDelegate.nodeIdentityCriteria","title":"nodeIdentityCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/node-identity/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceHubDelegate / nodeIdentity nodeIdentity open val nodeIdentity: Party Overrides NodeServiceDelegate.nodeIdentity","title":"Node identity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/node-identity/#nodeidentity","text":"open val nodeIdentity: Party Overrides NodeServiceDelegate.nodeIdentity","title":"nodeIdentity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/node-legal-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceHubDelegate / nodeLegalName nodeLegalName open val nodeLegalName: CordaX500Name Overrides NodeServiceDelegate.nodeLegalName","title":"Node legal name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/node-legal-name/#nodelegalname","text":"open val nodeLegalName: CordaX500Name Overrides NodeServiceDelegate.nodeLegalName","title":"nodeLegalName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/parties-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceHubDelegate / partiesFromName partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Overrides NodeServiceDelegate.partiesFromName Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. Parameters query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parties from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/parties-from-name/#partiesfromname","text":"open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Overrides NodeServiceDelegate.partiesFromName Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted.","title":"partiesFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/parties-from-name/#parameters","text":"query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceHubDelegate / queryBy queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Overrides NodeServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/query-by/#queryby","text":"open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Overrides NodeServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/service-hub/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceHubDelegate / serviceHub serviceHub val serviceHub: ServiceHub","title":"Service hub"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/service-hub/#servicehub","text":"val serviceHub: ServiceHub","title":"serviceHub"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceHubDelegate / trackBy trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Overrides NodeServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/track-by/#trackby","text":"open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Overrides NodeServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/well-known-party-from-x500-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceHubDelegate / wellKnownPartyFromX500Name wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Overrides NodeServiceDelegate.wellKnownPartyFromX500Name Returns a Party match for the given CordaX500Name if found, null otherwise Parameters name - The name to convert to a party","title":"Well known party from x500 name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/well-known-party-from-x500-name/#wellknownpartyfromx500name","text":"open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Overrides NodeServiceDelegate.wellKnownPartyFromX500Name Returns a Party match for the given CordaX500Name if found, null otherwise","title":"wellKnownPartyFromX500Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-hub-delegate/well-known-party-from-x500-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-connection-delegate/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcConnectionDelegate NodeServiceRpcConnectionDelegate open class NodeServiceRpcConnectionDelegate : NodeServiceRpcDelegateBase NodeRpcConnection -based NodeServiceDelegate implementation Constructors Name Summary init NodeServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based NodeServiceDelegate implementation Properties Name Summary defaults open val defaults: ServiceDefaults rpcOps open val rpcOps: CordaRPCOps Inherited Properties Name Summary nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name Inherited Functions Name Summary partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inheritors Name Summary StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate T : ContractState : NodeServiceRpcConnectionDelegate , StateServiceDelegate T NodeRpcConnection -based StateServiceDelegate implementation","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-connection-delegate/#nodeservicerpcconnectiondelegate","text":"open class NodeServiceRpcConnectionDelegate : NodeServiceRpcDelegateBase NodeRpcConnection -based NodeServiceDelegate implementation","title":"NodeServiceRpcConnectionDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-connection-delegate/#constructors","text":"Name Summary init NodeServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based NodeServiceDelegate implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-connection-delegate/#properties","text":"Name Summary defaults open val defaults: ServiceDefaults rpcOps open val rpcOps: CordaRPCOps","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-connection-delegate/#inherited-properties","text":"Name Summary nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-connection-delegate/#inherited-functions","text":"Name Summary partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-connection-delegate/#inheritors","text":"Name Summary StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate T : ContractState : NodeServiceRpcConnectionDelegate , StateServiceDelegate T NodeRpcConnection -based StateServiceDelegate implementation","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-connection-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcConnectionDelegate / init init NodeServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based NodeServiceDelegate implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-connection-delegate/-init-/#init","text":"NodeServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection , defaults: ServiceDefaults = ServiceDefaults()) NodeRpcConnection -based NodeServiceDelegate implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-connection-delegate/defaults/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcConnectionDelegate / defaults defaults open val defaults: ServiceDefaults Overrides NodeServiceRpcDelegateBase.defaults","title":"Defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-connection-delegate/defaults/#defaults","text":"open val defaults: ServiceDefaults Overrides NodeServiceRpcDelegateBase.defaults","title":"defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-connection-delegate/rpc-ops/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcConnectionDelegate / rpcOps rpcOps open val rpcOps: CordaRPCOps Overrides NodeServiceRpcDelegateBase.rpcOps","title":"Rpc ops"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-connection-delegate/rpc-ops/#rpcops","text":"open val rpcOps: CordaRPCOps Overrides NodeServiceRpcDelegateBase.rpcOps","title":"rpcOps"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcDelegate NodeServiceRpcDelegate open class NodeServiceRpcDelegate : NodeServiceRpcDelegateBase CordaRPCOps -based NodeServiceDelegate implementation Constructors Name Summary init NodeServiceRpcDelegate(rpcOps: CordaRPCOps, defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based NodeServiceDelegate implementation Properties Name Summary rpcOps open val rpcOps: CordaRPCOps Inherited Properties Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name Inherited Functions Name Summary partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inheritors Name Summary StateServiceRpcDelegate open class StateServiceRpcDelegate T : ContractState : NodeServiceRpcDelegate , StateServiceDelegate T CordaRPCOps -based StateServiceDelegate implementation","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate/#nodeservicerpcdelegate","text":"open class NodeServiceRpcDelegate : NodeServiceRpcDelegateBase CordaRPCOps -based NodeServiceDelegate implementation","title":"NodeServiceRpcDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate/#constructors","text":"Name Summary init NodeServiceRpcDelegate(rpcOps: CordaRPCOps, defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based NodeServiceDelegate implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate/#properties","text":"Name Summary rpcOps open val rpcOps: CordaRPCOps","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate/#inherited-properties","text":"Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate/#inherited-functions","text":"Name Summary partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate/#inheritors","text":"Name Summary StateServiceRpcDelegate open class StateServiceRpcDelegate T : ContractState : NodeServiceRpcDelegate , StateServiceDelegate T CordaRPCOps -based StateServiceDelegate implementation","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcDelegate / init init NodeServiceRpcDelegate(rpcOps: CordaRPCOps, defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based NodeServiceDelegate implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate/-init-/#init","text":"NodeServiceRpcDelegate(rpcOps: CordaRPCOps, defaults: ServiceDefaults = ServiceDefaults()) CordaRPCOps -based NodeServiceDelegate implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate/rpc-ops/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcDelegate / rpcOps rpcOps open val rpcOps: CordaRPCOps Overrides NodeServiceRpcDelegateBase.rpcOps","title":"Rpc ops"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate/rpc-ops/#rpcops","text":"open val rpcOps: CordaRPCOps Overrides NodeServiceRpcDelegateBase.rpcOps","title":"rpcOps"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcDelegateBase NodeServiceRpcDelegateBase abstract class NodeServiceRpcDelegateBase : NodeServiceDelegate RPC implementation base Constructors Name Summary init NodeServiceRpcDelegateBase(defaults: ServiceDefaults = ServiceDefaults()) RPC implementation base Properties Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name rpcOps abstract val rpcOps: CordaRPCOps Functions Name Summary partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inherited Functions Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name Inheritors Name Summary NodeServiceRpcConnectionDelegate open class NodeServiceRpcConnectionDelegate : NodeServiceRpcDelegateBase NodeRpcConnection -based NodeServiceDelegate implementation NodeServiceRpcDelegate open class NodeServiceRpcDelegate : NodeServiceRpcDelegateBase CordaRPCOps -based NodeServiceDelegate implementation","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/#nodeservicerpcdelegatebase","text":"abstract class NodeServiceRpcDelegateBase : NodeServiceDelegate RPC implementation base","title":"NodeServiceRpcDelegateBase"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/#constructors","text":"Name Summary init NodeServiceRpcDelegateBase(defaults: ServiceDefaults = ServiceDefaults()) RPC implementation base","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/#properties","text":"Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name rpcOps abstract val rpcOps: CordaRPCOps","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/#functions","text":"Name Summary partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/#inherited-functions","text":"Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/#inheritors","text":"Name Summary NodeServiceRpcConnectionDelegate open class NodeServiceRpcConnectionDelegate : NodeServiceRpcDelegateBase NodeRpcConnection -based NodeServiceDelegate implementation NodeServiceRpcDelegate open class NodeServiceRpcDelegate : NodeServiceRpcDelegateBase CordaRPCOps -based NodeServiceDelegate implementation","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcDelegateBase / init init NodeServiceRpcDelegateBase(defaults: ServiceDefaults = ServiceDefaults()) RPC implementation base","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/-init-/#init","text":"NodeServiceRpcDelegateBase(defaults: ServiceDefaults = ServiceDefaults()) RPC implementation base","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/defaults/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcDelegateBase / defaults defaults open val defaults: ServiceDefaults Overrides NodeServiceDelegate.defaults","title":"Defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/defaults/#defaults","text":"open val defaults: ServiceDefaults Overrides NodeServiceDelegate.defaults","title":"defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/node-identity-criteria/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcDelegateBase / nodeIdentityCriteria nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria Overrides NodeServiceDelegate.nodeIdentityCriteria","title":"Node identity criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/node-identity-criteria/#nodeidentitycriteria","text":"open val nodeIdentityCriteria: LinearStateQueryCriteria Overrides NodeServiceDelegate.nodeIdentityCriteria","title":"nodeIdentityCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/node-identity/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcDelegateBase / nodeIdentity nodeIdentity open val nodeIdentity: Party Overrides NodeServiceDelegate.nodeIdentity","title":"Node identity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/node-identity/#nodeidentity","text":"open val nodeIdentity: Party Overrides NodeServiceDelegate.nodeIdentity","title":"nodeIdentity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/node-legal-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcDelegateBase / nodeLegalName nodeLegalName open val nodeLegalName: CordaX500Name Overrides NodeServiceDelegate.nodeLegalName","title":"Node legal name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/node-legal-name/#nodelegalname","text":"open val nodeLegalName: CordaX500Name Overrides NodeServiceDelegate.nodeLegalName","title":"nodeLegalName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/parties-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcDelegateBase / partiesFromName partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Overrides NodeServiceDelegate.partiesFromName Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. Parameters query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parties from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/parties-from-name/#partiesfromname","text":"open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Overrides NodeServiceDelegate.partiesFromName Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted.","title":"partiesFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/parties-from-name/#parameters","text":"query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcDelegateBase / queryBy queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Overrides NodeServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/query-by/#queryby","text":"open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Overrides NodeServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/rpc-ops/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcDelegateBase / rpcOps rpcOps abstract val rpcOps: CordaRPCOps","title":"Rpc ops"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/rpc-ops/#rpcops","text":"abstract val rpcOps: CordaRPCOps","title":"rpcOps"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcDelegateBase / trackBy trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Overrides NodeServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/track-by/#trackby","text":"open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Overrides NodeServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/well-known-party-from-x500-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcDelegateBase / wellKnownPartyFromX500Name wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Overrides NodeServiceDelegate.wellKnownPartyFromX500Name Returns a Party match for the given CordaX500Name if found, null otherwise Parameters name - The name to convert to a party","title":"Well known party from x500 name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/well-known-party-from-x500-name/#wellknownpartyfromx500name","text":"open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Overrides NodeServiceDelegate.wellKnownPartyFromX500Name Returns a Party match for the given CordaX500Name if found, null otherwise","title":"wellKnownPartyFromX500Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-delegate-base/well-known-party-from-x500-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-state-not-found-exception/","text":"com.github.manosbatsis.vaultaire.service.node / StateNotFoundException StateNotFoundException class StateNotFoundException : RuntimeException Constructors Name Summary init StateNotFoundException(id: String, stateType: Class * )","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-state-not-found-exception/#statenotfoundexception","text":"class StateNotFoundException : RuntimeException","title":"StateNotFoundException"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-state-not-found-exception/#constructors","text":"Name Summary init StateNotFoundException(id: String, stateType: Class * )","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-state-not-found-exception/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / StateNotFoundException / init init StateNotFoundException(id: String, stateType: Class * )","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-state-not-found-exception/-init-/#init","text":"StateNotFoundException(id: String, stateType: Class * )","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/","text":"com.github.manosbatsis.vaultaire.util Package com.github.manosbatsis.vaultaire.util Types Name Summary Fields interface Fields T Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type FieldWrapper interface FieldWrapper T GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Extensions for External Classes Name Summary kotlin.String","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/#package-comgithubmanosbatsisvaultaireutil","text":"","title":"Package com.github.manosbatsis.vaultaire.util"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/#types","text":"Name Summary Fields interface Fields T Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type FieldWrapper interface FieldWrapper T GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/#extensions-for-external-classes","text":"Name Summary kotlin.String","title":"Extensions for External Classes"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / FieldWrapper FieldWrapper interface FieldWrapper T Properties Name Summary property abstract val property: KProperty1 T , * Inheritors Name Summary TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/#fieldwrapper","text":"interface FieldWrapper T","title":"FieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/#properties","text":"Name Summary property abstract val property: KProperty1 T , *","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/#inheritors","text":"Name Summary TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / FieldWrapper / property property abstract val property: KProperty1 T , *","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/property/#property","text":"abstract val property: KProperty1 T , *","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/","text":"com.github.manosbatsis.vaultaire.util / Fields Fields interface Fields T Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type Properties Name Summary fieldsByName abstract val fieldsByName: Map String, FieldWrapper T Functions Name Summary contains open fun contains(name: String): Boolean get open operator fun get(name: String): FieldWrapper T","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/#fields","text":"interface Fields T Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/#properties","text":"Name Summary fieldsByName abstract val fieldsByName: Map String, FieldWrapper T","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/#functions","text":"Name Summary contains open fun contains(name: String): Boolean get open operator fun get(name: String): FieldWrapper T","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/contains/","text":"com.github.manosbatsis.vaultaire.util / Fields / contains contains open fun contains(name: String): Boolean","title":"Contains"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/contains/#contains","text":"open fun contains(name: String): Boolean","title":"contains"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/fields-by-name/","text":"com.github.manosbatsis.vaultaire.util / Fields / fieldsByName fieldsByName abstract val fieldsByName: Map String, FieldWrapper T","title":"Fields by name"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/fields-by-name/#fieldsbyname","text":"abstract val fieldsByName: Map String, FieldWrapper T","title":"fieldsByName"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/get/","text":"com.github.manosbatsis.vaultaire.util / Fields / get get open operator fun get(name: String): FieldWrapper T","title":"Get"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/get/#get","text":"open operator fun get(name: String): FieldWrapper T","title":"get"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / GenericFieldWrapper GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Constructors Name Summary init GenericFieldWrapper(property: KProperty1 T , S ) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Properties Name Summary property val property: KProperty1 T , S","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/#genericfieldwrapper","text":"class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"GenericFieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/#constructors","text":"Name Summary init GenericFieldWrapper(property: KProperty1 T , S ) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/#properties","text":"Name Summary property val property: KProperty1 T , S","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/-init-/","text":"com.github.manosbatsis.vaultaire.util / GenericFieldWrapper / init init GenericFieldWrapper(property: KProperty1 T , S ) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/-init-/#init","text":"GenericFieldWrapper(property: KProperty1 T , S ) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / GenericFieldWrapper / property property val property: KProperty1 T , S Overrides TypedFieldWrapper.property","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/property/#property","text":"val property: KProperty1 T , S Overrides TypedFieldWrapper.property","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / NullableGenericFieldWrapper NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Constructors Name Summary init NullableGenericFieldWrapper(property: KProperty1 T , S ? ) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Properties Name Summary property val property: KProperty1 T , S ?","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/#nullablegenericfieldwrapper","text":"class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"NullableGenericFieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/#constructors","text":"Name Summary init NullableGenericFieldWrapper(property: KProperty1 T , S ? ) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/#properties","text":"Name Summary property val property: KProperty1 T , S ?","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/-init-/","text":"com.github.manosbatsis.vaultaire.util / NullableGenericFieldWrapper / init init NullableGenericFieldWrapper(property: KProperty1 T , S ? ) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/-init-/#init","text":"NullableGenericFieldWrapper(property: KProperty1 T , S ? ) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / NullableGenericFieldWrapper / property property val property: KProperty1 T , S ? Overrides TypedFieldWrapper.property","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/property/#property","text":"val property: KProperty1 T , S ? Overrides TypedFieldWrapper.property","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / TypedFieldWrapper TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Properties Name Summary property abstract val property: KProperty1 T , S Inheritors Name Summary GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/#typedfieldwrapper","text":"interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"TypedFieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/#properties","text":"Name Summary property abstract val property: KProperty1 T , S","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/#inheritors","text":"Name Summary GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / TypedFieldWrapper / property property abstract val property: KProperty1 T , S Overrides FieldWrapper.property","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/property/#property","text":"abstract val property: KProperty1 T , S Overrides FieldWrapper.property","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/","text":"com.github.manosbatsis.vaultaire.util / kotlin.String Extensions for kotlin.String Name Summary asUniqueIdentifier fun String.asUniqueIdentifier(): UniqueIdentifier","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/#extensions-for-kotlinstring","text":"Name Summary asUniqueIdentifier fun String.asUniqueIdentifier(): UniqueIdentifier","title":"Extensions for kotlin.String"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/as-unique-identifier/","text":"com.github.manosbatsis.vaultaire.util / kotlin.String / asUniqueIdentifier asUniqueIdentifier fun String.asUniqueIdentifier(): UniqueIdentifier","title":"As unique identifier"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/as-unique-identifier/#asuniqueidentifier","text":"fun String.asUniqueIdentifier(): UniqueIdentifier","title":"asUniqueIdentifier"}]}