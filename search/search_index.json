{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Vaultaire Query DSL and data access utilities for Corda developers. Query DSL Use DSL will make your queries much easier to read and maintain. Each query DSL is automatically (re)generated at build time using annotation processing. Usage example: val queryCriteria : QueryCriteria = booksQuery { and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` Corda Books Ltd. or { fields . title ` == ` A book on Corda fields . author ` != ` John Doe } } orderBy { fields . title sort DESC } }. toCriteria () For more details see Query DSL . State Services Vaultaire s StateService interface provide a simple, consistent API to load, query and track vault states. StateService implementations are usually auto-generated at build time and specific to a single ContractState type. State Services can also decouple you code from ServiceHub and CordaRPCOps amd help increase code reuse between cordapps and their clients. For more details see State Services . State DTOs Maintaining Data Transfer Objects for your contract states can be a mundane, error-prone task. Vaultaire\u2019s annotation processing automates this by (re)generating those DTOs for you. For more info checkout State DTOs Other Utils Vaultaire includes a few other utilities like annotations to generate Data Transfer Objects for your contract states and responding flows from commonly used supertypes. For more info checkout Other Utilities","title":"Overview"},{"location":"#vaultaire","text":"Query DSL and data access utilities for Corda developers.","title":"Vaultaire"},{"location":"#query-dsl","text":"Use DSL will make your queries much easier to read and maintain. Each query DSL is automatically (re)generated at build time using annotation processing. Usage example: val queryCriteria : QueryCriteria = booksQuery { and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` Corda Books Ltd. or { fields . title ` == ` A book on Corda fields . author ` != ` John Doe } } orderBy { fields . title sort DESC } }. toCriteria () For more details see Query DSL .","title":"Query DSL"},{"location":"#state-services","text":"Vaultaire s StateService interface provide a simple, consistent API to load, query and track vault states. StateService implementations are usually auto-generated at build time and specific to a single ContractState type. State Services can also decouple you code from ServiceHub and CordaRPCOps amd help increase code reuse between cordapps and their clients. For more details see State Services .","title":"State Services"},{"location":"#state-dtos","text":"Maintaining Data Transfer Objects for your contract states can be a mundane, error-prone task. Vaultaire\u2019s annotation processing automates this by (re)generating those DTOs for you. For more info checkout State DTOs","title":"State DTOs"},{"location":"#other-utils","text":"Vaultaire includes a few other utilities like annotations to generate Data Transfer Objects for your contract states and responding flows from commonly used supertypes. For more info checkout Other Utilities","title":"Other Utils"},{"location":"changelog/","text":"Changelog The following sections describe major changes per version and can be helpful with version upgrades. 0.28 Fixed generated DTOs missing @CordaSerializable (Service) Registry is now more accessible Fixed service defaults parameter type from SimpleServiceDefaults to interface ServiceDefaults in NodeService, StateService and delegates Fixed pool-based initialization of services from network service 0.26-27 Bumped Corda to OS 4.5 Refactored to support RPC connection pooling based on Corda RPC PoolBoy 0.25 Bumped Corda to OS 4.4 Added support for lite DTO strategy Added Query DSL root externalIds property to support querying the vault by Corda Account(s) 0.24 Added default parameter value false to VaultQueryCriteriaCondition.toCriteria(boolean) , so that aggregates are not ignored by default. 0.23 Fixed corda API design issue, where a secondary VaultCustomQueryCriteria s implicit/default status of UNCONSUMED (VS null) is applied, overriding the root DSL status 0.22 Bumped kotlin-utils, fixing issue with DTO generation including companion object members of the source type. 0.21 Bumped KotlinPoet, util versions Added @DefaultValue example in the docs 0.20 Added CordaSerializable annotation to generated DTOs Added ignoreProperties to VaultaireGenerateDto and VaultaireGenerateDtoForDependency , useful with derived/backed properties like participants 0.19 Added [NodeRpcConnection] interface and [StateServiceRpcConnectionDelegate] for libraries in need of more flexible [StateServiceDelegate] integration e.g. Corbeans/Spring or other IoC containers 0.18 Bumped deps i.e. Corda to OS 4.3 0.17 Added support for sorting based on standard attributes and aliases of those, i.e. enum values of Sort.CommonStateAttribute , Sort.VaultStateAttribute , Sort.LinearStateAttribute and Sort.FungibleStateAttribute . 0.16 Added copyAnnotationPackages property to VaultaireGenerateDto and VaultaireGenerateDtoForDependency . The property can be used to define a list of base packages for matching annotations to be copied automatically from a source ContractState to it s generated DTO. This is useful when replication of e.g. Jackson or Bean Validation annotations can be useful. 0.15 Replaced com.github.manosbatsis.vaultaire.dto.Dto and com.github.manosbatsis.vaultaire.util.DtoInsufficientStateMappingException with kotlin-utils equivalents extracted there. You may need to update package/method names in your code if you make use of generated DTOs. 0.14 Vaultaire s *ForDependency annotations now use the annotated element s package (suffixed with .generated ) for output. This leaves the original (state) packages exclusive to their modules if needed, avoiding when cordapp package conflicts while testing. 0.13 Add support for final responder flow supertypes in VaultaireGenerateResponder 0.12 Fixed dependency scope for kotlin-utils 0.11 Added VaultaireGenerateDto , VaultaireGenerateDtoForDependency annotations for generating DTOs for contract states Added VaultaireGenerateResponder annotation for generating responder flows extending common supertypes Refactored to extract kotlin-utils 0.10 Added @VaultaireGenerateForDependency to support generation (of DSL, Services etc.) for states contributed to the classpath by project dependencies Enhanced generated subclasses of ExtendedStateService with DSL-aware buildQuery , queryBy and trackBy Fixed typo from VaultaireGenerate.constractStateType to VaultaireGenerate.contractStateType 0.9 0.8 re-release fix 0.8 Allow annotation processing to generate code to another Gradle module or location using the kapt.kotlin.vaultaire.generated kapt argument, see installation docs. 0.7 Fixed, improved and added tests for StateService get/find by id/externalId methods StateService get by id/externalId will throw a StateNotFoundException when no match is found 0.6 Added support for aggregate functions . Added getByExternalId and findByExternalId methods to StateService Added optional Vault.RelevancyStatus parameter to StateService getByLinearId and findByLinearId methods 0.5 Removed param from String.asUniqueIdentifier() 0.4 Fixed handling of nullable fields Added string input signatures for getByLinearId , findByLinearId 0.3 Refactored StateService to an interface 0.2 Renamed VaultQueryDsl annotation to VaultaireGenerate Renamed StateService to BasicStateService , added extended StateService type. The annotation processor will now generate a subclass of StateService per annotated PersistentState 0.1 Initial release","title":"Change Log"},{"location":"changelog/#changelog","text":"The following sections describe major changes per version and can be helpful with version upgrades.","title":"Changelog"},{"location":"changelog/#028","text":"Fixed generated DTOs missing @CordaSerializable (Service) Registry is now more accessible Fixed service defaults parameter type from SimpleServiceDefaults to interface ServiceDefaults in NodeService, StateService and delegates Fixed pool-based initialization of services from network service","title":"0.28"},{"location":"changelog/#026-27","text":"Bumped Corda to OS 4.5 Refactored to support RPC connection pooling based on Corda RPC PoolBoy","title":"0.26-27"},{"location":"changelog/#025","text":"Bumped Corda to OS 4.4 Added support for lite DTO strategy Added Query DSL root externalIds property to support querying the vault by Corda Account(s)","title":"0.25"},{"location":"changelog/#024","text":"Added default parameter value false to VaultQueryCriteriaCondition.toCriteria(boolean) , so that aggregates are not ignored by default.","title":"0.24"},{"location":"changelog/#023","text":"Fixed corda API design issue, where a secondary VaultCustomQueryCriteria s implicit/default status of UNCONSUMED (VS null) is applied, overriding the root DSL status","title":"0.23"},{"location":"changelog/#022","text":"Bumped kotlin-utils, fixing issue with DTO generation including companion object members of the source type.","title":"0.22"},{"location":"changelog/#021","text":"Bumped KotlinPoet, util versions Added @DefaultValue example in the docs","title":"0.21"},{"location":"changelog/#020","text":"Added CordaSerializable annotation to generated DTOs Added ignoreProperties to VaultaireGenerateDto and VaultaireGenerateDtoForDependency , useful with derived/backed properties like participants","title":"0.20"},{"location":"changelog/#019","text":"Added [NodeRpcConnection] interface and [StateServiceRpcConnectionDelegate] for libraries in need of more flexible [StateServiceDelegate] integration e.g. Corbeans/Spring or other IoC containers","title":"0.19"},{"location":"changelog/#018","text":"Bumped deps i.e. Corda to OS 4.3","title":"0.18"},{"location":"changelog/#017","text":"Added support for sorting based on standard attributes and aliases of those, i.e. enum values of Sort.CommonStateAttribute , Sort.VaultStateAttribute , Sort.LinearStateAttribute and Sort.FungibleStateAttribute .","title":"0.17"},{"location":"changelog/#016","text":"Added copyAnnotationPackages property to VaultaireGenerateDto and VaultaireGenerateDtoForDependency . The property can be used to define a list of base packages for matching annotations to be copied automatically from a source ContractState to it s generated DTO. This is useful when replication of e.g. Jackson or Bean Validation annotations can be useful.","title":"0.16"},{"location":"changelog/#015","text":"Replaced com.github.manosbatsis.vaultaire.dto.Dto and com.github.manosbatsis.vaultaire.util.DtoInsufficientStateMappingException with kotlin-utils equivalents extracted there. You may need to update package/method names in your code if you make use of generated DTOs.","title":"0.15"},{"location":"changelog/#014","text":"Vaultaire s *ForDependency annotations now use the annotated element s package (suffixed with .generated ) for output. This leaves the original (state) packages exclusive to their modules if needed, avoiding when cordapp package conflicts while testing.","title":"0.14"},{"location":"changelog/#013","text":"Add support for final responder flow supertypes in VaultaireGenerateResponder","title":"0.13"},{"location":"changelog/#012","text":"Fixed dependency scope for kotlin-utils","title":"0.12"},{"location":"changelog/#011","text":"Added VaultaireGenerateDto , VaultaireGenerateDtoForDependency annotations for generating DTOs for contract states Added VaultaireGenerateResponder annotation for generating responder flows extending common supertypes Refactored to extract kotlin-utils","title":"0.11"},{"location":"changelog/#010","text":"Added @VaultaireGenerateForDependency to support generation (of DSL, Services etc.) for states contributed to the classpath by project dependencies Enhanced generated subclasses of ExtendedStateService with DSL-aware buildQuery , queryBy and trackBy Fixed typo from VaultaireGenerate.constractStateType to VaultaireGenerate.contractStateType","title":"0.10"},{"location":"changelog/#09","text":"0.8 re-release fix","title":"0.9"},{"location":"changelog/#08","text":"Allow annotation processing to generate code to another Gradle module or location using the kapt.kotlin.vaultaire.generated kapt argument, see installation docs.","title":"0.8"},{"location":"changelog/#07","text":"Fixed, improved and added tests for StateService get/find by id/externalId methods StateService get by id/externalId will throw a StateNotFoundException when no match is found","title":"0.7"},{"location":"changelog/#06","text":"Added support for aggregate functions . Added getByExternalId and findByExternalId methods to StateService Added optional Vault.RelevancyStatus parameter to StateService getByLinearId and findByLinearId methods","title":"0.6"},{"location":"changelog/#05","text":"Removed param from String.asUniqueIdentifier()","title":"0.5"},{"location":"changelog/#04","text":"Fixed handling of nullable fields Added string input signatures for getByLinearId , findByLinearId","title":"0.4"},{"location":"changelog/#03","text":"Refactored StateService to an interface","title":"0.3"},{"location":"changelog/#02","text":"Renamed VaultQueryDsl annotation to VaultaireGenerate Renamed StateService to BasicStateService , added extended StateService type. The annotation processor will now generate a subclass of StateService per annotated PersistentState","title":"0.2"},{"location":"changelog/#01","text":"Initial release","title":"0.1"},{"location":"credits/","text":"Credits The following projects where of great help in creating my first DSL: AutoDsl , SqlDsl and of course the amazing KotlinPoet","title":"Credits"},{"location":"credits/#credits","text":"The following projects where of great help in creating my first DSL: AutoDsl , SqlDsl and of course the amazing KotlinPoet","title":"Credits"},{"location":"faq/","text":"Frequently Asked Questions Answers to common questions. License: Can I use Vaultaire with my project? Yes, Vaultaire can be used as a library/dependency with no side-effect to your project. Vaultaire is distributed under the GNU Lesser General Public License or LGPL, the same license adopted by Corda dependencies like Hibernate. Use with Corda Enterprise To use Vaultaire with Corda Enterprise, you will have to update your build to use the CE release . After switching to the appropriate corda_release_group and corda_release_version in your ext section, you can instruct your build to substitute transitive Corda OS dependencies with their CE equivalents: allprojects { //... configurations { all { //... resolutionStrategy { // ... eachDependency { DependencyResolveDetails details - // Exclude from substitutions as appropriate, e.g. def exclusions = [ corda-finance-contracts ] // Substitute the rest, assumes `ext.corda_release_group` and `ext.corda_release_version` are set if ( details . requested . group == net.corda ! exclusions . contains ( details . requested . name )) { // Force Corda Enterprise details . useTarget group: corda_release_group , name: details . requested . name , version: corda_release_version } } } } } } Note : The above assumes ext.corda_release_group and ext.corda_release_version are already set, e.g. to com.r3.corda and 4.2 respectively.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"Answers to common questions.","title":"Frequently Asked Questions"},{"location":"faq/#license-can-i-use-vaultaire-with-my-project","text":"Yes, Vaultaire can be used as a library/dependency with no side-effect to your project. Vaultaire is distributed under the GNU Lesser General Public License or LGPL, the same license adopted by Corda dependencies like Hibernate.","title":"License: Can I use Vaultaire with my project?"},{"location":"faq/#use-with-corda-enterprise","text":"To use Vaultaire with Corda Enterprise, you will have to update your build to use the CE release . After switching to the appropriate corda_release_group and corda_release_version in your ext section, you can instruct your build to substitute transitive Corda OS dependencies with their CE equivalents: allprojects { //... configurations { all { //... resolutionStrategy { // ... eachDependency { DependencyResolveDetails details - // Exclude from substitutions as appropriate, e.g. def exclusions = [ corda-finance-contracts ] // Substitute the rest, assumes `ext.corda_release_group` and `ext.corda_release_version` are set if ( details . requested . group == net.corda ! exclusions . contains ( details . requested . name )) { // Force Corda Enterprise details . useTarget group: corda_release_group , name: details . requested . name , version: corda_release_version } } } } } } Note : The above assumes ext.corda_release_group and ext.corda_release_version are already set, e.g. to com.r3.corda and 4.2 respectively.","title":"Use with Corda Enterprise"},{"location":"installation/","text":"Installation For Cordapps Add to your Cordapp s Gradle dependencies: // apply the kapt plugin apply plugin: kotlin-kapt // Optional: for IntelliJ users, see also sourceSets bellow apply plugin: idea dependencies { // Core dependency cordaCompile com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version // Annotation processing kapt com.github.manosbatsis.vaultaire:vaultaire-processor:$vaultaire_version // Corda dependencies etc. // ... } You may also want to add the generated sources to your build s sourceSets // Define an extra sources variable def generatedSourcesDir = project . file ( build/generated/source/kaptKotlin/main ) // Tell Gradle about the extra source set sourceSets { main { kotlin . srcDirs += generatedSourcesDir } } // Optional: Tell IntelliJ about the extra source set idea { module { sourceDirs += generatedSourcesDir generatedSourceDirs += generatedSourcesDir } } Note that setting kotlin.incremental=true in gradle.properties may break non-clean builds earlier versions of kotlin like 1.2.71 - if you enable incremental then you ll need to ./gradlew clean when building. For Client Apps The core module can also be useful outside a cordapp, e.g. in a Spring application interacting with Corda nodes via RPC: // Core dependency compile com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version // Corda dependencies etc. // ...","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#for-cordapps","text":"Add to your Cordapp s Gradle dependencies: // apply the kapt plugin apply plugin: kotlin-kapt // Optional: for IntelliJ users, see also sourceSets bellow apply plugin: idea dependencies { // Core dependency cordaCompile com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version // Annotation processing kapt com.github.manosbatsis.vaultaire:vaultaire-processor:$vaultaire_version // Corda dependencies etc. // ... } You may also want to add the generated sources to your build s sourceSets // Define an extra sources variable def generatedSourcesDir = project . file ( build/generated/source/kaptKotlin/main ) // Tell Gradle about the extra source set sourceSets { main { kotlin . srcDirs += generatedSourcesDir } } // Optional: Tell IntelliJ about the extra source set idea { module { sourceDirs += generatedSourcesDir generatedSourceDirs += generatedSourcesDir } } Note that setting kotlin.incremental=true in gradle.properties may break non-clean builds earlier versions of kotlin like 1.2.71 - if you enable incremental then you ll need to ./gradlew clean when building.","title":"For Cordapps"},{"location":"installation/#for-client-apps","text":"The core module can also be useful outside a cordapp, e.g. in a Spring application interacting with Corda nodes via RPC: // Core dependency compile com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version // Corda dependencies etc. // ...","title":"For Client Apps"},{"location":"0.x/","text":"Packages Name Summary com.github.manosbatsis.vaultaire.annotation com.github.manosbatsis.vaultaire.dsl.contract com.github.manosbatsis.vaultaire.dsl.query com.github.manosbatsis.vaultaire.dto com.github.manosbatsis.vaultaire.dto.attachment com.github.manosbatsis.vaultaire.dto.info com.github.manosbatsis.vaultaire.registry com.github.manosbatsis.vaultaire.service com.github.manosbatsis.vaultaire.service.dao com.github.manosbatsis.vaultaire.service.node com.github.manosbatsis.vaultaire.util Index All Types","title":"Home"},{"location":"0.x/#packages","text":"Name Summary com.github.manosbatsis.vaultaire.annotation com.github.manosbatsis.vaultaire.dsl.contract com.github.manosbatsis.vaultaire.dsl.query com.github.manosbatsis.vaultaire.dto com.github.manosbatsis.vaultaire.dto.attachment com.github.manosbatsis.vaultaire.dto.info com.github.manosbatsis.vaultaire.registry com.github.manosbatsis.vaultaire.service com.github.manosbatsis.vaultaire.service.dao com.github.manosbatsis.vaultaire.service.node com.github.manosbatsis.vaultaire.util","title":"Packages"},{"location":"0.x/#index","text":"All Types","title":"Index"},{"location":"0.x/alltypes/","text":"All Types Name Summary com.github.manosbatsis.vaultaire.service.node.AbstractNodeServiceHubDelegate ServiceHub -based NodeServiceDelegate implementation com.github.manosbatsis.vaultaire.dto.AccountParty Convenient participant type that combines a known Corda Account ID with a corresponding anonymous party. com.github.manosbatsis.vaultaire.dsl.query.Aggregates Used to define aggregation criteria com.github.manosbatsis.vaultaire.dsl.query.AndCondition Defines a set of conditions where all items must be matched com.github.manosbatsis.vaultaire.dto.attachment.Attachment Data transfer object representing an attachment to be persisted in the vault com.github.manosbatsis.vaultaire.dto.attachment.AttachmentFile Data transfer object representing an attachment file to be persisted in the vault com.github.manosbatsis.vaultaire.dto.attachment.AttachmentReceipt Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable. com.github.manosbatsis.vaultaire.service.node.BasicNodeService Basic NodeService implementation com.github.manosbatsis.vaultaire.service.dao.BasicStateService Basic StateService implementation, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.dsl.query.CompositeCondition A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. com.github.manosbatsis.vaultaire.dsl.query.Condition Condition interface com.github.manosbatsis.vaultaire.dsl.query.ConditionsCondition A Condition that contains other conditions. Allows for nested and/or condition groups com.github.manosbatsis.vaultaire.dsl.contract.ContractConditions com.github.manosbatsis.vaultaire.service.dao.DefaultExtendedStateService Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . com.github.manosbatsis.vaultaire.dto.info.ExtendedNodeInfo com.github.manosbatsis.vaultaire.service.dao.ExtendedStateService com.github.manosbatsis.vaultaire.annotation.ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type com.github.manosbatsis.vaultaire.util.Fields Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type com.github.manosbatsis.vaultaire.util.FieldWrapper com.github.manosbatsis.vaultaire.util.GenericFieldWrapper Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.dto.info.NetworkInfo com.github.manosbatsis.vaultaire.service.node.NodeCordaServiceDelegate Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService com.github.manosbatsis.vaultaire.service.node.NodeService Short-lived helper, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.service.node.NodeServiceDelegate NodeService delegate for vault operations com.github.manosbatsis.vaultaire.service.node.NodeServiceRpcPoolBoyDelegate RPC implementation base com.github.manosbatsis.vaultaire.service.node.NotFoundException com.github.manosbatsis.vaultaire.util.NullableGenericFieldWrapper Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.dsl.query.OrCondition Defines a set of conditions where at least a single item must be matched com.github.manosbatsis.vaultaire.registry.Registry com.github.manosbatsis.vaultaire.dsl.query.RootCondition com.github.manosbatsis.vaultaire.service.ServiceDefaults com.github.manosbatsis.vaultaire.service.SimpleServiceDefaults Define option defaults for StateService instances com.github.manosbatsis.vaultaire.dsl.query.SortColumns Used to define Sort.SortColumn s com.github.manosbatsis.vaultaire.service.dao.StateCordaServiceDelegate Implementation of StateServiceDelegate as a CordaService com.github.manosbatsis.vaultaire.service.dao.StateService Short-lived helper, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.service.dao.StateServiceDelegate StateService delegate for vault operations com.github.manosbatsis.vaultaire.service.dao.StateServiceHubDelegate ServiceHub -based StateServiceDelegate implementation com.github.manosbatsis.vaultaire.service.dao.StateServicePoolBoyDelegate com.github.manosbatsis.vaultaire.service.dao.StateServiceRpcConnectionDelegate NodeRpcConnection -based StateServiceDelegate implementation kotlin.String (extensions in package com.github.manosbatsis.vaultaire.util) com.github.manosbatsis.vaultaire.dsl.query.TimeConsumedCondition com.github.manosbatsis.vaultaire.dsl.query.TimeInstantTypeCondition com.github.manosbatsis.vaultaire.dsl.query.TimeRecordedCondition com.github.manosbatsis.vaultaire.util.TypedFieldWrapper Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.annotation.VaultaireAccountInfo Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty . com.github.manosbatsis.vaultaire.dto.VaultaireBaseLiteDto Modeled after com.github.manosbatsis.kotlin.utils.api.Dto only bringing a StateService in-context for toTargetType and toPatched . com.github.manosbatsis.vaultaire.annotation.VaultaireDependencyAnnotationConvention com.github.manosbatsis.vaultaire.annotation.VaultaireDtoStrategyKeys com.github.manosbatsis.vaultaire.annotation.VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateResponder Generate a responser flow that extends the given type. com.github.manosbatsis.vaultaire.dto.VaultaireLiteDto com.github.manosbatsis.vaultaire.dsl.query.VaultCustomQueryCriteriaWrapperCondition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. com.github.manosbatsis.vaultaire.dsl.query.VaultQueryCriteriaCondition A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort com.github.manosbatsis.vaultaire.dsl.contract.When","title":"Home"},{"location":"0.x/alltypes/#all-types","text":"Name Summary com.github.manosbatsis.vaultaire.service.node.AbstractNodeServiceHubDelegate ServiceHub -based NodeServiceDelegate implementation com.github.manosbatsis.vaultaire.dto.AccountParty Convenient participant type that combines a known Corda Account ID with a corresponding anonymous party. com.github.manosbatsis.vaultaire.dsl.query.Aggregates Used to define aggregation criteria com.github.manosbatsis.vaultaire.dsl.query.AndCondition Defines a set of conditions where all items must be matched com.github.manosbatsis.vaultaire.dto.attachment.Attachment Data transfer object representing an attachment to be persisted in the vault com.github.manosbatsis.vaultaire.dto.attachment.AttachmentFile Data transfer object representing an attachment file to be persisted in the vault com.github.manosbatsis.vaultaire.dto.attachment.AttachmentReceipt Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable. com.github.manosbatsis.vaultaire.service.node.BasicNodeService Basic NodeService implementation com.github.manosbatsis.vaultaire.service.dao.BasicStateService Basic StateService implementation, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.dsl.query.CompositeCondition A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. com.github.manosbatsis.vaultaire.dsl.query.Condition Condition interface com.github.manosbatsis.vaultaire.dsl.query.ConditionsCondition A Condition that contains other conditions. Allows for nested and/or condition groups com.github.manosbatsis.vaultaire.dsl.contract.ContractConditions com.github.manosbatsis.vaultaire.service.dao.DefaultExtendedStateService Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . com.github.manosbatsis.vaultaire.dto.info.ExtendedNodeInfo com.github.manosbatsis.vaultaire.service.dao.ExtendedStateService com.github.manosbatsis.vaultaire.annotation.ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type com.github.manosbatsis.vaultaire.util.Fields Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type com.github.manosbatsis.vaultaire.util.FieldWrapper com.github.manosbatsis.vaultaire.util.GenericFieldWrapper Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.dto.info.NetworkInfo com.github.manosbatsis.vaultaire.service.node.NodeCordaServiceDelegate Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService com.github.manosbatsis.vaultaire.service.node.NodeService Short-lived helper, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.service.node.NodeServiceDelegate NodeService delegate for vault operations com.github.manosbatsis.vaultaire.service.node.NodeServiceRpcPoolBoyDelegate RPC implementation base com.github.manosbatsis.vaultaire.service.node.NotFoundException com.github.manosbatsis.vaultaire.util.NullableGenericFieldWrapper Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.dsl.query.OrCondition Defines a set of conditions where at least a single item must be matched com.github.manosbatsis.vaultaire.registry.Registry com.github.manosbatsis.vaultaire.dsl.query.RootCondition com.github.manosbatsis.vaultaire.service.ServiceDefaults com.github.manosbatsis.vaultaire.service.SimpleServiceDefaults Define option defaults for StateService instances com.github.manosbatsis.vaultaire.dsl.query.SortColumns Used to define Sort.SortColumn s com.github.manosbatsis.vaultaire.service.dao.StateCordaServiceDelegate Implementation of StateServiceDelegate as a CordaService com.github.manosbatsis.vaultaire.service.dao.StateService Short-lived helper, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.service.dao.StateServiceDelegate StateService delegate for vault operations com.github.manosbatsis.vaultaire.service.dao.StateServiceHubDelegate ServiceHub -based StateServiceDelegate implementation com.github.manosbatsis.vaultaire.service.dao.StateServicePoolBoyDelegate com.github.manosbatsis.vaultaire.service.dao.StateServiceRpcConnectionDelegate NodeRpcConnection -based StateServiceDelegate implementation kotlin.String (extensions in package com.github.manosbatsis.vaultaire.util) com.github.manosbatsis.vaultaire.dsl.query.TimeConsumedCondition com.github.manosbatsis.vaultaire.dsl.query.TimeInstantTypeCondition com.github.manosbatsis.vaultaire.dsl.query.TimeRecordedCondition com.github.manosbatsis.vaultaire.util.TypedFieldWrapper Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.annotation.VaultaireAccountInfo Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty . com.github.manosbatsis.vaultaire.dto.VaultaireBaseLiteDto Modeled after com.github.manosbatsis.kotlin.utils.api.Dto only bringing a StateService in-context for toTargetType and toPatched . com.github.manosbatsis.vaultaire.annotation.VaultaireDependencyAnnotationConvention com.github.manosbatsis.vaultaire.annotation.VaultaireDtoStrategyKeys com.github.manosbatsis.vaultaire.annotation.VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateResponder Generate a responser flow that extends the given type. com.github.manosbatsis.vaultaire.dto.VaultaireLiteDto com.github.manosbatsis.vaultaire.dsl.query.VaultCustomQueryCriteriaWrapperCondition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. com.github.manosbatsis.vaultaire.dsl.query.VaultQueryCriteriaCondition A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort com.github.manosbatsis.vaultaire.dsl.contract.When","title":"All Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/","text":"com.github.manosbatsis.vaultaire.annotation Package com.github.manosbatsis.vaultaire.annotation Types Name Summary VaultaireDependencyAnnotationConvention interface VaultaireDependencyAnnotationConvention VaultaireDtoStrategyKeys enum class VaultaireDtoStrategyKeys Annotations Name Summary ExtendedStateServiceBean annotation class ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type VaultaireAccountInfo annotation class VaultaireAccountInfo Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty . VaultaireGenerate annotation class VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. VaultaireGenerateDto annotation class VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. VaultaireGenerateDtoForDependency annotation class VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. VaultaireGenerateForDependency annotation class VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. VaultaireGenerateResponder annotation class VaultaireGenerateResponder Generate a responser flow that extends the given type.","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/#package-comgithubmanosbatsisvaultaireannotation","text":"","title":"Package com.github.manosbatsis.vaultaire.annotation"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/#types","text":"Name Summary VaultaireDependencyAnnotationConvention interface VaultaireDependencyAnnotationConvention VaultaireDtoStrategyKeys enum class VaultaireDtoStrategyKeys","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/#annotations","text":"Name Summary ExtendedStateServiceBean annotation class ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type VaultaireAccountInfo annotation class VaultaireAccountInfo Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty . VaultaireGenerate annotation class VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. VaultaireGenerateDto annotation class VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. VaultaireGenerateDtoForDependency annotation class VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. VaultaireGenerateForDependency annotation class VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. VaultaireGenerateResponder annotation class VaultaireGenerateResponder Generate a responser flow that extends the given type.","title":"Annotations"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/","text":"com.github.manosbatsis.vaultaire.annotation / ExtendedStateServiceBean ExtendedStateServiceBean @Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type Constructors Name Summary init ExtendedStateServiceBean() Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/#extendedstateservicebean","text":"@Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class ExtendedStateServiceBean Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":"ExtendedStateServiceBean"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/#constructors","text":"Name Summary init ExtendedStateServiceBean() Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / ExtendedStateServiceBean / init init ExtendedStateServiceBean() Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-extended-state-service-bean/-init-/#init","text":"ExtendedStateServiceBean() Marks a (Vaultaire-generated) ExtendedStateServiceBean type","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-account-info/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireAccountInfo VaultaireAccountInfo @Target([AnnotationTarget.FIELD, AnnotationTarget.PROPERTY]) annotation class VaultaireAccountInfo Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty . Constructors Name Summary init VaultaireAccountInfo() Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty .","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-account-info/#vaultaireaccountinfo","text":"@Target([AnnotationTarget.FIELD, AnnotationTarget.PROPERTY]) annotation class VaultaireAccountInfo Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty .","title":"VaultaireAccountInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-account-info/#constructors","text":"Name Summary init VaultaireAccountInfo() Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty .","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-account-info/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireAccountInfo / init init VaultaireAccountInfo() Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty .","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-account-info/-init-/#init","text":"VaultaireAccountInfo() Marks a net.corda.core.contracts.ContractState property as a Corda Account. Supported property types are java.security.PublicKey , net.corda.core.identity.AbstractParty and net.corda.core.identity.AnonymousParty .","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDependencyAnnotationConvention VaultaireDependencyAnnotationConvention interface VaultaireDependencyAnnotationConvention Properties Name Summary contractStateType abstract val contractStateType: KClass out ContractState persistentStateType abstract val persistentStateType: KClass out PersistentState","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/#vaultairedependencyannotationconvention","text":"interface VaultaireDependencyAnnotationConvention","title":"VaultaireDependencyAnnotationConvention"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/#properties","text":"Name Summary contractStateType abstract val contractStateType: KClass out ContractState persistentStateType abstract val persistentStateType: KClass out PersistentState","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDependencyAnnotationConvention / contractStateType contractStateType abstract val contractStateType: KClass out ContractState","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/contract-state-type/#contractstatetype","text":"abstract val contractStateType: KClass out ContractState","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/persistent-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDependencyAnnotationConvention / persistentStateType persistentStateType abstract val persistentStateType: KClass out PersistentState","title":"Persistent state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/persistent-state-type/#persistentstatetype","text":"abstract val persistentStateType: KClass out PersistentState","title":"persistentStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys VaultaireDtoStrategyKeys enum class VaultaireDtoStrategyKeys Enum Values Name Summary DEFAULT LITE Properties Name Summary classNameSuffix val classNameSuffix: String Functions Name Summary toString fun toString(): String Companion Object Functions Name Summary findFromString fun findFromString(s: String): VaultaireDtoStrategyKeys ? getFromString fun getFromString(s: String): VaultaireDtoStrategyKeys","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/#vaultairedtostrategykeys","text":"enum class VaultaireDtoStrategyKeys","title":"VaultaireDtoStrategyKeys"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/#enum-values","text":"Name Summary DEFAULT LITE","title":"Enum Values"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/#properties","text":"Name Summary classNameSuffix val classNameSuffix: String","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/#functions","text":"Name Summary toString fun toString(): String","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/#companion-object-functions","text":"Name Summary findFromString fun findFromString(s: String): VaultaireDtoStrategyKeys ? getFromString fun getFromString(s: String): VaultaireDtoStrategyKeys","title":"Companion Object Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-d-e-f-a-u-l-t/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys / DEFAULT DEFAULT DEFAULT Inherited Properties Name Summary classNameSuffix val classNameSuffix: String Inherited Functions Name Summary toString fun toString(): String","title":" d e f a u l t"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-d-e-f-a-u-l-t/#default","text":"DEFAULT","title":"DEFAULT"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-d-e-f-a-u-l-t/#inherited-properties","text":"Name Summary classNameSuffix val classNameSuffix: String","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-d-e-f-a-u-l-t/#inherited-functions","text":"Name Summary toString fun toString(): String","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-l-i-t-e/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys / LITE LITE LITE Inherited Properties Name Summary classNameSuffix val classNameSuffix: String Inherited Functions Name Summary toString fun toString(): String","title":" l i t e"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-l-i-t-e/#lite","text":"LITE","title":"LITE"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-l-i-t-e/#inherited-properties","text":"Name Summary classNameSuffix val classNameSuffix: String","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/-l-i-t-e/#inherited-functions","text":"Name Summary toString fun toString(): String","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/class-name-suffix/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys / classNameSuffix classNameSuffix val classNameSuffix: String","title":"Class name suffix"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/class-name-suffix/#classnamesuffix","text":"val classNameSuffix: String","title":"classNameSuffix"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/find-from-string/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys / findFromString findFromString fun findFromString(s: String): VaultaireDtoStrategyKeys ?","title":"Find from string"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/find-from-string/#findfromstring","text":"fun findFromString(s: String): VaultaireDtoStrategyKeys ?","title":"findFromString"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/get-from-string/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys / getFromString getFromString fun getFromString(s: String): VaultaireDtoStrategyKeys","title":"Get from string"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/get-from-string/#getfromstring","text":"fun getFromString(s: String): VaultaireDtoStrategyKeys","title":"getFromString"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/to-string/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDtoStrategyKeys / toString toString fun toString(): String","title":"To string"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dto-strategy-keys/to-string/#tostring","text":"fun toString(): String","title":"toString"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerate VaultaireGenerate @Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. Constructors Name Summary init VaultaireGenerate(name: String = \"\", contractStateType: KClass out ContractState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. Properties Name Summary contractStateType val contractStateType: KClass out ContractState name val name: String","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/#vaultairegenerate","text":"@Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor.","title":"VaultaireGenerate"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/#constructors","text":"Name Summary init VaultaireGenerate(name: String = \"\", contractStateType: KClass out ContractState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/#properties","text":"Name Summary contractStateType val contractStateType: KClass out ContractState name val name: String","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerate / init init VaultaireGenerate(name: String = \"\", contractStateType: KClass out ContractState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/-init-/#init","text":"VaultaireGenerate(name: String = \"\", contractStateType: KClass out ContractState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerate / contractStateType contractStateType val contractStateType: KClass out ContractState","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/contract-state-type/#contractstatetype","text":"val contractStateType: KClass out ContractState","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/name/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerate / name name val name: String","title":"Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/name/#name","text":"val name: String","title":"name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDto VaultaireGenerateDto @Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. Constructors Name Summary init VaultaireGenerateDto(ignoreProperties: Array String = [], copyAnnotationPackages: Array String = [], strategies: Array VaultaireDtoStrategyKeys = [VaultaireDtoStrategyKeys.DEFAULT], includeParticipants: Boolean = false) Generate a DTO for the annotated ContractState class or constructor. Properties Name Summary copyAnnotationPackages val copyAnnotationPackages: Array String ignoreProperties val ignoreProperties: Array String includeParticipants val includeParticipants: Boolean strategies val strategies: Array VaultaireDtoStrategyKeys","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/#vaultairegeneratedto","text":"@Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor.","title":"VaultaireGenerateDto"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/#constructors","text":"Name Summary init VaultaireGenerateDto(ignoreProperties: Array String = [], copyAnnotationPackages: Array String = [], strategies: Array VaultaireDtoStrategyKeys = [VaultaireDtoStrategyKeys.DEFAULT], includeParticipants: Boolean = false) Generate a DTO for the annotated ContractState class or constructor.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/#properties","text":"Name Summary copyAnnotationPackages val copyAnnotationPackages: Array String ignoreProperties val ignoreProperties: Array String includeParticipants val includeParticipants: Boolean strategies val strategies: Array VaultaireDtoStrategyKeys","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDto / init init VaultaireGenerateDto(ignoreProperties: Array String = [], copyAnnotationPackages: Array String = [], strategies: Array VaultaireDtoStrategyKeys = [VaultaireDtoStrategyKeys.DEFAULT], includeParticipants: Boolean = false) Generate a DTO for the annotated ContractState class or constructor.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/-init-/#init","text":"VaultaireGenerateDto(ignoreProperties: Array String = [], copyAnnotationPackages: Array String = [], strategies: Array VaultaireDtoStrategyKeys = [VaultaireDtoStrategyKeys.DEFAULT], includeParticipants: Boolean = false) Generate a DTO for the annotated ContractState class or constructor.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/copy-annotation-packages/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDto / copyAnnotationPackages copyAnnotationPackages val copyAnnotationPackages: Array String","title":"Copy annotation packages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/copy-annotation-packages/#copyannotationpackages","text":"val copyAnnotationPackages: Array String","title":"copyAnnotationPackages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/ignore-properties/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDto / ignoreProperties ignoreProperties val ignoreProperties: Array String","title":"Ignore properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/ignore-properties/#ignoreproperties","text":"val ignoreProperties: Array String","title":"ignoreProperties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/include-participants/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDto / includeParticipants includeParticipants val includeParticipants: Boolean","title":"Include participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/include-participants/#includeparticipants","text":"val includeParticipants: Boolean","title":"includeParticipants"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/strategies/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDto / strategies strategies val strategies: Array VaultaireDtoStrategyKeys","title":"Strategies"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/strategies/#strategies","text":"val strategies: Array VaultaireDtoStrategyKeys","title":"strategies"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency VaultaireGenerateDtoForDependency @Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. Constructors Name Summary init VaultaireGenerateDtoForDependency(ignoreProperties: Array String = [], contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState , copyAnnotationPackages: Array String = [], strategies: Array VaultaireDtoStrategyKeys = [VaultaireDtoStrategyKeys.DEFAULT], includeParticipants: Boolean = false) Generate a DTO for the ContractState of a project dependency. Properties Name Summary contractStateType val contractStateType: KClass out ContractState copyAnnotationPackages val copyAnnotationPackages: Array String ignoreProperties val ignoreProperties: Array String includeParticipants val includeParticipants: Boolean persistentStateType val persistentStateType: KClass out PersistentState strategies val strategies: Array VaultaireDtoStrategyKeys","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/#vaultairegeneratedtofordependency","text":"@Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency.","title":"VaultaireGenerateDtoForDependency"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/#constructors","text":"Name Summary init VaultaireGenerateDtoForDependency(ignoreProperties: Array String = [], contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState , copyAnnotationPackages: Array String = [], strategies: Array VaultaireDtoStrategyKeys = [VaultaireDtoStrategyKeys.DEFAULT], includeParticipants: Boolean = false) Generate a DTO for the ContractState of a project dependency.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/#properties","text":"Name Summary contractStateType val contractStateType: KClass out ContractState copyAnnotationPackages val copyAnnotationPackages: Array String ignoreProperties val ignoreProperties: Array String includeParticipants val includeParticipants: Boolean persistentStateType val persistentStateType: KClass out PersistentState strategies val strategies: Array VaultaireDtoStrategyKeys","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / init init VaultaireGenerateDtoForDependency(ignoreProperties: Array String = [], contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState , copyAnnotationPackages: Array String = [], strategies: Array VaultaireDtoStrategyKeys = [VaultaireDtoStrategyKeys.DEFAULT], includeParticipants: Boolean = false) Generate a DTO for the ContractState of a project dependency.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/-init-/#init","text":"VaultaireGenerateDtoForDependency(ignoreProperties: Array String = [], contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState , copyAnnotationPackages: Array String = [], strategies: Array VaultaireDtoStrategyKeys = [VaultaireDtoStrategyKeys.DEFAULT], includeParticipants: Boolean = false) Generate a DTO for the ContractState of a project dependency.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / contractStateType contractStateType val contractStateType: KClass out ContractState","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/contract-state-type/#contractstatetype","text":"val contractStateType: KClass out ContractState","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/copy-annotation-packages/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / copyAnnotationPackages copyAnnotationPackages val copyAnnotationPackages: Array String","title":"Copy annotation packages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/copy-annotation-packages/#copyannotationpackages","text":"val copyAnnotationPackages: Array String","title":"copyAnnotationPackages"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/ignore-properties/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / ignoreProperties ignoreProperties val ignoreProperties: Array String","title":"Ignore properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/ignore-properties/#ignoreproperties","text":"val ignoreProperties: Array String","title":"ignoreProperties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/include-participants/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / includeParticipants includeParticipants val includeParticipants: Boolean","title":"Include participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/include-participants/#includeparticipants","text":"val includeParticipants: Boolean","title":"includeParticipants"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/persistent-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / persistentStateType persistentStateType val persistentStateType: KClass out PersistentState","title":"Persistent state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/persistent-state-type/#persistentstatetype","text":"val persistentStateType: KClass out PersistentState","title":"persistentStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/strategies/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / strategies strategies val strategies: Array VaultaireDtoStrategyKeys","title":"Strategies"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/strategies/#strategies","text":"val strategies: Array VaultaireDtoStrategyKeys","title":"strategies"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency VaultaireGenerateForDependency @Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. Constructors Name Summary init VaultaireGenerateForDependency(name: String = \"\", contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. Properties Name Summary contractStateType val contractStateType: KClass out ContractState name val name: String persistentStateType val persistentStateType: KClass out PersistentState","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/#vaultairegeneratefordependency","text":"@Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency.","title":"VaultaireGenerateForDependency"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/#constructors","text":"Name Summary init VaultaireGenerateForDependency(name: String = \"\", contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/#properties","text":"Name Summary contractStateType val contractStateType: KClass out ContractState name val name: String persistentStateType val persistentStateType: KClass out PersistentState","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency / init init VaultaireGenerateForDependency(name: String = \"\", contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/-init-/#init","text":"VaultaireGenerateForDependency(name: String = \"\", contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency / contractStateType contractStateType val contractStateType: KClass out ContractState","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/contract-state-type/#contractstatetype","text":"val contractStateType: KClass out ContractState","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/name/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency / name name val name: String","title":"Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/name/#name","text":"val name: String","title":"name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/persistent-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency / persistentStateType persistentStateType val persistentStateType: KClass out PersistentState","title":"Persistent state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/persistent-state-type/#persistentstatetype","text":"val persistentStateType: KClass out PersistentState","title":"persistentStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateResponder VaultaireGenerateResponder @Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateResponder Generate a responser flow that extends the given type. Constructors Name Summary init VaultaireGenerateResponder(value: KClass out FlowLogic * , comment: String = \"\") Generate a responser flow that extends the given type. Properties Name Summary comment val comment: String value val value: KClass out FlowLogic *","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/#vaultairegenerateresponder","text":"@Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateResponder Generate a responser flow that extends the given type.","title":"VaultaireGenerateResponder"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/#constructors","text":"Name Summary init VaultaireGenerateResponder(value: KClass out FlowLogic * , comment: String = \"\") Generate a responser flow that extends the given type.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/#properties","text":"Name Summary comment val comment: String value val value: KClass out FlowLogic *","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateResponder / init init VaultaireGenerateResponder(value: KClass out FlowLogic * , comment: String = \"\") Generate a responser flow that extends the given type.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/-init-/#init","text":"VaultaireGenerateResponder(value: KClass out FlowLogic * , comment: String = \"\") Generate a responser flow that extends the given type.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/comment/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateResponder / comment comment val comment: String","title":"Comment"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/comment/#comment","text":"val comment: String","title":"comment"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/value/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateResponder / value value val value: KClass out FlowLogic *","title":"Value"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/value/#value","text":"val value: KClass out FlowLogic *","title":"value"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/","text":"com.github.manosbatsis.vaultaire.dsl.contract Package com.github.manosbatsis.vaultaire.dsl.contract Types Name Summary ContractConditions abstract class ContractConditions When class When","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/#package-comgithubmanosbatsisvaultairedslcontract","text":"","title":"Package com.github.manosbatsis.vaultaire.dsl.contract"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/#types","text":"Name Summary ContractConditions abstract class ContractConditions When class When","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions ContractConditions abstract class ContractConditions Constructors Name Summary init ContractConditions(tx: LedgerTransaction) Properties Name Summary commandTypes abstract val commandTypes: Any fields abstract val T : ContractState InOutGroup T , * .fields: Fields T groups abstract val groups: Any roles abstract val roles: Any stateTypeFields abstract val stateTypeFields: Any stateTypes abstract val stateTypes: Any tx val tx: LedgerTransaction","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/#contractconditions","text":"abstract class ContractConditions","title":"ContractConditions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/#constructors","text":"Name Summary init ContractConditions(tx: LedgerTransaction)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/#properties","text":"Name Summary commandTypes abstract val commandTypes: Any fields abstract val T : ContractState InOutGroup T , * .fields: Fields T groups abstract val groups: Any roles abstract val roles: Any stateTypeFields abstract val stateTypeFields: Any stateTypes abstract val stateTypes: Any tx val tx: LedgerTransaction","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / init init ContractConditions(tx: LedgerTransaction)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/-init-/#init","text":"ContractConditions(tx: LedgerTransaction)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/command-types/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / commandTypes commandTypes abstract val commandTypes: Any","title":"Command types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/command-types/#commandtypes","text":"abstract val commandTypes: Any","title":"commandTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/fields/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / fields fields abstract val T : ContractState InOutGroup T , * .fields: Fields T","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/fields/#fields","text":"abstract val T : ContractState InOutGroup T , * .fields: Fields T","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/groups/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / groups groups abstract val groups: Any","title":"Groups"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/groups/#groups","text":"abstract val groups: Any","title":"groups"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/roles/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / roles roles abstract val roles: Any","title":"Roles"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/roles/#roles","text":"abstract val roles: Any","title":"roles"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-type-fields/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / stateTypeFields stateTypeFields abstract val stateTypeFields: Any","title":"State type fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-type-fields/#statetypefields","text":"abstract val stateTypeFields: Any","title":"stateTypeFields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-types/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / stateTypes stateTypes abstract val stateTypes: Any","title":"State types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-types/#statetypes","text":"abstract val stateTypes: Any","title":"stateTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/tx/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / tx tx val tx: LedgerTransaction","title":"Tx"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/tx/#tx","text":"val tx: LedgerTransaction","title":"tx"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/","text":"com.github.manosbatsis.vaultaire.dsl.contract / When When class When Constructors Name Summary init When(vararg conditions: Boolean)","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/#when","text":"class When","title":"When"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/#constructors","text":"Name Summary init When(vararg conditions: Boolean)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.contract / When / init init When(vararg conditions: Boolean)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/-init-/#init","text":"When(vararg conditions: Boolean)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/","text":"com.github.manosbatsis.vaultaire.dsl.query Package com.github.manosbatsis.vaultaire.dsl.query Types Name Summary Aggregates class Aggregates P : StatePersistable Used to define aggregation criteria AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Condition interface Condition Condition interface ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched RootCondition interface RootCondition P : StatePersistable : Condition SortColumns class SortColumns P : StatePersistable Used to define Sort.SortColumn s TimeConsumedCondition class TimeConsumedCondition : TimeInstantTypeCondition TimeInstantTypeCondition abstract class TimeInstantTypeCondition TimeRecordedCondition class TimeRecordedCondition : TimeInstantTypeCondition VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/#package-comgithubmanosbatsisvaultairedslquery","text":"","title":"Package com.github.manosbatsis.vaultaire.dsl.query"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/#types","text":"Name Summary Aggregates class Aggregates P : StatePersistable Used to define aggregation criteria AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Condition interface Condition Condition interface ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched RootCondition interface RootCondition P : StatePersistable : Condition SortColumns class SortColumns P : StatePersistable Used to define Sort.SortColumn s TimeConsumedCondition class TimeConsumedCondition : TimeInstantTypeCondition TimeInstantTypeCondition abstract class TimeInstantTypeCondition TimeRecordedCondition class TimeRecordedCondition : TimeInstantTypeCondition VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates Aggregates class Aggregates P : StatePersistable Used to define aggregation criteria Constructors Name Summary init Aggregates(rootCondition: RootCondition P ) Used to define aggregation criteria Properties Name Summary rootCondition val rootCondition: RootCondition P Functions Name Summary avg fun S : Comparable S TypedFieldWrapper P , S .avg(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean count fun FieldWrapper P .count(): Boolean max fun S : Comparable S TypedFieldWrapper P , S .max(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean min fun S : Comparable S TypedFieldWrapper P , S .min(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean sum fun S : Comparable S TypedFieldWrapper P , S .sum(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#aggregates","text":"class Aggregates P : StatePersistable Used to define aggregation criteria","title":"Aggregates"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#constructors","text":"Name Summary init Aggregates(rootCondition: RootCondition P ) Used to define aggregation criteria","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#properties","text":"Name Summary rootCondition val rootCondition: RootCondition P","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#functions","text":"Name Summary avg fun S : Comparable S TypedFieldWrapper P , S .avg(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean count fun FieldWrapper P .count(): Boolean max fun S : Comparable S TypedFieldWrapper P , S .max(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean min fun S : Comparable S TypedFieldWrapper P , S .min(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean sum fun S : Comparable S TypedFieldWrapper P , S .sum(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / init init Aggregates(rootCondition: RootCondition P ) Used to define aggregation criteria","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/-init-/#init","text":"Aggregates(rootCondition: RootCondition P ) Used to define aggregation criteria","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/avg/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / avg avg fun S : Comparable S TypedFieldWrapper P , S .avg(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Avg"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/avg/#avg","text":"fun S : Comparable S TypedFieldWrapper P , S .avg(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"avg"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/count/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / count count fun FieldWrapper P .count(): Boolean","title":"Count"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/count/#count","text":"fun FieldWrapper P .count(): Boolean","title":"count"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/max/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / max max fun S : Comparable S TypedFieldWrapper P , S .max(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Max"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/max/#max","text":"fun S : Comparable S TypedFieldWrapper P , S .max(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"max"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/min/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / min min fun S : Comparable S TypedFieldWrapper P , S .min(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Min"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/min/#min","text":"fun S : Comparable S TypedFieldWrapper P , S .min(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"min"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/root-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / rootCondition rootCondition val rootCondition: RootCondition P","title":"Root condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/root-condition/#rootcondition","text":"val rootCondition: RootCondition P","title":"rootCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/sum/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / sum sum fun S : Comparable S TypedFieldWrapper P , S .sum(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Sum"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/sum/#sum","text":"fun S : Comparable S TypedFieldWrapper P , S .sum(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"sum"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / AndCondition AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched Constructors Name Summary init AndCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where all items must be matched Inherited Properties Name Summary fields open val fields: F The fields of the target StatePersistable type P Functions Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inherited Functions Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#andcondition","text":"class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched","title":"AndCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#constructors","text":"Name Summary init AndCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where all items must be matched","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#inherited-properties","text":"Name Summary fields open val fields: F The fields of the target StatePersistable type P","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#functions","text":"Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#inherited-functions","text":"Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / AndCondition / init init AndCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where all items must be matched","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/-init-/#init","text":"AndCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where all items must be matched","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / AndCondition / toCriteria toCriteria fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/to-criteria/#tocriteria","text":"fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Constructors Name Summary init CompositeCondition(fields: F , rootCondition: RootCondition P ) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Properties Name Summary fields open val fields: F The fields of the target StatePersistable type P Functions Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit Inherited Functions Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit Inheritors Name Summary AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#compositecondition","text":"abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":"CompositeCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#constructors","text":"Name Summary init CompositeCondition(fields: F , rootCondition: RootCondition P ) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#properties","text":"Name Summary fields open val fields: F The fields of the target StatePersistable type P","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#functions","text":"Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#inherited-functions","text":"Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#inheritors","text":"Name Summary AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/!=/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / != != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit","title":"!="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/!=/#_1","text":"infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit","title":"!="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/!in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / !in !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit","title":"!in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/!in/#in","text":"fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit","title":"!in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / init init CompositeCondition(fields: F , rootCondition: RootCondition P ) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/-init-/#init","text":"CompositeCondition(fields: F , rootCondition: RootCondition P ) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/==/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / == == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit","title":"=="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/==/#_1","text":"infix fun S TypedFieldWrapper P , S .==(value: S ): Unit","title":"=="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _equal _equal infix fun FieldWrapper P ._equal(value: Any): Unit","title":" equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_equal/#_equal","text":"infix fun FieldWrapper P ._equal(value: Any): Unit","title":"_equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _like _like infix fun FieldWrapper P ._like(value: String): Unit","title":" like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_like/#_like","text":"infix fun FieldWrapper P ._like(value: String): Unit","title":"_like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _notEqual _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit","title":" not equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-equal/#_notequal","text":"infix fun FieldWrapper P ._notEqual(value: Any): Unit","title":"_notEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _notLike _notLike infix fun FieldWrapper P ._notLike(value: String): Unit","title":" not like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-like/#_notlike","text":"infix fun FieldWrapper P ._notLike(value: String): Unit","title":"_notLike"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/as-string-property/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / asStringProperty asStringProperty protected fun FieldWrapper P .asStringProperty(): KProperty1 P , String","title":"As string property"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/as-string-property/#asstringproperty","text":"protected fun FieldWrapper P .asStringProperty(): KProperty1 P , String","title":"asStringProperty"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/between/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / between between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit","title":"Between"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/between/#between","text":"fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit","title":"between"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/btw/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / btw btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit","title":"Btw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/btw/#btw","text":"infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit","title":"btw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / equal equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit","title":"Equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/equal/#equal","text":"infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit","title":"equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/fields/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / fields fields open val fields: F Overrides ConditionsCondition.fields The fields of the target StatePersistable type P","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/fields/#fields","text":"open val fields: F Overrides ConditionsCondition.fields The fields of the target StatePersistable type P","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than-or-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / greaterThanOrEqual greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit","title":"Greater than or equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than-or-equal/#greaterthanorequal","text":"infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit","title":"greaterThanOrEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / greaterThan greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit","title":"Greater than"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than/#greaterthan","text":"infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit","title":"greaterThan"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gt/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / gt gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit","title":"Gt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gt/#gt","text":"infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit","title":"gt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gte/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / gte gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit","title":"Gte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gte/#gte","text":"infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit","title":"gte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / in in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit","title":"In"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/in/#in","text":"infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit","title":"in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / isIn isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit","title":"Is in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-in/#isin","text":"infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit","title":"isIn"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-null/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / isNull isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit","title":"Is null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-null/#isnull","text":"fun S NullableGenericFieldWrapper P , S .isNull(): Unit","title":"isNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than-or-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lessThanOrEqual lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit","title":"Less than or equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than-or-equal/#lessthanorequal","text":"infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit","title":"lessThanOrEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lessThan lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit","title":"Less than"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than/#lessthan","text":"infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit","title":"lessThan"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / like like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit","title":"Like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/like/#like","text":"infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit","title":"like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lt/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lt lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit","title":"Lt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lt/#lt","text":"infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit","title":"lt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lte/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lte lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit","title":"Lte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lte/#lte","text":"infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit","title":"lte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notEqual notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit","title":"Not equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-equal/#notequal","text":"infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit","title":"notEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notIn notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit","title":"Not in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-in/#notin","text":"infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit","title":"notIn"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notLike notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit","title":"Not like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-like/#notlike","text":"infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit","title":"notLike"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-null/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notNull notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Not null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-null/#notnull","text":"fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"notNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / Condition Condition interface Condition Condition interface Functions Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inheritors Name Summary ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups RootCondition interface RootCondition P : StatePersistable : Condition VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/#condition","text":"interface Condition Condition interface","title":"Condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/#functions","text":"Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/#inheritors","text":"Name Summary ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups RootCondition interface RootCondition P : StatePersistable : Condition VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / Condition / toCriteria toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/to-criteria/#tocriteria","text":"abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups Constructors Name Summary init ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups Properties Name Summary fields abstract val fields: F The fields of the target StatePersistable type P Functions Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit Inherited Functions Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inheritors Name Summary CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#conditionscondition","text":"abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups","title":"ConditionsCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#constructors","text":"Name Summary init ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#properties","text":"Name Summary fields abstract val fields: F The fields of the target StatePersistable type P","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#functions","text":"Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#inherited-functions","text":"Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#inheritors","text":"Name Summary CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / init init ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/-init-/#init","text":"ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/add-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / addCondition addCondition fun addCondition(condition: Condition ): Unit","title":"Add condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/add-condition/#addcondition","text":"fun addCondition(condition: Condition ): Unit","title":"addCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/and/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / and and fun and(initializer: CompositeCondition P , F .() - Unit): Unit","title":"And"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/and/#and","text":"fun and(initializer: CompositeCondition P , F .() - Unit): Unit","title":"and"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/fields/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / fields fields abstract val fields: F The fields of the target StatePersistable type P","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/fields/#fields","text":"abstract val fields: F The fields of the target StatePersistable type P","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/or/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / or or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Or"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/or/#or","text":"fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"or"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / OrCondition OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched Constructors Name Summary init OrCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where at least a single item must be matched Inherited Properties Name Summary fields open val fields: F The fields of the target StatePersistable type P Functions Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inherited Functions Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#orcondition","text":"class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched","title":"OrCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#constructors","text":"Name Summary init OrCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where at least a single item must be matched","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#inherited-properties","text":"Name Summary fields open val fields: F The fields of the target StatePersistable type P","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#functions","text":"Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#inherited-functions","text":"Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / OrCondition / init init OrCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where at least a single item must be matched","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/-init-/#init","text":"OrCondition(fields: F , rootCondition: RootCondition P ) Defines a set of conditions where at least a single item must be matched","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / OrCondition / toCriteria toCriteria fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/to-criteria/#tocriteria","text":"fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition RootCondition interface RootCondition P : StatePersistable : Condition Properties Name Summary constraints abstract var constraints: Set ConstraintInfo constraintTypes abstract var constraintTypes: Set Type externalIds abstract var externalIds: List UUID notary abstract var notary: List AbstractParty ? participants abstract var participants: List AbstractParty ? relevancyStatus abstract var relevancyStatus: RelevancyStatus softLockingCondition abstract var softLockingCondition: SoftLockingCondition? stateRefs abstract var stateRefs: List StateRef ? status abstract var status: StateStatus timeCondition abstract var timeCondition: TimeCondition? Inherited Functions Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inheritors Name Summary VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/#rootcondition","text":"interface RootCondition P : StatePersistable : Condition","title":"RootCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/#properties","text":"Name Summary constraints abstract var constraints: Set ConstraintInfo constraintTypes abstract var constraintTypes: Set Type externalIds abstract var externalIds: List UUID notary abstract var notary: List AbstractParty ? participants abstract var participants: List AbstractParty ? relevancyStatus abstract var relevancyStatus: RelevancyStatus softLockingCondition abstract var softLockingCondition: SoftLockingCondition? stateRefs abstract var stateRefs: List StateRef ? status abstract var status: StateStatus timeCondition abstract var timeCondition: TimeCondition?","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/#inherited-functions","text":"Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/#inheritors","text":"Name Summary VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/constraint-types/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / constraintTypes constraintTypes abstract var constraintTypes: Set Type","title":"Constraint types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/constraint-types/#constrainttypes","text":"abstract var constraintTypes: Set Type","title":"constraintTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/constraints/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / constraints constraints abstract var constraints: Set ConstraintInfo","title":"Constraints"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/constraints/#constraints","text":"abstract var constraints: Set ConstraintInfo","title":"constraints"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/external-ids/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / externalIds externalIds abstract var externalIds: List UUID","title":"External ids"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/external-ids/#externalids","text":"abstract var externalIds: List UUID","title":"externalIds"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/notary/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / notary notary abstract var notary: List AbstractParty ?","title":"Notary"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/notary/#notary","text":"abstract var notary: List AbstractParty ?","title":"notary"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/participants/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / participants participants abstract var participants: List AbstractParty ?","title":"Participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/participants/#participants","text":"abstract var participants: List AbstractParty ?","title":"participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/relevancy-status/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / relevancyStatus relevancyStatus abstract var relevancyStatus: RelevancyStatus","title":"Relevancy status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/relevancy-status/#relevancystatus","text":"abstract var relevancyStatus: RelevancyStatus","title":"relevancyStatus"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/soft-locking-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / softLockingCondition softLockingCondition abstract var softLockingCondition: SoftLockingCondition?","title":"Soft locking condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/soft-locking-condition/#softlockingcondition","text":"abstract var softLockingCondition: SoftLockingCondition?","title":"softLockingCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/state-refs/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / stateRefs stateRefs abstract var stateRefs: List StateRef ?","title":"State refs"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/state-refs/#staterefs","text":"abstract var stateRefs: List StateRef ?","title":"stateRefs"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/status/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / status status abstract var status: StateStatus","title":"Status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/status/#status","text":"abstract var status: StateStatus","title":"status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/time-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / RootCondition / timeCondition timeCondition abstract var timeCondition: TimeCondition?","title":"Time condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-root-condition/time-condition/#timecondition","text":"abstract var timeCondition: TimeCondition?","title":"timeCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns SortColumns class SortColumns P : StatePersistable Used to define Sort.SortColumn s Constructors Name Summary init SortColumns(statePersistableType: Class P ) Used to define Sort.SortColumn s Properties Name Summary ASC val ASC: Direction constraintType val constraintType: VaultStateAttribute consumedTime val consumedTime: VaultStateAttribute contractStateType val contractStateType: VaultStateAttribute DESC val DESC: Direction entries val entries: LinkedHashSet SortColumn externalId val externalId: LinearStateAttribute issuerRef val issuerRef: FungibleStateAttribute lockId val lockId: VaultStateAttribute notaryName val notaryName: VaultStateAttribute quantity val quantity: FungibleStateAttribute recordedTime val recordedTime: VaultStateAttribute statePersistableType val statePersistableType: Class P stateRef val stateRef: CommonStateAttribute stateRefIndex val stateRefIndex: CommonStateAttribute stateRefTxnId val stateRefTxnId: CommonStateAttribute stateStatus val stateStatus: VaultStateAttribute uuid val uuid: LinearStateAttribute Functions Name Summary sort infix fun CommonStateAttribute.sort(value: Direction): Boolean infix fun FungibleStateAttribute.sort(value: Direction): Boolean infix fun LinearStateAttribute.sort(value: Direction): Boolean infix fun VaultStateAttribute.sort(value: Direction): Boolean infix fun FieldWrapper P .sort(value: Direction): Unit","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#sortcolumns","text":"class SortColumns P : StatePersistable Used to define Sort.SortColumn s","title":"SortColumns"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#constructors","text":"Name Summary init SortColumns(statePersistableType: Class P ) Used to define Sort.SortColumn s","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#properties","text":"Name Summary ASC val ASC: Direction constraintType val constraintType: VaultStateAttribute consumedTime val consumedTime: VaultStateAttribute contractStateType val contractStateType: VaultStateAttribute DESC val DESC: Direction entries val entries: LinkedHashSet SortColumn externalId val externalId: LinearStateAttribute issuerRef val issuerRef: FungibleStateAttribute lockId val lockId: VaultStateAttribute notaryName val notaryName: VaultStateAttribute quantity val quantity: FungibleStateAttribute recordedTime val recordedTime: VaultStateAttribute statePersistableType val statePersistableType: Class P stateRef val stateRef: CommonStateAttribute stateRefIndex val stateRefIndex: CommonStateAttribute stateRefTxnId val stateRefTxnId: CommonStateAttribute stateStatus val stateStatus: VaultStateAttribute uuid val uuid: LinearStateAttribute","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#functions","text":"Name Summary sort infix fun CommonStateAttribute.sort(value: Direction): Boolean infix fun FungibleStateAttribute.sort(value: Direction): Boolean infix fun LinearStateAttribute.sort(value: Direction): Boolean infix fun VaultStateAttribute.sort(value: Direction): Boolean infix fun FieldWrapper P .sort(value: Direction): Unit","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-a-s-c/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / ASC ASC val ASC: Direction","title":" a s c"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-a-s-c/#asc","text":"val ASC: Direction","title":"ASC"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-d-e-s-c/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / DESC DESC val DESC: Direction","title":" d e s c"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-d-e-s-c/#desc","text":"val DESC: Direction","title":"DESC"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / init init SortColumns(statePersistableType: Class P ) Used to define Sort.SortColumn s","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-init-/#init","text":"SortColumns(statePersistableType: Class P ) Used to define Sort.SortColumn s","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/constraint-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / constraintType constraintType val constraintType: VaultStateAttribute","title":"Constraint type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/constraint-type/#constrainttype","text":"val constraintType: VaultStateAttribute","title":"constraintType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/consumed-time/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / consumedTime consumedTime val consumedTime: VaultStateAttribute","title":"Consumed time"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/consumed-time/#consumedtime","text":"val consumedTime: VaultStateAttribute","title":"consumedTime"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/contract-state-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / contractStateType contractStateType val contractStateType: VaultStateAttribute","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/contract-state-type/#contractstatetype","text":"val contractStateType: VaultStateAttribute","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/entries/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / entries entries val entries: LinkedHashSet SortColumn","title":"Entries"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/entries/#entries","text":"val entries: LinkedHashSet SortColumn","title":"entries"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/external-id/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / externalId externalId val externalId: LinearStateAttribute","title":"External id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/external-id/#externalid","text":"val externalId: LinearStateAttribute","title":"externalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/issuer-ref/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / issuerRef issuerRef val issuerRef: FungibleStateAttribute","title":"Issuer ref"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/issuer-ref/#issuerref","text":"val issuerRef: FungibleStateAttribute","title":"issuerRef"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/lock-id/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / lockId lockId val lockId: VaultStateAttribute","title":"Lock id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/lock-id/#lockid","text":"val lockId: VaultStateAttribute","title":"lockId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/notary-name/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / notaryName notaryName val notaryName: VaultStateAttribute","title":"Notary name"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/notary-name/#notaryname","text":"val notaryName: VaultStateAttribute","title":"notaryName"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/quantity/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / quantity quantity val quantity: FungibleStateAttribute","title":"Quantity"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/quantity/#quantity","text":"val quantity: FungibleStateAttribute","title":"quantity"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/recorded-time/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / recordedTime recordedTime val recordedTime: VaultStateAttribute","title":"Recorded time"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/recorded-time/#recordedtime","text":"val recordedTime: VaultStateAttribute","title":"recordedTime"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/sort/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / sort sort infix fun CommonStateAttribute.sort(value: Direction): Boolean infix fun FungibleStateAttribute.sort(value: Direction): Boolean infix fun LinearStateAttribute.sort(value: Direction): Boolean infix fun VaultStateAttribute.sort(value: Direction): Boolean infix fun FieldWrapper P .sort(value: Direction): Unit","title":"Sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/sort/#sort","text":"infix fun CommonStateAttribute.sort(value: Direction): Boolean infix fun FungibleStateAttribute.sort(value: Direction): Boolean infix fun LinearStateAttribute.sort(value: Direction): Boolean infix fun VaultStateAttribute.sort(value: Direction): Boolean infix fun FieldWrapper P .sort(value: Direction): Unit","title":"sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-persistable-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / statePersistableType statePersistableType val statePersistableType: Class P","title":"State persistable type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-persistable-type/#statepersistabletype","text":"val statePersistableType: Class P","title":"statePersistableType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref-index/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / stateRefIndex stateRefIndex val stateRefIndex: CommonStateAttribute","title":"State ref index"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref-index/#staterefindex","text":"val stateRefIndex: CommonStateAttribute","title":"stateRefIndex"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref-txn-id/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / stateRefTxnId stateRefTxnId val stateRefTxnId: CommonStateAttribute","title":"State ref txn id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref-txn-id/#statereftxnid","text":"val stateRefTxnId: CommonStateAttribute","title":"stateRefTxnId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / stateRef stateRef val stateRef: CommonStateAttribute","title":"State ref"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-ref/#stateref","text":"val stateRef: CommonStateAttribute","title":"stateRef"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-status/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / stateStatus stateStatus val stateStatus: VaultStateAttribute","title":"State status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-status/#statestatus","text":"val stateStatus: VaultStateAttribute","title":"stateStatus"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/uuid/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / uuid uuid val uuid: LinearStateAttribute","title":"Uuid"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/uuid/#uuid","text":"val uuid: LinearStateAttribute","title":"uuid"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeConsumedCondition TimeConsumedCondition class TimeConsumedCondition : TimeInstantTypeCondition Constructors Name Summary init TimeConsumedCondition()","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/#timeconsumedcondition","text":"class TimeConsumedCondition : TimeInstantTypeCondition","title":"TimeConsumedCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/#constructors","text":"Name Summary init TimeConsumedCondition()","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeConsumedCondition / init init TimeConsumedCondition()","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-consumed-condition/-init-/#init","text":"TimeConsumedCondition()","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeInstantTypeCondition TimeInstantTypeCondition abstract class TimeInstantTypeCondition Constructors Name Summary init TimeInstantTypeCondition(type: TimeInstantType) Inheritors Name Summary TimeConsumedCondition class TimeConsumedCondition : TimeInstantTypeCondition TimeRecordedCondition class TimeRecordedCondition : TimeInstantTypeCondition","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/#timeinstanttypecondition","text":"abstract class TimeInstantTypeCondition","title":"TimeInstantTypeCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/#constructors","text":"Name Summary init TimeInstantTypeCondition(type: TimeInstantType)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/#inheritors","text":"Name Summary TimeConsumedCondition class TimeConsumedCondition : TimeInstantTypeCondition TimeRecordedCondition class TimeRecordedCondition : TimeInstantTypeCondition","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeInstantTypeCondition / init init TimeInstantTypeCondition(type: TimeInstantType)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-instant-type-condition/-init-/#init","text":"TimeInstantTypeCondition(type: TimeInstantType)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeRecordedCondition TimeRecordedCondition class TimeRecordedCondition : TimeInstantTypeCondition Constructors Name Summary init TimeRecordedCondition()","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/#timerecordedcondition","text":"class TimeRecordedCondition : TimeInstantTypeCondition","title":"TimeRecordedCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/#constructors","text":"Name Summary init TimeRecordedCondition()","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / TimeRecordedCondition / init init TimeRecordedCondition()","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-time-recorded-condition/-init-/#init","text":"TimeRecordedCondition()","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultCustomQueryCriteriaWrapperCondition VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. Constructors Name Summary init VaultCustomQueryCriteriaWrapperCondition(criterion: VaultCustomQueryCriteria * ) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. Functions Name Summary toCriteria fun toCriteria(): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/#vaultcustomquerycriteriawrappercondition","text":"open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"VaultCustomQueryCriteriaWrapperCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/#constructors","text":"Name Summary init VaultCustomQueryCriteriaWrapperCondition(criterion: VaultCustomQueryCriteria * ) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/#functions","text":"Name Summary toCriteria fun toCriteria(): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultCustomQueryCriteriaWrapperCondition / init init VaultCustomQueryCriteriaWrapperCondition(criterion: VaultCustomQueryCriteria * ) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/-init-/#init","text":"VaultCustomQueryCriteriaWrapperCondition(criterion: VaultCustomQueryCriteria * ) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultCustomQueryCriteriaWrapperCondition / toCriteria toCriteria fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/to-criteria/#tocriteria","text":"fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort Constructors Name Summary init VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List StateRef ? = null, notary: List AbstractParty ? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set Type = emptySet(), constraints: Set ConstraintInfo = emptySet(), externalIds: List UUID = emptyList(), participants: List AbstractParty ? = null) A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort Properties Name Summary constraints open var constraints: Set ConstraintInfo constraintTypes open var constraintTypes: Set Type contractStateType abstract val contractStateType: Class out ContractState The target ContractState type externalIds open var externalIds: List UUID notary open var notary: List AbstractParty ? participants open var participants: List AbstractParty ? relevancyStatus open var relevancyStatus: RelevancyStatus softLockingCondition open var softLockingCondition: SoftLockingCondition? statePersistableType abstract val statePersistableType: Class P The target StatePersistable type stateRefs open var stateRefs: List StateRef ? status open var status: StateStatus timeCondition open var timeCondition: TimeCondition? timeConsumed val timeConsumed: TimeConsumedCondition timeRecorded val timeRecorded: TimeRecordedCondition Inherited Properties Name Summary fields abstract val fields: F The fields of the target StatePersistable type P Functions Name Summary aggregate fun aggregate(initializer: Aggregates P .() - Unit): Unit greaterThan infix fun TimeInstantTypeCondition .greaterThan(instant: Instant): Unit greaterThanOrEqual infix fun TimeInstantTypeCondition .greaterThanOrEqual(instant: Instant): Unit gt infix fun TimeInstantTypeCondition .gt(instant: Instant): Unit gtw infix fun TimeInstantTypeCondition .gtw(instant: Instant): Unit lessThan infix fun TimeInstantTypeCondition .lessThan(instant: Instant): Unit lessThanOrEqual infix fun TimeInstantTypeCondition .lessThanOrEqual(instant: Instant): Unit lt infix fun TimeInstantTypeCondition .lt(instant: Instant): Unit ltw infix fun TimeInstantTypeCondition .ltw(instant: Instant): Unit orderBy fun orderBy(initializer: SortColumns P .() - Unit): Unit toCriteria open fun toCriteria(): QueryCriteria fun toCriteria(ignoreAggregates: Boolean = false): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise toSort fun toSort(): Sort Inherited Functions Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#vaultquerycriteriacondition","text":"abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F , RootCondition P A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"VaultQueryCriteriaCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#constructors","text":"Name Summary init VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List StateRef ? = null, notary: List AbstractParty ? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set Type = emptySet(), constraints: Set ConstraintInfo = emptySet(), externalIds: List UUID = emptyList(), participants: List AbstractParty ? = null) A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#properties","text":"Name Summary constraints open var constraints: Set ConstraintInfo constraintTypes open var constraintTypes: Set Type contractStateType abstract val contractStateType: Class out ContractState The target ContractState type externalIds open var externalIds: List UUID notary open var notary: List AbstractParty ? participants open var participants: List AbstractParty ? relevancyStatus open var relevancyStatus: RelevancyStatus softLockingCondition open var softLockingCondition: SoftLockingCondition? statePersistableType abstract val statePersistableType: Class P The target StatePersistable type stateRefs open var stateRefs: List StateRef ? status open var status: StateStatus timeCondition open var timeCondition: TimeCondition? timeConsumed val timeConsumed: TimeConsumedCondition timeRecorded val timeRecorded: TimeRecordedCondition","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#inherited-properties","text":"Name Summary fields abstract val fields: F The fields of the target StatePersistable type P","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#functions","text":"Name Summary aggregate fun aggregate(initializer: Aggregates P .() - Unit): Unit greaterThan infix fun TimeInstantTypeCondition .greaterThan(instant: Instant): Unit greaterThanOrEqual infix fun TimeInstantTypeCondition .greaterThanOrEqual(instant: Instant): Unit gt infix fun TimeInstantTypeCondition .gt(instant: Instant): Unit gtw infix fun TimeInstantTypeCondition .gtw(instant: Instant): Unit lessThan infix fun TimeInstantTypeCondition .lessThan(instant: Instant): Unit lessThanOrEqual infix fun TimeInstantTypeCondition .lessThanOrEqual(instant: Instant): Unit lt infix fun TimeInstantTypeCondition .lt(instant: Instant): Unit ltw infix fun TimeInstantTypeCondition .ltw(instant: Instant): Unit orderBy fun orderBy(initializer: SortColumns P .() - Unit): Unit toCriteria open fun toCriteria(): QueryCriteria fun toCriteria(ignoreAggregates: Boolean = false): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise toSort fun toSort(): Sort","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#inherited-functions","text":"Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / init init VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List StateRef ? = null, notary: List AbstractParty ? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set Type = emptySet(), constraints: Set ConstraintInfo = emptySet(), externalIds: List UUID = emptyList(), participants: List AbstractParty ? = null) A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/-init-/#init","text":"VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List StateRef ? = null, notary: List AbstractParty ? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set Type = emptySet(), constraints: Set ConstraintInfo = emptySet(), externalIds: List UUID = emptyList(), participants: List AbstractParty ? = null) A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/aggregate/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / aggregate aggregate fun aggregate(initializer: Aggregates P .() - Unit): Unit","title":"Aggregate"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/aggregate/#aggregate","text":"fun aggregate(initializer: Aggregates P .() - Unit): Unit","title":"aggregate"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraint-types/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / constraintTypes constraintTypes open var constraintTypes: Set Type Overrides RootCondition.constraintTypes","title":"Constraint types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraint-types/#constrainttypes","text":"open var constraintTypes: Set Type Overrides RootCondition.constraintTypes","title":"constraintTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraints/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / constraints constraints open var constraints: Set ConstraintInfo Overrides RootCondition.constraints","title":"Constraints"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraints/#constraints","text":"open var constraints: Set ConstraintInfo Overrides RootCondition.constraints","title":"constraints"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/contract-state-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / contractStateType contractStateType abstract val contractStateType: Class out ContractState The target ContractState type","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/contract-state-type/#contractstatetype","text":"abstract val contractStateType: Class out ContractState The target ContractState type","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/external-ids/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / externalIds externalIds open var externalIds: List UUID Overrides RootCondition.externalIds","title":"External ids"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/external-ids/#externalids","text":"open var externalIds: List UUID Overrides RootCondition.externalIds","title":"externalIds"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/greater-than-or-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / greaterThanOrEqual greaterThanOrEqual infix fun TimeInstantTypeCondition .greaterThanOrEqual(instant: Instant): Unit","title":"Greater than or equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/greater-than-or-equal/#greaterthanorequal","text":"infix fun TimeInstantTypeCondition .greaterThanOrEqual(instant: Instant): Unit","title":"greaterThanOrEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/greater-than/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / greaterThan greaterThan infix fun TimeInstantTypeCondition .greaterThan(instant: Instant): Unit","title":"Greater than"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/greater-than/#greaterthan","text":"infix fun TimeInstantTypeCondition .greaterThan(instant: Instant): Unit","title":"greaterThan"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/gt/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / gt gt infix fun TimeInstantTypeCondition .gt(instant: Instant): Unit","title":"Gt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/gt/#gt","text":"infix fun TimeInstantTypeCondition .gt(instant: Instant): Unit","title":"gt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/gtw/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / gtw gtw infix fun TimeInstantTypeCondition .gtw(instant: Instant): Unit","title":"Gtw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/gtw/#gtw","text":"infix fun TimeInstantTypeCondition .gtw(instant: Instant): Unit","title":"gtw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/less-than-or-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / lessThanOrEqual lessThanOrEqual infix fun TimeInstantTypeCondition .lessThanOrEqual(instant: Instant): Unit","title":"Less than or equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/less-than-or-equal/#lessthanorequal","text":"infix fun TimeInstantTypeCondition .lessThanOrEqual(instant: Instant): Unit","title":"lessThanOrEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/less-than/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / lessThan lessThan infix fun TimeInstantTypeCondition .lessThan(instant: Instant): Unit","title":"Less than"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/less-than/#lessthan","text":"infix fun TimeInstantTypeCondition .lessThan(instant: Instant): Unit","title":"lessThan"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/lt/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / lt lt infix fun TimeInstantTypeCondition .lt(instant: Instant): Unit","title":"Lt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/lt/#lt","text":"infix fun TimeInstantTypeCondition .lt(instant: Instant): Unit","title":"lt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/ltw/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / ltw ltw infix fun TimeInstantTypeCondition .ltw(instant: Instant): Unit","title":"Ltw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/ltw/#ltw","text":"infix fun TimeInstantTypeCondition .ltw(instant: Instant): Unit","title":"ltw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/notary/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / notary notary open var notary: List AbstractParty ? Overrides RootCondition.notary","title":"Notary"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/notary/#notary","text":"open var notary: List AbstractParty ? Overrides RootCondition.notary","title":"notary"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/order-by/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / orderBy orderBy fun orderBy(initializer: SortColumns P .() - Unit): Unit","title":"Order by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/order-by/#orderby","text":"fun orderBy(initializer: SortColumns P .() - Unit): Unit","title":"orderBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/participants/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / participants participants open var participants: List AbstractParty ? Overrides RootCondition.participants","title":"Participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/participants/#participants","text":"open var participants: List AbstractParty ? Overrides RootCondition.participants","title":"participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/relevancy-status/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / relevancyStatus relevancyStatus open var relevancyStatus: RelevancyStatus Overrides RootCondition.relevancyStatus","title":"Relevancy status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/relevancy-status/#relevancystatus","text":"open var relevancyStatus: RelevancyStatus Overrides RootCondition.relevancyStatus","title":"relevancyStatus"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/soft-locking-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / softLockingCondition softLockingCondition open var softLockingCondition: SoftLockingCondition? Overrides RootCondition.softLockingCondition","title":"Soft locking condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/soft-locking-condition/#softlockingcondition","text":"open var softLockingCondition: SoftLockingCondition? Overrides RootCondition.softLockingCondition","title":"softLockingCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-persistable-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / statePersistableType statePersistableType abstract val statePersistableType: Class P The target StatePersistable type","title":"State persistable type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-persistable-type/#statepersistabletype","text":"abstract val statePersistableType: Class P The target StatePersistable type","title":"statePersistableType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-refs/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / stateRefs stateRefs open var stateRefs: List StateRef ? Overrides RootCondition.stateRefs","title":"State refs"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-refs/#staterefs","text":"open var stateRefs: List StateRef ? Overrides RootCondition.stateRefs","title":"stateRefs"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/status/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / status status open var status: StateStatus Overrides RootCondition.status","title":"Status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/status/#status","text":"open var status: StateStatus Overrides RootCondition.status","title":"status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / timeCondition timeCondition open var timeCondition: TimeCondition? Overrides RootCondition.timeCondition","title":"Time condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-condition/#timecondition","text":"open var timeCondition: TimeCondition? Overrides RootCondition.timeCondition","title":"timeCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-consumed/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / timeConsumed timeConsumed val timeConsumed: TimeConsumedCondition","title":"Time consumed"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-consumed/#timeconsumed","text":"val timeConsumed: TimeConsumedCondition","title":"timeConsumed"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-recorded/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / timeRecorded timeRecorded val timeRecorded: TimeRecordedCondition","title":"Time recorded"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-recorded/#timerecorded","text":"val timeRecorded: TimeRecordedCondition","title":"timeRecorded"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / toCriteria toCriteria open fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise fun toCriteria(ignoreAggregates: Boolean = false): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise Parameters ignoreAggregates - whether to ignore aggregate functions. Corda paged queries can have either state or aggregate results, but not both.","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-criteria/#tocriteria","text":"open fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise fun toCriteria(ignoreAggregates: Boolean = false): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-criteria/#parameters","text":"ignoreAggregates - whether to ignore aggregate functions. Corda paged queries can have either state or aggregate results, but not both.","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-sort/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / toSort toSort fun toSort(): Sort","title":"To sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-sort/#tosort","text":"fun toSort(): Sort","title":"toSort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/","text":"com.github.manosbatsis.vaultaire.dto Package com.github.manosbatsis.vaultaire.dto Types Name Summary AccountParty data class AccountParty Convenient participant type that combines a known Corda Account ID with a corresponding anonymous party. VaultaireBaseLiteDto interface VaultaireBaseLiteDto T : ContractState, S : StateService T Modeled after com.github.manosbatsis.kotlin.utils.api.Dto only bringing a StateService in-context for toTargetType and toPatched . VaultaireLiteDto interface VaultaireLiteDto T : ContractState : VaultaireBaseLiteDto T , StateService T","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/#package-comgithubmanosbatsisvaultairedto","text":"","title":"Package com.github.manosbatsis.vaultaire.dto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/#types","text":"Name Summary AccountParty data class AccountParty Convenient participant type that combines a known Corda Account ID with a corresponding anonymous party. VaultaireBaseLiteDto interface VaultaireBaseLiteDto T : ContractState, S : StateService T Modeled after com.github.manosbatsis.kotlin.utils.api.Dto only bringing a StateService in-context for toTargetType and toPatched . VaultaireLiteDto interface VaultaireLiteDto T : ContractState : VaultaireBaseLiteDto T , StateService T","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireLiteDto VaultaireLiteDto interface VaultaireLiteDto T : ContractState : VaultaireBaseLiteDto T , StateService T Inherited Functions Name Summary toName open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name toNameOrNull open fun toNameOrNull(party: Party?): CordaX500Name? toParty open fun toParty(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefault open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefaultNullable open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party? toPartyOrNull open fun toPartyOrNull(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party? toPatched abstract fun toPatched(original: T , stateService: S ): T Create a patched copy of the given T instance, updated using this DTO s non-null properties toTargetType abstract fun toTargetType(stateService: S ): T Create an instance of T , using this DTO s properties. May throw a DtoInsufficientMappingException if there is mot enough information to do so.","title":" vaultaire lite dto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/#vaultairelitedto","text":"interface VaultaireLiteDto T : ContractState : VaultaireBaseLiteDto T , StateService T","title":"VaultaireLiteDto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-lite-dto/#inherited-functions","text":"Name Summary toName open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name toNameOrNull open fun toNameOrNull(party: Party?): CordaX500Name? toParty open fun toParty(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefault open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefaultNullable open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party? toPartyOrNull open fun toPartyOrNull(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party? toPatched abstract fun toPatched(original: T , stateService: S ): T Create a patched copy of the given T instance, updated using this DTO s non-null properties toTargetType abstract fun toTargetType(stateService: S ): T Create an instance of T , using this DTO s properties. May throw a DtoInsufficientMappingException if there is mot enough information to do so.","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/","text":"com.github.manosbatsis.vaultaire.dto / AccountParty AccountParty data class AccountParty Convenient participant type that combines a known Corda Account ID with a corresponding anonymous party. Constructors Name Summary init AccountParty(identifier: UUID, name: String, party: AnonymousParty) Convenient participant type that combines a known Corda Account ID with a corresponding anonymous party. Properties Name Summary identifier var identifier: UUID The account ID, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.identifier name var name: String The account name, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.name party var party: AnonymousParty The account party Functions Name Summary hasMatchingIdentifier fun hasMatchingIdentifier(other: AccountParty ?): Boolean","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/#accountparty","text":"data class AccountParty Convenient participant type that combines a known Corda Account ID with a corresponding anonymous party.","title":"AccountParty"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/#constructors","text":"Name Summary init AccountParty(identifier: UUID, name: String, party: AnonymousParty) Convenient participant type that combines a known Corda Account ID with a corresponding anonymous party.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/#properties","text":"Name Summary identifier var identifier: UUID The account ID, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.identifier name var name: String The account name, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.name party var party: AnonymousParty The account party","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/#functions","text":"Name Summary hasMatchingIdentifier fun hasMatchingIdentifier(other: AccountParty ?): Boolean","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/-init-/","text":"com.github.manosbatsis.vaultaire.dto / AccountParty / init init AccountParty(identifier: UUID, name: String, party: AnonymousParty) Convenient participant type that combines a known Corda Account ID with a corresponding anonymous party.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/-init-/#init","text":"AccountParty(identifier: UUID, name: String, party: AnonymousParty) Convenient participant type that combines a known Corda Account ID with a corresponding anonymous party.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/has-matching-identifier/","text":"com.github.manosbatsis.vaultaire.dto / AccountParty / hasMatchingIdentifier hasMatchingIdentifier fun hasMatchingIdentifier(other: AccountParty ?): Boolean","title":"Has matching identifier"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/has-matching-identifier/#hasmatchingidentifier","text":"fun hasMatchingIdentifier(other: AccountParty ?): Boolean","title":"hasMatchingIdentifier"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/identifier/","text":"com.github.manosbatsis.vaultaire.dto / AccountParty / identifier identifier var identifier: UUID The account ID, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.identifier","title":"Identifier"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/identifier/#identifier","text":"var identifier: UUID The account ID, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.identifier","title":"identifier"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/name/","text":"com.github.manosbatsis.vaultaire.dto / AccountParty / name name var name: String The account name, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.name","title":"Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/name/#name","text":"var name: String The account name, maps to com.r3.corda.lib.accounts.contracts.states.AccountInfo.name","title":"name"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/party/","text":"com.github.manosbatsis.vaultaire.dto / AccountParty / party party var party: AnonymousParty The account party","title":"Party"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-account-party/party/#party","text":"var party: AnonymousParty The account party","title":"party"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireBaseLiteDto VaultaireBaseLiteDto interface VaultaireBaseLiteDto T : ContractState, S : StateService T Modeled after com.github.manosbatsis.kotlin.utils.api.Dto only bringing a StateService in-context for toTargetType and toPatched . Functions Name Summary toName open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name toNameOrNull open fun toNameOrNull(party: Party?): CordaX500Name? toParty open fun toParty(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefault open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefaultNullable open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party? toPartyOrNull open fun toPartyOrNull(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party? toPatched abstract fun toPatched(original: T , stateService: S ): T Create a patched copy of the given T instance, updated using this DTO s non-null properties toTargetType abstract fun toTargetType(stateService: S ): T Create an instance of T , using this DTO s properties. May throw a DtoInsufficientMappingException if there is mot enough information to do so. Inheritors Name Summary VaultaireLiteDto interface VaultaireLiteDto T : ContractState : VaultaireBaseLiteDto T , StateService T","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/#vaultairebaselitedto","text":"interface VaultaireBaseLiteDto T : ContractState, S : StateService T Modeled after com.github.manosbatsis.kotlin.utils.api.Dto only bringing a StateService in-context for toTargetType and toPatched .","title":"VaultaireBaseLiteDto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/#functions","text":"Name Summary toName open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name toNameOrNull open fun toNameOrNull(party: Party?): CordaX500Name? toParty open fun toParty(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefault open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party toPartyOrDefaultNullable open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party? toPartyOrNull open fun toPartyOrNull(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party? toPatched abstract fun toPatched(original: T , stateService: S ): T Create a patched copy of the given T instance, updated using this DTO s non-null properties toTargetType abstract fun toTargetType(stateService: S ): T Create an instance of T , using this DTO s properties. May throw a DtoInsufficientMappingException if there is mot enough information to do so.","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/#inheritors","text":"Name Summary VaultaireLiteDto interface VaultaireLiteDto T : ContractState : VaultaireBaseLiteDto T , StateService T","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-name-or-null/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireBaseLiteDto / toNameOrNull toNameOrNull open fun toNameOrNull(party: Party?): CordaX500Name?","title":"To name or null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-name-or-null/#tonameornull","text":"open fun toNameOrNull(party: Party?): CordaX500Name?","title":"toNameOrNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-name/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireBaseLiteDto / toName toName open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name","title":"To name"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-name/#toname","text":"open fun toName(party: Party?, propertyName: String = \"unknown\"): CordaX500Name","title":"toName"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-party-or-default-nullable/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireBaseLiteDto / toPartyOrDefaultNullable toPartyOrDefaultNullable open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party?","title":"To party or default nullable"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-party-or-default-nullable/#topartyordefaultnullable","text":"open fun toPartyOrDefaultNullable(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party?","title":"toPartyOrDefaultNullable"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-party-or-default/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireBaseLiteDto / toPartyOrDefault toPartyOrDefault open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party","title":"To party or default"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-party-or-default/#topartyordefault","text":"open fun toPartyOrDefault(partyName: CordaX500Name?, defaultValue: Party?, stateService: S , propertyName: String = \"unknown\"): Party","title":"toPartyOrDefault"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-party-or-null/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireBaseLiteDto / toPartyOrNull toPartyOrNull open fun toPartyOrNull(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party?","title":"To party or null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-party-or-null/#topartyornull","text":"open fun toPartyOrNull(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party?","title":"toPartyOrNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-party/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireBaseLiteDto / toParty toParty open fun toParty(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party","title":"To party"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-party/#toparty","text":"open fun toParty(partyName: CordaX500Name?, stateService: S , propertyName: String = \"unknown\"): Party","title":"toParty"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-patched/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireBaseLiteDto / toPatched toPatched abstract fun toPatched(original: T , stateService: S ): T Create a patched copy of the given T instance, updated using this DTO s non-null properties","title":"To patched"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-patched/#topatched","text":"abstract fun toPatched(original: T , stateService: S ): T Create a patched copy of the given T instance, updated using this DTO s non-null properties","title":"toPatched"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-target-type/","text":"com.github.manosbatsis.vaultaire.dto / VaultaireBaseLiteDto / toTargetType toTargetType abstract fun toTargetType(stateService: S ): T Create an instance of T , using this DTO s properties. May throw a DtoInsufficientMappingException if there is mot enough information to do so.","title":"To target type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-vaultaire-base-lite-dto/to-target-type/#totargettype","text":"abstract fun toTargetType(stateService: S ): T Create an instance of T , using this DTO s properties. May throw a DtoInsufficientMappingException if there is mot enough information to do so.","title":"toTargetType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/","text":"com.github.manosbatsis.vaultaire.dto.attachment Package com.github.manosbatsis.vaultaire.dto.attachment Types Name Summary Attachment data class Attachment : Closeable Data transfer object representing an attachment to be persisted in the vault AttachmentFile data class AttachmentFile Data transfer object representing an attachment file to be persisted in the vault AttachmentReceipt class AttachmentReceipt Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable.","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/#package-comgithubmanosbatsisvaultairedtoattachment","text":"","title":"Package com.github.manosbatsis.vaultaire.dto.attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/#types","text":"Name Summary Attachment data class Attachment : Closeable Data transfer object representing an attachment to be persisted in the vault AttachmentFile data class AttachmentFile Data transfer object representing an attachment file to be persisted in the vault AttachmentReceipt class AttachmentReceipt Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable.","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/","text":"com.github.manosbatsis.vaultaire.dto.attachment / Attachment Attachment data class Attachment : Closeable Data transfer object representing an attachment to be persisted in the vault Constructors Name Summary init Attachment(tmpFile: File? = null, inputStream: InputStream, filenames: List String , original: Boolean = false) Data transfer object representing an attachment to be persisted in the vault Properties Name Summary filenames val filenames: List String The files contained in the attachment archive inputStream val inputStream: InputStream The attachment input stream to upload original val original: Boolean true if an archive as originally uploaded, false if automatically created to save in the vault tmpFile val tmpFile: File? The temporary file backing this attachment, if any Functions Name Summary close fun close(): Unit","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/#attachment","text":"data class Attachment : Closeable Data transfer object representing an attachment to be persisted in the vault","title":"Attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/#constructors","text":"Name Summary init Attachment(tmpFile: File? = null, inputStream: InputStream, filenames: List String , original: Boolean = false) Data transfer object representing an attachment to be persisted in the vault","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/#properties","text":"Name Summary filenames val filenames: List String The files contained in the attachment archive inputStream val inputStream: InputStream The attachment input stream to upload original val original: Boolean true if an archive as originally uploaded, false if automatically created to save in the vault tmpFile val tmpFile: File? The temporary file backing this attachment, if any","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/#functions","text":"Name Summary close fun close(): Unit","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/-init-/","text":"com.github.manosbatsis.vaultaire.dto.attachment / Attachment / init init Attachment(tmpFile: File? = null, inputStream: InputStream, filenames: List String , original: Boolean = false) Data transfer object representing an attachment to be persisted in the vault","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/-init-/#init","text":"Attachment(tmpFile: File? = null, inputStream: InputStream, filenames: List String , original: Boolean = false) Data transfer object representing an attachment to be persisted in the vault","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/close/","text":"com.github.manosbatsis.vaultaire.dto.attachment / Attachment / close close fun close(): Unit","title":"Close"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/close/#close","text":"fun close(): Unit","title":"close"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/filenames/","text":"com.github.manosbatsis.vaultaire.dto.attachment / Attachment / filenames filenames val filenames: List String The files contained in the attachment archive","title":"Filenames"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/filenames/#filenames","text":"val filenames: List String The files contained in the attachment archive","title":"filenames"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/input-stream/","text":"com.github.manosbatsis.vaultaire.dto.attachment / Attachment / inputStream inputStream val inputStream: InputStream The attachment input stream to upload","title":"Input stream"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/input-stream/#inputstream","text":"val inputStream: InputStream The attachment input stream to upload","title":"inputStream"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/original/","text":"com.github.manosbatsis.vaultaire.dto.attachment / Attachment / original original val original: Boolean true if an archive as originally uploaded, false if automatically created to save in the vault","title":"Original"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/original/#original","text":"val original: Boolean true if an archive as originally uploaded, false if automatically created to save in the vault","title":"original"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/tmp-file/","text":"com.github.manosbatsis.vaultaire.dto.attachment / Attachment / tmpFile tmpFile val tmpFile: File? The temporary file backing this attachment, if any","title":"Tmp file"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment/tmp-file/#tmpfile","text":"val tmpFile: File? The temporary file backing this attachment, if any","title":"tmpFile"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentFile AttachmentFile data class AttachmentFile Data transfer object representing an attachment file to be persisted in the vault Constructors Name Summary init AttachmentFile(name: String, originalFilename: String, inputStream: InputStream, size: Long, contentType: String?) Data transfer object representing an attachment file to be persisted in the vault Properties Name Summary contentType val contentType: String? inputStream val inputStream: InputStream name val name: String originalFilename val originalFilename: String size val size: Long","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/#attachmentfile","text":"data class AttachmentFile Data transfer object representing an attachment file to be persisted in the vault","title":"AttachmentFile"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/#constructors","text":"Name Summary init AttachmentFile(name: String, originalFilename: String, inputStream: InputStream, size: Long, contentType: String?) Data transfer object representing an attachment file to be persisted in the vault","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/#properties","text":"Name Summary contentType val contentType: String? inputStream val inputStream: InputStream name val name: String originalFilename val originalFilename: String size val size: Long","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/-init-/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentFile / init init AttachmentFile(name: String, originalFilename: String, inputStream: InputStream, size: Long, contentType: String?) Data transfer object representing an attachment file to be persisted in the vault","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/-init-/#init","text":"AttachmentFile(name: String, originalFilename: String, inputStream: InputStream, size: Long, contentType: String?) Data transfer object representing an attachment file to be persisted in the vault","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/content-type/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentFile / contentType contentType val contentType: String?","title":"Content type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/content-type/#contenttype","text":"val contentType: String?","title":"contentType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/input-stream/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentFile / inputStream inputStream val inputStream: InputStream","title":"Input stream"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/input-stream/#inputstream","text":"val inputStream: InputStream","title":"inputStream"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/name/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentFile / name name val name: String","title":"Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/name/#name","text":"val name: String","title":"name"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/original-filename/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentFile / originalFilename originalFilename val originalFilename: String","title":"Original filename"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/original-filename/#originalfilename","text":"val originalFilename: String","title":"originalFilename"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/size/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentFile / size size val size: Long","title":"Size"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-file/size/#size","text":"val size: Long","title":"size"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentReceipt AttachmentReceipt class AttachmentReceipt Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable. Constructors Name Summary init AttachmentReceipt(date: Date? = null, hash: String? = null, files: List String = emptyList(), author: String? = null, savedOriginal: Boolean = false) Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable. Properties Name Summary author var author: String? The attachment authoring organization date var date: Date? The datetime of attachment persistence to the vault files var files: List String The attached files hash var hash: String? The attachment net.corda.core.crypto.SecureHash string savedOriginal var savedOriginal: Boolean Whether an original archive was persisted in the vault, false if automatically created","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/#attachmentreceipt","text":"class AttachmentReceipt Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable.","title":"AttachmentReceipt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/#constructors","text":"Name Summary init AttachmentReceipt(date: Date? = null, hash: String? = null, files: List String = emptyList(), author: String? = null, savedOriginal: Boolean = false) Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/#properties","text":"Name Summary author var author: String? The attachment authoring organization date var date: Date? The datetime of attachment persistence to the vault files var files: List String The attached files hash var hash: String? The attachment net.corda.core.crypto.SecureHash string savedOriginal var savedOriginal: Boolean Whether an original archive was persisted in the vault, false if automatically created","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/-init-/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentReceipt / init init AttachmentReceipt(date: Date? = null, hash: String? = null, files: List String = emptyList(), author: String? = null, savedOriginal: Boolean = false) Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/-init-/#init","text":"AttachmentReceipt(date: Date? = null, hash: String? = null, files: List String = emptyList(), author: String? = null, savedOriginal: Boolean = false) Receipt of an attachment saved to the vault. Annotated with CordaSerializable and thus ContractState -embeddable.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/author/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentReceipt / author author var author: String? The attachment authoring organization","title":"Author"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/author/#author","text":"var author: String? The attachment authoring organization","title":"author"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/date/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentReceipt / date date var date: Date? The datetime of attachment persistence to the vault","title":"Date"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/date/#date","text":"var date: Date? The datetime of attachment persistence to the vault","title":"date"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/files/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentReceipt / files files var files: List String The attached files","title":"Files"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/files/#files","text":"var files: List String The attached files","title":"files"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/hash/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentReceipt / hash hash var hash: String? The attachment net.corda.core.crypto.SecureHash string","title":"Hash"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/hash/#hash","text":"var hash: String? The attachment net.corda.core.crypto.SecureHash string","title":"hash"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/saved-original/","text":"com.github.manosbatsis.vaultaire.dto.attachment / AttachmentReceipt / savedOriginal savedOriginal var savedOriginal: Boolean Whether an original archive was persisted in the vault, false if automatically created","title":"Saved original"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.attachment/-attachment-receipt/saved-original/#savedoriginal","text":"var savedOriginal: Boolean Whether an original archive was persisted in the vault, false if automatically created","title":"savedOriginal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/","text":"com.github.manosbatsis.vaultaire.dto.info Package com.github.manosbatsis.vaultaire.dto.info Types Name Summary ExtendedNodeInfo data class ExtendedNodeInfo NetworkInfo data class NetworkInfo","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/#package-comgithubmanosbatsisvaultairedtoinfo","text":"","title":"Package com.github.manosbatsis.vaultaire.dto.info"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/#types","text":"Name Summary ExtendedNodeInfo data class ExtendedNodeInfo NetworkInfo data class NetworkInfo","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo ExtendedNodeInfo data class ExtendedNodeInfo Constructors Name Summary init ExtendedNodeInfo(platformVersion: Int, identity: Party, identities: List Party , notaries: List Party , flows: List String , addresses: List NetworkHostAndPort ) Properties Name Summary addresses val addresses: List NetworkHostAndPort flows val flows: List String identities val identities: List Party identity val identity: Party notaries val notaries: List Party platformVersion val platformVersion: Int","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/#extendednodeinfo","text":"data class ExtendedNodeInfo","title":"ExtendedNodeInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/#constructors","text":"Name Summary init ExtendedNodeInfo(platformVersion: Int, identity: Party, identities: List Party , notaries: List Party , flows: List String , addresses: List NetworkHostAndPort )","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/#properties","text":"Name Summary addresses val addresses: List NetworkHostAndPort flows val flows: List String identities val identities: List Party identity val identity: Party notaries val notaries: List Party platformVersion val platformVersion: Int","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/-init-/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo / init init ExtendedNodeInfo(platformVersion: Int, identity: Party, identities: List Party , notaries: List Party , flows: List String , addresses: List NetworkHostAndPort )","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/-init-/#init","text":"ExtendedNodeInfo(platformVersion: Int, identity: Party, identities: List Party , notaries: List Party , flows: List String , addresses: List NetworkHostAndPort )","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/addresses/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo / addresses addresses val addresses: List NetworkHostAndPort","title":"Addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/addresses/#addresses","text":"val addresses: List NetworkHostAndPort","title":"addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/flows/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo / flows flows val flows: List String","title":"Flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/flows/#flows","text":"val flows: List String","title":"flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/identities/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo / identities identities val identities: List Party","title":"Identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/identities/#identities","text":"val identities: List Party","title":"identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/identity/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo / identity identity val identity: Party","title":"Identity"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/identity/#identity","text":"val identity: Party","title":"identity"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/notaries/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo / notaries notaries val notaries: List Party","title":"Notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/notaries/#notaries","text":"val notaries: List Party","title":"notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/platform-version/","text":"com.github.manosbatsis.vaultaire.dto.info / ExtendedNodeInfo / platformVersion platformVersion val platformVersion: Int","title":"Platform version"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-extended-node-info/platform-version/#platformversion","text":"val platformVersion: Int","title":"platformVersion"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/","text":"com.github.manosbatsis.vaultaire.dto.info / NetworkInfo NetworkInfo data class NetworkInfo Constructors Name Summary init NetworkInfo(nodes: Map String, ExtendedNodeInfo ) Properties Name Summary nodes val nodes: Map String, ExtendedNodeInfo","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/#networkinfo","text":"data class NetworkInfo","title":"NetworkInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/#constructors","text":"Name Summary init NetworkInfo(nodes: Map String, ExtendedNodeInfo )","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/#properties","text":"Name Summary nodes val nodes: Map String, ExtendedNodeInfo","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/-init-/","text":"com.github.manosbatsis.vaultaire.dto.info / NetworkInfo / init init NetworkInfo(nodes: Map String, ExtendedNodeInfo )","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/-init-/#init","text":"NetworkInfo(nodes: Map String, ExtendedNodeInfo )","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/nodes/","text":"com.github.manosbatsis.vaultaire.dto.info / NetworkInfo / nodes nodes val nodes: Map String, ExtendedNodeInfo","title":"Nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto.info/-network-info/nodes/#nodes","text":"val nodes: Map String, ExtendedNodeInfo","title":"nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/","text":"com.github.manosbatsis.vaultaire.registry Package com.github.manosbatsis.vaultaire.registry Types Name Summary Registry object Registry","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/#package-comgithubmanosbatsisvaultaireregistry","text":"","title":"Package com.github.manosbatsis.vaultaire.registry"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/#types","text":"Name Summary Registry object Registry","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/","text":"com.github.manosbatsis.vaultaire.registry / Registry Registry object Registry Functions Name Summary getServices fun getServices(): Map Class * , Class * getStateServiceType fun T : ContractState, S : StateService T getStateServiceType(contractStateType: Class T ): Class S ? registerQueryDsl fun P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F registerQueryDsl(keyType: KClass P , queryCriteriaType: KClass Q ): Class * ? registerService fun T : ContractState, P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F , S : ExtendedStateService T , P , F , Q registerService(keyType: KClass T , serviceType: KClass S ): Class * ? fun registerService(keyType: Class out ContractState , serviceType: Class out ExtendedStateService *, *, *, * ): Class * ?","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/#registry","text":"object Registry","title":"Registry"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/#functions","text":"Name Summary getServices fun getServices(): Map Class * , Class * getStateServiceType fun T : ContractState, S : StateService T getStateServiceType(contractStateType: Class T ): Class S ? registerQueryDsl fun P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F registerQueryDsl(keyType: KClass P , queryCriteriaType: KClass Q ): Class * ? registerService fun T : ContractState, P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F , S : ExtendedStateService T , P , F , Q registerService(keyType: KClass T , serviceType: KClass S ): Class * ? fun registerService(keyType: Class out ContractState , serviceType: Class out ExtendedStateService *, *, *, * ): Class * ?","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/get-services/","text":"com.github.manosbatsis.vaultaire.registry / Registry / getServices getServices fun getServices(): Map Class * , Class *","title":"Get services"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/get-services/#getservices","text":"fun getServices(): Map Class * , Class *","title":"getServices"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/get-state-service-type/","text":"com.github.manosbatsis.vaultaire.registry / Registry / getStateServiceType getStateServiceType fun T : ContractState, S : StateService T getStateServiceType(contractStateType: Class T ): Class S ?","title":"Get state service type"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/get-state-service-type/#getstateservicetype","text":"fun T : ContractState, S : StateService T getStateServiceType(contractStateType: Class T ): Class S ?","title":"getStateServiceType"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-query-dsl/","text":"com.github.manosbatsis.vaultaire.registry / Registry / registerQueryDsl registerQueryDsl fun P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F registerQueryDsl(keyType: KClass P , queryCriteriaType: KClass Q ): Class * ?","title":"Register query dsl"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-query-dsl/#registerquerydsl","text":"fun P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F registerQueryDsl(keyType: KClass P , queryCriteriaType: KClass Q ): Class * ?","title":"registerQueryDsl"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-service/","text":"com.github.manosbatsis.vaultaire.registry / Registry / registerService registerService fun T : ContractState, P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F , S : ExtendedStateService T , P , F , Q registerService(keyType: KClass T , serviceType: KClass S ): Class * ? fun registerService(keyType: Class out ContractState , serviceType: Class out ExtendedStateService *, *, *, * ): Class * ?","title":"Register service"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-service/#registerservice","text":"fun T : ContractState, P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F , S : ExtendedStateService T , P , F , Q registerService(keyType: KClass T , serviceType: KClass S ): Class * ? fun registerService(keyType: Class out ContractState , serviceType: Class out ExtendedStateService *, *, *, * ): Class * ?","title":"registerService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/","text":"com.github.manosbatsis.vaultaire.service Package com.github.manosbatsis.vaultaire.service Types Name Summary ServiceDefaults interface ServiceDefaults SimpleServiceDefaults data class SimpleServiceDefaults : ServiceDefaults Define option defaults for StateService instances","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/#package-comgithubmanosbatsisvaultaireservice","text":"","title":"Package com.github.manosbatsis.vaultaire.service"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/#types","text":"Name Summary ServiceDefaults interface ServiceDefaults SimpleServiceDefaults data class SimpleServiceDefaults : ServiceDefaults Define option defaults for StateService instances","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults ServiceDefaults interface ServiceDefaults Properties Name Summary criteria abstract val criteria: QueryCriteria pageNumber abstract val pageNumber: Int pageSize abstract val pageSize: Int paging abstract val paging: PageSpecification sort abstract val sort: Sort Inheritors Name Summary SimpleServiceDefaults data class SimpleServiceDefaults : ServiceDefaults Define option defaults for StateService instances","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/#servicedefaults","text":"interface ServiceDefaults","title":"ServiceDefaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/#properties","text":"Name Summary criteria abstract val criteria: QueryCriteria pageNumber abstract val pageNumber: Int pageSize abstract val pageSize: Int paging abstract val paging: PageSpecification sort abstract val sort: Sort","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/#inheritors","text":"Name Summary SimpleServiceDefaults data class SimpleServiceDefaults : ServiceDefaults Define option defaults for StateService instances","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/criteria/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / criteria criteria abstract val criteria: QueryCriteria","title":"Criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/criteria/#criteria","text":"abstract val criteria: QueryCriteria","title":"criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/page-number/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / pageNumber pageNumber abstract val pageNumber: Int","title":"Page number"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/page-number/#pagenumber","text":"abstract val pageNumber: Int","title":"pageNumber"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/page-size/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / pageSize pageSize abstract val pageSize: Int","title":"Page size"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/page-size/#pagesize","text":"abstract val pageSize: Int","title":"pageSize"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/paging/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / paging paging abstract val paging: PageSpecification","title":"Paging"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/paging/#paging","text":"abstract val paging: PageSpecification","title":"paging"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/sort/","text":"com.github.manosbatsis.vaultaire.service / ServiceDefaults / sort sort abstract val sort: Sort","title":"Sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-service-defaults/sort/#sort","text":"abstract val sort: Sort","title":"sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/","text":"com.github.manosbatsis.vaultaire.service / SimpleServiceDefaults SimpleServiceDefaults data class SimpleServiceDefaults : ServiceDefaults Define option defaults for StateService instances Constructors Name Summary init SimpleServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances Properties Name Summary criteria val criteria: QueryCriteria pageNumber val pageNumber: Int pageSize val pageSize: Int paging val paging: PageSpecification sort val sort: Sort","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/#simpleservicedefaults","text":"data class SimpleServiceDefaults : ServiceDefaults Define option defaults for StateService instances","title":"SimpleServiceDefaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/#constructors","text":"Name Summary init SimpleServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/#properties","text":"Name Summary criteria val criteria: QueryCriteria pageNumber val pageNumber: Int pageSize val pageSize: Int paging val paging: PageSpecification sort val sort: Sort","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/-init-/","text":"com.github.manosbatsis.vaultaire.service / SimpleServiceDefaults / init init SimpleServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/-init-/#init","text":"SimpleServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/criteria/","text":"com.github.manosbatsis.vaultaire.service / SimpleServiceDefaults / criteria criteria val criteria: QueryCriteria Overrides ServiceDefaults.criteria","title":"Criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/criteria/#criteria","text":"val criteria: QueryCriteria Overrides ServiceDefaults.criteria","title":"criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/page-number/","text":"com.github.manosbatsis.vaultaire.service / SimpleServiceDefaults / pageNumber pageNumber val pageNumber: Int Overrides ServiceDefaults.pageNumber","title":"Page number"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/page-number/#pagenumber","text":"val pageNumber: Int Overrides ServiceDefaults.pageNumber","title":"pageNumber"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/page-size/","text":"com.github.manosbatsis.vaultaire.service / SimpleServiceDefaults / pageSize pageSize val pageSize: Int Overrides ServiceDefaults.pageSize","title":"Page size"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/page-size/#pagesize","text":"val pageSize: Int Overrides ServiceDefaults.pageSize","title":"pageSize"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/paging/","text":"com.github.manosbatsis.vaultaire.service / SimpleServiceDefaults / paging paging val paging: PageSpecification Overrides ServiceDefaults.paging","title":"Paging"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/paging/#paging","text":"val paging: PageSpecification Overrides ServiceDefaults.paging","title":"paging"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/sort/","text":"com.github.manosbatsis.vaultaire.service / SimpleServiceDefaults / sort sort val sort: Sort Overrides ServiceDefaults.sort","title":"Sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service/-simple-service-defaults/sort/#sort","text":"val sort: Sort Overrides ServiceDefaults.sort","title":"sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/","text":"com.github.manosbatsis.vaultaire.service.dao Package com.github.manosbatsis.vaultaire.service.dao Types Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type DefaultExtendedStateService abstract class DefaultExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T , ExtendedStateService T , P , F , Q Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . ExtendedStateService interface ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : StateServiceDelegate T StateCordaServiceDelegate abstract class StateCordaServiceDelegate T : ContractState : NodeCordaServiceDelegate , StateServiceDelegate T Implementation of StateServiceDelegate as a CordaService StateService interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type StateServiceDelegate interface StateServiceDelegate T : ContractState : NodeServiceDelegate StateService delegate for vault operations StateServiceHubDelegate open class StateServiceHubDelegate T : ContractState : NodeServiceHubDelegate, StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation StateServicePoolBoyDelegate open class StateServicePoolBoyDelegate T : ContractState : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate T StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate T : ContractState : NodeServiceRpcConnectionDelegate, StateServiceDelegate T NodeRpcConnection -based StateServiceDelegate implementation","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/#package-comgithubmanosbatsisvaultaireservicedao","text":"","title":"Package com.github.manosbatsis.vaultaire.service.dao"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/#types","text":"Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type DefaultExtendedStateService abstract class DefaultExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T , ExtendedStateService T , P , F , Q Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . ExtendedStateService interface ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : StateServiceDelegate T StateCordaServiceDelegate abstract class StateCordaServiceDelegate T : ContractState : NodeCordaServiceDelegate , StateServiceDelegate T Implementation of StateServiceDelegate as a CordaService StateService interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type StateServiceDelegate interface StateServiceDelegate T : ContractState : NodeServiceDelegate StateService delegate for vault operations StateServiceHubDelegate open class StateServiceHubDelegate T : ContractState : NodeServiceHubDelegate, StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation StateServicePoolBoyDelegate open class StateServicePoolBoyDelegate T : ContractState : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate T StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate T : ContractState : NodeServiceRpcConnectionDelegate, StateServiceDelegate T NodeRpcConnection -based StateServiceDelegate implementation","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/","text":"com.github.manosbatsis.vaultaire.service.dao / BasicStateService BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type Parameters T - the ContractState type Constructors Name Summary init BasicStateService(poolBoy: PoolBoyConnection, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate T ) Basic StateService implementation, used for vault operations on a specific ContractState type Properties Name Summary delegate open val delegate: StateServiceDelegate T ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean Inherited Functions Name Summary countBy open fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria countBy open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByExternalId open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inheritors Name Summary DefaultExtendedStateService abstract class DefaultExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T , ExtendedStateService T , P , F , Q Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields .","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#basicstateservice","text":"open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type","title":"BasicStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#constructors","text":"Name Summary init BasicStateService(poolBoy: PoolBoyConnection, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate T ) Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#properties","text":"Name Summary delegate open val delegate: StateServiceDelegate T ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#inherited-functions","text":"Name Summary countBy open fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria countBy open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByExternalId open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/#inheritors","text":"Name Summary DefaultExtendedStateService abstract class DefaultExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T , ExtendedStateService T , P , F , Q Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields .","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / BasicStateService / init init BasicStateService(poolBoy: PoolBoyConnection, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate T ) Basic StateService implementation, used for vault operations on a specific ContractState type Parameters T - the ContractState type","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/-init-/#init","text":"BasicStateService(poolBoy: PoolBoyConnection, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate T ) Basic StateService implementation, used for vault operations on a specific ContractState type","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/-init-/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / BasicStateService / delegate delegate open val delegate: StateServiceDelegate T Overrides BasicNodeService.delegate","title":"Delegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/delegate/#delegate","text":"open val delegate: StateServiceDelegate T Overrides BasicNodeService.delegate","title":"delegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/of-linear-state/","text":"com.github.manosbatsis.vaultaire.service.dao / BasicStateService / ofLinearState ofLinearState open val ofLinearState: Boolean Overrides StateService.ofLinearState","title":"Of linear state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/of-linear-state/#oflinearstate","text":"open val ofLinearState: Boolean Overrides StateService.ofLinearState","title":"ofLinearState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/of-queryable-state/","text":"com.github.manosbatsis.vaultaire.service.dao / BasicStateService / ofQueryableState ofQueryableState open val ofQueryableState: Boolean Overrides StateService.ofQueryableState","title":"Of queryable state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-basic-state-service/of-queryable-state/#ofqueryablestate","text":"open val ofQueryableState: Boolean Overrides StateService.ofQueryableState","title":"ofQueryableState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/","text":"com.github.manosbatsis.vaultaire.service.dao / DefaultExtendedStateService DefaultExtendedStateService abstract class DefaultExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T , ExtendedStateService T , P , F , Q Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Subclassed by Vaultaire s annotation processing to generate service components. Constructors Name Summary init DefaultExtendedStateService(delegate: StateServiceDelegate T ) Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Properties Name Summary criteriaConditionsType open lateinit var criteriaConditionsType: Class Q The fields of the target StatePersistable type P Inherited Properties Name Summary delegate open val delegate: StateServiceDelegate T fields abstract val fields: F The fields of the target StatePersistable type P ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean statePersistableType abstract val statePersistableType: Class P The type of the target state s StatePersistable Inherited Functions Name Summary buildQuery abstract fun buildQuery(block: Q .() - Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q queryBy open fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page T Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): Page T open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any toSort open fun toSort(vararg sort: Pair String, Direction ): Sort Build a sort from the given string/direction pairs trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): DataFeed Page T , Update T open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any open fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed Page T , Update T Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates.","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/#defaultextendedstateservice","text":"abstract class DefaultExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T , ExtendedStateService T , P , F , Q Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Subclassed by Vaultaire s annotation processing to generate service components.","title":"DefaultExtendedStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/#constructors","text":"Name Summary init DefaultExtendedStateService(delegate: StateServiceDelegate T ) Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields .","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/#properties","text":"Name Summary criteriaConditionsType open lateinit var criteriaConditionsType: Class Q The fields of the target StatePersistable type P","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/#inherited-properties","text":"Name Summary delegate open val delegate: StateServiceDelegate T fields abstract val fields: F The fields of the target StatePersistable type P ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean statePersistableType abstract val statePersistableType: Class P The type of the target state s StatePersistable","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/#inherited-functions","text":"Name Summary buildQuery abstract fun buildQuery(block: Q .() - Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q queryBy open fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page T Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): Page T open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any toSort open fun toSort(vararg sort: Pair String, Direction ): Sort Build a sort from the given string/direction pairs trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): DataFeed Page T , Update T open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any open fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed Page T , Update T Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates.","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / DefaultExtendedStateService / init init DefaultExtendedStateService(delegate: StateServiceDelegate T ) Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Subclassed by Vaultaire s annotation processing to generate service components.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/-init-/#init","text":"DefaultExtendedStateService(delegate: StateServiceDelegate T ) Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Subclassed by Vaultaire s annotation processing to generate service components.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/criteria-conditions-type/","text":"com.github.manosbatsis.vaultaire.service.dao / DefaultExtendedStateService / criteriaConditionsType criteriaConditionsType open lateinit var criteriaConditionsType: Class Q Overrides ExtendedStateService.criteriaConditionsType The fields of the target StatePersistable type P","title":"Criteria conditions type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-default-extended-state-service/criteria-conditions-type/#criteriaconditionstype","text":"open lateinit var criteriaConditionsType: Class Q Overrides ExtendedStateService.criteriaConditionsType The fields of the target StatePersistable type P","title":"criteriaConditionsType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService ExtendedStateService interface ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : StateServiceDelegate T Properties Name Summary criteriaConditionsType abstract var criteriaConditionsType: Class Q The fields of the target StatePersistable type P fields abstract val fields: F The fields of the target StatePersistable type P statePersistableType abstract val statePersistableType: Class P The type of the target state s StatePersistable Inherited Properties Name Summary contractStateType abstract val contractStateType: Class T Functions Name Summary buildQuery abstract fun buildQuery(block: Q .() - Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q queryBy open fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page T Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): Page T open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any toSort open fun toSort(vararg sort: Pair String, Direction ): Sort Build a sort from the given string/direction pairs trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): DataFeed Page T , Update T open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any open fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed Page T , Update T Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates. Inherited Functions Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any Inheritors Name Summary DefaultExtendedStateService abstract class DefaultExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T , ExtendedStateService T , P , F , Q Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields .","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#extendedstateservice","text":"interface ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : StateServiceDelegate T","title":"ExtendedStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#properties","text":"Name Summary criteriaConditionsType abstract var criteriaConditionsType: Class Q The fields of the target StatePersistable type P fields abstract val fields: F The fields of the target StatePersistable type P statePersistableType abstract val statePersistableType: Class P The type of the target state s StatePersistable","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#inherited-properties","text":"Name Summary contractStateType abstract val contractStateType: Class T","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#functions","text":"Name Summary buildQuery abstract fun buildQuery(block: Q .() - Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q queryBy open fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page T Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): Page T open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any toSort open fun toSort(vararg sort: Pair String, Direction ): Sort Build a sort from the given string/direction pairs trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): DataFeed Page T , Update T open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any open fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed Page T , Update T Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates.","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#inherited-functions","text":"Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/#inheritors","text":"Name Summary DefaultExtendedStateService abstract class DefaultExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T , ExtendedStateService T , P , F , Q Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields .","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/build-query/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / buildQuery buildQuery abstract fun buildQuery(block: Q .() - Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q","title":"Build query"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/build-query/#buildquery","text":"abstract fun buildQuery(block: Q .() - Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q","title":"buildQuery"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/criteria-conditions-type/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / criteriaConditionsType criteriaConditionsType abstract var criteriaConditionsType: Class Q The fields of the target StatePersistable type P","title":"Criteria conditions type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/criteria-conditions-type/#criteriaconditionstype","text":"abstract var criteriaConditionsType: Class Q The fields of the target StatePersistable type P","title":"criteriaConditionsType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/fields/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / fields fields abstract val fields: F The fields of the target StatePersistable type P","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/fields/#fields","text":"abstract val fields: F The fields of the target StatePersistable type P","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/query-by/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / queryBy queryBy @Suspendable open fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page T Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag @Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): Page T @Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/query-by/#queryby","text":"@Suspendable open fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page T Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag @Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): Page T @Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/state-persistable-type/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / statePersistableType statePersistableType abstract val statePersistableType: Class P The type of the target state s StatePersistable","title":"State persistable type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/state-persistable-type/#statepersistabletype","text":"abstract val statePersistableType: Class P The type of the target state s StatePersistable","title":"statePersistableType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/to-sort/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / toSort toSort open fun toSort(vararg sort: Pair String, Direction ): Sort Build a sort from the given string/direction pairs","title":"To sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/to-sort/#tosort","text":"open fun toSort(vararg sort: Pair String, Direction ): Sort Build a sort from the given string/direction pairs","title":"toSort"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/track-by/","text":"com.github.manosbatsis.vaultaire.service.dao / ExtendedStateService / trackBy trackBy @Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): DataFeed Page T , Update T @Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any @Suspendable open fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed Page T , Update T Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates.","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-extended-state-service/track-by/#trackby","text":"@Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): DataFeed Page T , Update T @Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any @Suspendable open fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed Page T , Update T Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates.","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / StateCordaServiceDelegate StateCordaServiceDelegate abstract class StateCordaServiceDelegate T : ContractState : NodeCordaServiceDelegate , StateServiceDelegate T Implementation of StateServiceDelegate as a CordaService Constructors Name Summary init StateCordaServiceDelegate(serviceHub: AppServiceHub, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) Implementation of StateServiceDelegate as a CordaService Properties Name Summary contractStateType open val contractStateType: Class T Inherited Properties Name Summary defaults open val defaults: ServiceDefaults Inherited Functions Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/#statecordaservicedelegate","text":"abstract class StateCordaServiceDelegate T : ContractState : NodeCordaServiceDelegate , StateServiceDelegate T Implementation of StateServiceDelegate as a CordaService","title":"StateCordaServiceDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/#constructors","text":"Name Summary init StateCordaServiceDelegate(serviceHub: AppServiceHub, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) Implementation of StateServiceDelegate as a CordaService","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/#properties","text":"Name Summary contractStateType open val contractStateType: Class T","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/#inherited-properties","text":"Name Summary defaults open val defaults: ServiceDefaults","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/#inherited-functions","text":"Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / StateCordaServiceDelegate / init init StateCordaServiceDelegate(serviceHub: AppServiceHub, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) Implementation of StateServiceDelegate as a CordaService","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/-init-/#init","text":"StateCordaServiceDelegate(serviceHub: AppServiceHub, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) Implementation of StateServiceDelegate as a CordaService","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.service.dao / StateCordaServiceDelegate / contractStateType contractStateType open val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-corda-service-delegate/contract-state-type/#contractstatetype","text":"open val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService StateService interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type Parameters T - the ContractState type Properties Name Summary ofLinearState abstract val ofLinearState: Boolean ofQueryableState abstract val ofQueryableState: Boolean Inherited Properties Name Summary contractStateType abstract val contractStateType: Class T Functions Name Summary countBy open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inherited Functions Name Summary countBy abstract fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId abstract fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? abstract fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List UUID = emptyList()): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any Inheritors Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#stateservice","text":"interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type","title":"StateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#properties","text":"Name Summary ofLinearState abstract val ofLinearState: Boolean ofQueryableState abstract val ofQueryableState: Boolean","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#inherited-properties","text":"Name Summary contractStateType abstract val contractStateType: Class T","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#functions","text":"Name Summary countBy open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#inherited-functions","text":"Name Summary countBy abstract fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId abstract fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? abstract fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List UUID = emptyList()): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/#inheritors","text":"Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/count-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / countBy countBy @Suspendable open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria","title":"Count by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/count-by/#countby","text":"@Suspendable open fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria","title":"countBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/find-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / findByExternalId findByExternalId @Suspendable open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"Find by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/find-by-external-id/#findbyexternalid","text":"@Suspendable open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"findByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/find-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / findByLinearId findByLinearId @Suspendable open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any @Suspendable open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? @Suspendable open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any","title":"Find by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/find-by-linear-id/#findbylinearid","text":"@Suspendable open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any @Suspendable open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? @Suspendable open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any","title":"findByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / getByExternalId getByExternalId @Suspendable open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise Exceptions NotFoundException - if no match is found","title":"Get by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-external-id/#getbyexternalid","text":"@Suspendable open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise","title":"getByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-external-id/#exceptions","text":"NotFoundException - if no match is found","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / getByLinearId getByLinearId @Suspendable open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise Exceptions NotFoundException - if no match is found @Suspendable open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T @Suspendable open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise Exceptions NotFoundException - if no match is found","title":"Get by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-linear-id/#getbylinearid","text":"@Suspendable open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise","title":"getByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-linear-id/#exceptions","text":"NotFoundException - if no match is found @Suspendable open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T @Suspendable open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/get-by-linear-id/#exceptions_1","text":"NotFoundException - if no match is found","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/of-linear-state/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / ofLinearState ofLinearState abstract val ofLinearState: Boolean","title":"Of linear state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/of-linear-state/#oflinearstate","text":"abstract val ofLinearState: Boolean","title":"ofLinearState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/of-queryable-state/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / ofQueryableState ofQueryableState abstract val ofQueryableState: Boolean","title":"Of queryable state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/of-queryable-state/#ofqueryablestate","text":"abstract val ofQueryableState: Boolean","title":"ofQueryableState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/query-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / queryBy queryBy @Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/query-by/#queryby","text":"@Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/track-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateService / trackBy trackBy @Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service/track-by/#trackby","text":"@Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceDelegate StateServiceDelegate interface StateServiceDelegate T : ContractState : NodeServiceDelegate StateService delegate for vault operations Properties Name Summary contractStateType abstract val contractStateType: Class T Inherited Properties Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name Functions Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any Inherited Functions Name Summary addresses abstract fun addresses(): List NetworkHostAndPort createStateService abstract fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. flows abstract fun flows(): List String getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getNodeInfo abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. identities abstract fun identities(): List Party isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean nodes abstract fun nodes(): List Party Get a list of nodes in the network, including self and notaries. notaries abstract fun notaries(): List Party openAttachment abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers abstract fun peers(): List Party Returns the node s network peers, excluding self and notaries. platformVersion abstract fun platformVersion(): Int queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault serverTime abstract fun serverTime(): LocalDateTime toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash. wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inheritors Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type ExtendedStateService interface ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : StateServiceDelegate T StateCordaServiceDelegate abstract class StateCordaServiceDelegate T : ContractState : NodeCordaServiceDelegate , StateServiceDelegate T Implementation of StateServiceDelegate as a CordaService StateService interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type StateServiceHubDelegate open class StateServiceHubDelegate T : ContractState : NodeServiceHubDelegate, StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation StateServicePoolBoyDelegate open class StateServicePoolBoyDelegate T : ContractState : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate T StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate T : ContractState : NodeServiceRpcConnectionDelegate, StateServiceDelegate T NodeRpcConnection -based StateServiceDelegate implementation","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#stateservicedelegate","text":"interface StateServiceDelegate T : ContractState : NodeServiceDelegate StateService delegate for vault operations","title":"StateServiceDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#properties","text":"Name Summary contractStateType abstract val contractStateType: Class T","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#inherited-properties","text":"Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#functions","text":"Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#inherited-functions","text":"Name Summary addresses abstract fun addresses(): List NetworkHostAndPort createStateService abstract fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. flows abstract fun flows(): List String getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getNodeInfo abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. identities abstract fun identities(): List Party isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean nodes abstract fun nodes(): List Party Get a list of nodes in the network, including self and notaries. notaries abstract fun notaries(): List Party openAttachment abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers abstract fun peers(): List Party Returns the node s network peers, excluding self and notaries. platformVersion abstract fun platformVersion(): Int queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault serverTime abstract fun serverTime(): LocalDateTime toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash. wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/#inheritors","text":"Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type ExtendedStateService interface ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : StateServiceDelegate T StateCordaServiceDelegate abstract class StateCordaServiceDelegate T : ContractState : NodeCordaServiceDelegate , StateServiceDelegate T Implementation of StateServiceDelegate as a CordaService StateService interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type StateServiceHubDelegate open class StateServiceHubDelegate T : ContractState : NodeServiceHubDelegate, StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation StateServicePoolBoyDelegate open class StateServicePoolBoyDelegate T : ContractState : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate T StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate T : ContractState : NodeServiceRpcConnectionDelegate, StateServiceDelegate T NodeRpcConnection -based StateServiceDelegate implementation","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceDelegate / contractStateType contractStateType abstract val contractStateType: Class T","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/contract-state-type/#contractstatetype","text":"abstract val contractStateType: Class T","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/query-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceDelegate / queryBy queryBy @Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/query-by/#queryby","text":"@Suspendable open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/track-by/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceDelegate / trackBy trackBy @Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-delegate/track-by/#trackby","text":"@Suspendable open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceHubDelegate StateServiceHubDelegate open class StateServiceHubDelegate T : ContractState : NodeServiceHubDelegate, StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation Constructors Name Summary init StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based StateServiceDelegate implementation Properties Name Summary contractStateType open val contractStateType: Class T Inherited Functions Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/#stateservicehubdelegate","text":"open class StateServiceHubDelegate T : ContractState : NodeServiceHubDelegate, StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation","title":"StateServiceHubDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/#constructors","text":"Name Summary init StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based StateServiceDelegate implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/#properties","text":"Name Summary contractStateType open val contractStateType: Class T","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/#inherited-functions","text":"Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceHubDelegate / init init StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based StateServiceDelegate implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/-init-/#init","text":"StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based StateServiceDelegate implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceHubDelegate / contractStateType contractStateType open val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-hub-delegate/contract-state-type/#contractstatetype","text":"open val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServicePoolBoyDelegate StateServicePoolBoyDelegate open class StateServicePoolBoyDelegate T : ContractState : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate T Constructors Name Summary init StateServicePoolBoyDelegate(poolBoy: PoolBoyConnection, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) Properties Name Summary contractStateType open val contractStateType: Class T Inherited Properties Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name poolBoy val poolBoy: PoolBoyConnection Inherited Functions Name Summary addresses open fun addresses(): List NetworkHostAndPort createStateService open fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flows open fun flows(): List String getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List Party nodes open fun nodes(): List Party Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List Party openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List Party Returns the node s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/#stateservicepoolboydelegate","text":"open class StateServicePoolBoyDelegate T : ContractState : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate T","title":"StateServicePoolBoyDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/#constructors","text":"Name Summary init StateServicePoolBoyDelegate(poolBoy: PoolBoyConnection, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults())","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/#properties","text":"Name Summary contractStateType open val contractStateType: Class T","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/#inherited-properties","text":"Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name poolBoy val poolBoy: PoolBoyConnection","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/#inherited-functions","text":"Name Summary addresses open fun addresses(): List NetworkHostAndPort createStateService open fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flows open fun flows(): List String getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List Party nodes open fun nodes(): List Party Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List Party openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List Party Returns the node s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServicePoolBoyDelegate / init init StateServicePoolBoyDelegate(poolBoy: PoolBoyConnection, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults())","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/-init-/#init","text":"StateServicePoolBoyDelegate(poolBoy: PoolBoyConnection, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults())","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServicePoolBoyDelegate / contractStateType contractStateType open val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-pool-boy-delegate/contract-state-type/#contractstatetype","text":"open val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceRpcConnectionDelegate StateServiceRpcConnectionDelegate open class StateServiceRpcConnectionDelegate T : ContractState : NodeServiceRpcConnectionDelegate, StateServiceDelegate T NodeRpcConnection -based StateServiceDelegate implementation Constructors Name Summary init StateServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) NodeRpcConnection -based StateServiceDelegate implementation Properties Name Summary contractStateType open val contractStateType: Class T Inherited Functions Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/#stateservicerpcconnectiondelegate","text":"open class StateServiceRpcConnectionDelegate T : ContractState : NodeServiceRpcConnectionDelegate, StateServiceDelegate T NodeRpcConnection -based StateServiceDelegate implementation","title":"StateServiceRpcConnectionDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/#constructors","text":"Name Summary init StateServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) NodeRpcConnection -based StateServiceDelegate implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/#properties","text":"Name Summary contractStateType open val contractStateType: Class T","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/#inherited-functions","text":"Name Summary queryBy open fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for T states matching the given criteria, applying the given paging and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceRpcConnectionDelegate / init init StateServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) NodeRpcConnection -based StateServiceDelegate implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/-init-/#init","text":"StateServiceRpcConnectionDelegate(nodeRpcConnection: NodeRpcConnection, contractStateType: Class T , defaults: ServiceDefaults = SimpleServiceDefaults()) NodeRpcConnection -based StateServiceDelegate implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.service.dao / StateServiceRpcConnectionDelegate / contractStateType contractStateType open val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.dao/-state-service-rpc-connection-delegate/contract-state-type/#contractstatetype","text":"open val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/","text":"com.github.manosbatsis.vaultaire.service.node Package com.github.manosbatsis.vaultaire.service.node Types Name Summary AbstractNodeServiceHubDelegate abstract class AbstractNodeServiceHubDelegate S : ServiceHub : SingletonSerializeAsToken, NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation NodeCordaServiceDelegate abstract class NodeCordaServiceDelegate : AbstractNodeServiceHubDelegate AppServiceHub Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService NodeService interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type NodeServiceDelegate interface NodeServiceDelegate NodeService delegate for vault operations NodeServiceRpcPoolBoyDelegate open class NodeServiceRpcPoolBoyDelegate : NodeServiceDelegate RPC implementation base Exceptions Name Summary NotFoundException class NotFoundException : RuntimeException","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/#package-comgithubmanosbatsisvaultaireservicenode","text":"","title":"Package com.github.manosbatsis.vaultaire.service.node"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/#types","text":"Name Summary AbstractNodeServiceHubDelegate abstract class AbstractNodeServiceHubDelegate S : ServiceHub : SingletonSerializeAsToken, NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation NodeCordaServiceDelegate abstract class NodeCordaServiceDelegate : AbstractNodeServiceHubDelegate AppServiceHub Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService NodeService interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type NodeServiceDelegate interface NodeServiceDelegate NodeService delegate for vault operations NodeServiceRpcPoolBoyDelegate open class NodeServiceRpcPoolBoyDelegate : NodeServiceDelegate RPC implementation base","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/#exceptions","text":"Name Summary NotFoundException class NotFoundException : RuntimeException","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate AbstractNodeServiceHubDelegate abstract class AbstractNodeServiceHubDelegate S : ServiceHub : SingletonSerializeAsToken, NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation Constructors Name Summary init AbstractNodeServiceHubDelegate(serviceHub: S ) ServiceHub -based NodeServiceDelegate implementation Properties Name Summary nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name serviceHub val serviceHub: S Inherited Properties Name Summary defaults abstract val defaults: ServiceDefaults Functions Name Summary addresses open fun addresses(): List NetworkHostAndPort createStateService open fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flowAwareStartFlow fun T flowAwareStartFlow(flowLogic: FlowLogic T ): CordaFuture T Will start the given flow as a subflow of the current top-level FlowLogic if any, or using the AppServiceHub otherwise. flows open fun flows(): List String getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List Party nodes open fun nodes(): List Party Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List Party openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List Party Returns the node s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inherited Functions Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean openAttachment open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name Inheritors Name Summary NodeCordaServiceDelegate abstract class NodeCordaServiceDelegate : AbstractNodeServiceHubDelegate AppServiceHub Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/#abstractnodeservicehubdelegate","text":"abstract class AbstractNodeServiceHubDelegate S : ServiceHub : SingletonSerializeAsToken, NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation","title":"AbstractNodeServiceHubDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/#constructors","text":"Name Summary init AbstractNodeServiceHubDelegate(serviceHub: S ) ServiceHub -based NodeServiceDelegate implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/#properties","text":"Name Summary nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name serviceHub val serviceHub: S","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/#inherited-properties","text":"Name Summary defaults abstract val defaults: ServiceDefaults","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/#functions","text":"Name Summary addresses open fun addresses(): List NetworkHostAndPort createStateService open fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flowAwareStartFlow fun T flowAwareStartFlow(flowLogic: FlowLogic T ): CordaFuture T Will start the given flow as a subflow of the current top-level FlowLogic if any, or using the AppServiceHub otherwise. flows open fun flows(): List String getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List Party nodes open fun nodes(): List Party Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List Party openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List Party Returns the node s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/#inherited-functions","text":"Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean openAttachment open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/#inheritors","text":"Name Summary NodeCordaServiceDelegate abstract class NodeCordaServiceDelegate : AbstractNodeServiceHubDelegate AppServiceHub Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / init init AbstractNodeServiceHubDelegate(serviceHub: S ) ServiceHub -based NodeServiceDelegate implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/-init-/#init","text":"AbstractNodeServiceHubDelegate(serviceHub: S ) ServiceHub -based NodeServiceDelegate implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/addresses/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / addresses addresses open fun addresses(): List NetworkHostAndPort Overrides NodeServiceDelegate.addresses","title":"Addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/addresses/#addresses","text":"open fun addresses(): List NetworkHostAndPort Overrides NodeServiceDelegate.addresses","title":"addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/create-state-service/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / createStateService createStateService open fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Overrides NodeServiceDelegate.createStateService Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized.","title":"Create state service"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/create-state-service/#createstateservice","text":"open fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Overrides NodeServiceDelegate.createStateService Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized.","title":"createStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/flow-aware-start-flow/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / flowAwareStartFlow flowAwareStartFlow @Suspendable fun T flowAwareStartFlow(flowLogic: FlowLogic T ): CordaFuture T Will start the given flow as a subflow of the current top-level FlowLogic if any, or using the AppServiceHub otherwise.","title":"Flow aware start flow"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/flow-aware-start-flow/#flowawarestartflow","text":"@Suspendable fun T flowAwareStartFlow(flowLogic: FlowLogic T ): CordaFuture T Will start the given flow as a subflow of the current top-level FlowLogic if any, or using the AppServiceHub otherwise.","title":"flowAwareStartFlow"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/flows/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / flows flows open fun flows(): List String Overrides NodeServiceDelegate.flows","title":"Flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/flows/#flows","text":"open fun flows(): List String Overrides NodeServiceDelegate.flows","title":"flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/get-node-info/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / getNodeInfo getNodeInfo open fun getNodeInfo(): NodeInfo Overrides NodeServiceDelegate.getNodeInfo Get information about the node in context as an NodeInfo","title":"Get node info"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/get-node-info/#getnodeinfo","text":"open fun getNodeInfo(): NodeInfo Overrides NodeServiceDelegate.getNodeInfo Get information about the node in context as an NodeInfo","title":"getNodeInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/identities/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / identities identities open fun identities(): List Party Overrides NodeServiceDelegate.identities","title":"Identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/identities/#identities","text":"open fun identities(): List Party Overrides NodeServiceDelegate.identities","title":"identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/node-identity-criteria/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / nodeIdentityCriteria nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria Overrides NodeServiceDelegate.nodeIdentityCriteria","title":"Node identity criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/node-identity-criteria/#nodeidentitycriteria","text":"open val nodeIdentityCriteria: LinearStateQueryCriteria Overrides NodeServiceDelegate.nodeIdentityCriteria","title":"nodeIdentityCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/node-identity/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / nodeIdentity nodeIdentity open val nodeIdentity: Party Overrides NodeServiceDelegate.nodeIdentity","title":"Node identity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/node-identity/#nodeidentity","text":"open val nodeIdentity: Party Overrides NodeServiceDelegate.nodeIdentity","title":"nodeIdentity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/node-legal-name/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / nodeLegalName nodeLegalName open val nodeLegalName: CordaX500Name Overrides NodeServiceDelegate.nodeLegalName","title":"Node legal name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/node-legal-name/#nodelegalname","text":"open val nodeLegalName: CordaX500Name Overrides NodeServiceDelegate.nodeLegalName","title":"nodeLegalName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/nodes/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / nodes nodes open fun nodes(): List Party Overrides NodeServiceDelegate.nodes Get a list of nodes in the network, including self and notaries.","title":"Nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/nodes/#nodes","text":"open fun nodes(): List Party Overrides NodeServiceDelegate.nodes Get a list of nodes in the network, including self and notaries.","title":"nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/notaries/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / notaries notaries open fun notaries(): List Party Overrides NodeServiceDelegate.notaries","title":"Notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/notaries/#notaries","text":"open fun notaries(): List Party Overrides NodeServiceDelegate.notaries","title":"notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/open-attachment/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / openAttachment openAttachment open fun openAttachment(hash: SecureHash): InputStream Overrides NodeServiceDelegate.openAttachment Retrieve the attachment matching the given secure hash from the vault","title":"Open attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/open-attachment/#openattachment","text":"open fun openAttachment(hash: SecureHash): InputStream Overrides NodeServiceDelegate.openAttachment Retrieve the attachment matching the given secure hash from the vault","title":"openAttachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/parties-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / partiesFromName partiesFromName @Suspendable open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Overrides NodeServiceDelegate.partiesFromName Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. Parameters query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parties from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/parties-from-name/#partiesfromname","text":"@Suspendable open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Overrides NodeServiceDelegate.partiesFromName Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted.","title":"partiesFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/parties-from-name/#parameters","text":"query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/peers/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / peers peers open fun peers(): List Party Overrides NodeServiceDelegate.peers Returns the node s network peers, excluding self and notaries.","title":"Peers"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/peers/#peers","text":"open fun peers(): List Party Overrides NodeServiceDelegate.peers Returns the node s network peers, excluding self and notaries.","title":"peers"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/platform-version/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / platformVersion platformVersion open fun platformVersion(): Int Overrides NodeServiceDelegate.platformVersion","title":"Platform version"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/platform-version/#platformversion","text":"open fun platformVersion(): Int Overrides NodeServiceDelegate.platformVersion","title":"platformVersion"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / queryBy queryBy @Suspendable open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Overrides NodeServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/query-by/#queryby","text":"@Suspendable open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Overrides NodeServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/server-time/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / serverTime serverTime open fun serverTime(): LocalDateTime Overrides NodeServiceDelegate.serverTime","title":"Server time"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/server-time/#servertime","text":"open fun serverTime(): LocalDateTime Overrides NodeServiceDelegate.serverTime","title":"serverTime"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/service-hub/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / serviceHub serviceHub val serviceHub: S","title":"Service hub"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/service-hub/#servicehub","text":"val serviceHub: S","title":"serviceHub"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / trackBy trackBy @Suspendable open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Overrides NodeServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/track-by/#trackby","text":"@Suspendable open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Overrides NodeServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/upload-attachment/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / uploadAttachment uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar to the node, returns it s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar including metadata to the node, returns it s hash.","title":"Upload attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/upload-attachment/#uploadattachment","text":"open fun uploadAttachment(inputStream: InputStream): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar to the node, returns it s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar including metadata to the node, returns it s hash.","title":"uploadAttachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/well-known-party-from-x500-name/","text":"com.github.manosbatsis.vaultaire.service.node / AbstractNodeServiceHubDelegate / wellKnownPartyFromX500Name wellKnownPartyFromX500Name @Suspendable open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Overrides NodeServiceDelegate.wellKnownPartyFromX500Name Returns a Party match for the given CordaX500Name if found, null otherwise Parameters name - The name to convert to a party","title":"Well known party from x500 name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/well-known-party-from-x500-name/#wellknownpartyfromx500name","text":"@Suspendable open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Overrides NodeServiceDelegate.wellKnownPartyFromX500Name Returns a Party match for the given CordaX500Name if found, null otherwise","title":"wellKnownPartyFromX500Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-abstract-node-service-hub-delegate/well-known-party-from-x500-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation Constructors Name Summary init BasicNodeService(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicNodeService(serviceHub: ServiceHub, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor, initializes a Corda Service delegate BasicNodeService(delegate: NodeServiceDelegate ) Basic NodeService implementation Properties Name Summary delegate open val delegate: NodeServiceDelegate Functions Name Summary countBy open fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inherited Functions Name Summary findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List UUID = emptyList()): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise Inheritors Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#basicnodeservice","text":"open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation","title":"BasicNodeService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#constructors","text":"Name Summary init BasicNodeService(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicNodeService(serviceHub: ServiceHub, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor, initializes a Corda Service delegate BasicNodeService(delegate: NodeServiceDelegate ) Basic NodeService implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#properties","text":"Name Summary delegate open val delegate: NodeServiceDelegate","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#functions","text":"Name Summary countBy open fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#inherited-functions","text":"Name Summary findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List UUID = emptyList()): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/#inheritors","text":"Name Summary BasicStateService open class BasicStateService T : ContractState : BasicNodeService , StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / init init BasicNodeService(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicNodeService(serviceHub: ServiceHub, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor, initializes a Corda Service delegate BasicNodeService(delegate: NodeServiceDelegate ) Basic NodeService implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/-init-/#init","text":"BasicNodeService(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) PoolBoyConnection -based constructor BasicNodeService(serviceHub: ServiceHub, defaults: ServiceDefaults = SimpleServiceDefaults()) ServiceHub -based constructor, initializes a Corda Service delegate BasicNodeService(delegate: NodeServiceDelegate ) Basic NodeService implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/count-by/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / countBy countBy @Suspendable open fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria): Long Overrides NodeService.countBy Count states of type T matching stored in the vault and matching any given criteria","title":"Count by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/count-by/#countby","text":"@Suspendable open fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria): Long Overrides NodeService.countBy Count states of type T matching stored in the vault and matching any given criteria","title":"countBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/delegate/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / delegate delegate open val delegate: NodeServiceDelegate","title":"Delegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/delegate/#delegate","text":"open val delegate: NodeServiceDelegate","title":"delegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/find-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / findByExternalId findByExternalId @Suspendable open fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Overrides NodeService.findByExternalId Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"Find by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/find-by-external-id/#findbyexternalid","text":"@Suspendable open fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Overrides NodeService.findByExternalId Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"findByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/find-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / findByLinearId findByLinearId @Suspendable open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Overrides NodeService.findByLinearId Find the state of type T matching the given UniqueIdentifier if any","title":"Find by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/find-by-linear-id/#findbylinearid","text":"@Suspendable open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Overrides NodeService.findByLinearId Find the state of type T matching the given UniqueIdentifier if any","title":"findByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / queryBy queryBy @Suspendable open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Overrides NodeService.queryBy Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/query-by/#queryby","text":"@Suspendable open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Overrides NodeService.queryBy Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / BasicNodeService / trackBy trackBy @Suspendable open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Overrides NodeService.trackBy Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-basic-node-service/track-by/#trackby","text":"@Suspendable open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Overrides NodeService.trackBy Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/","text":"com.github.manosbatsis.vaultaire.service.node / NodeCordaServiceDelegate NodeCordaServiceDelegate abstract class NodeCordaServiceDelegate : AbstractNodeServiceHubDelegate AppServiceHub Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService Constructors Name Summary init NodeCordaServiceDelegate(serviceHub: AppServiceHub) Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService Properties Name Summary defaults open val defaults: ServiceDefaults Inherited Properties Name Summary nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name serviceHub val serviceHub: S Inherited Functions Name Summary addresses open fun addresses(): List NetworkHostAndPort createStateService open fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flowAwareStartFlow fun T flowAwareStartFlow(flowLogic: FlowLogic T ): CordaFuture T Will start the given flow as a subflow of the current top-level FlowLogic if any, or using the AppServiceHub otherwise. flows open fun flows(): List String getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List Party nodes open fun nodes(): List Party Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List Party openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List Party Returns the node s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inheritors Name Summary StateCordaServiceDelegate abstract class StateCordaServiceDelegate T : ContractState : NodeCordaServiceDelegate , StateServiceDelegate T Implementation of StateServiceDelegate as a CordaService","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/#nodecordaservicedelegate","text":"abstract class NodeCordaServiceDelegate : AbstractNodeServiceHubDelegate AppServiceHub Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService","title":"NodeCordaServiceDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/#constructors","text":"Name Summary init NodeCordaServiceDelegate(serviceHub: AppServiceHub) Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/#properties","text":"Name Summary defaults open val defaults: ServiceDefaults","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/#inherited-properties","text":"Name Summary nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name serviceHub val serviceHub: S","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/#inherited-functions","text":"Name Summary addresses open fun addresses(): List NetworkHostAndPort createStateService open fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flowAwareStartFlow fun T flowAwareStartFlow(flowLogic: FlowLogic T ): CordaFuture T Will start the given flow as a subflow of the current top-level FlowLogic if any, or using the AppServiceHub otherwise. flows open fun flows(): List String getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List Party nodes open fun nodes(): List Party Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List Party openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List Party Returns the node s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/#inheritors","text":"Name Summary StateCordaServiceDelegate abstract class StateCordaServiceDelegate T : ContractState : NodeCordaServiceDelegate , StateServiceDelegate T Implementation of StateServiceDelegate as a CordaService","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / NodeCordaServiceDelegate / init init NodeCordaServiceDelegate(serviceHub: AppServiceHub) Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/-init-/#init","text":"NodeCordaServiceDelegate(serviceHub: AppServiceHub) Abstract AppServiceHub -based implementation of NodeServiceDelegate as a CordaService","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/defaults/","text":"com.github.manosbatsis.vaultaire.service.node / NodeCordaServiceDelegate / defaults defaults open val defaults: ServiceDefaults Overrides NodeServiceDelegate.defaults","title":"Defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-corda-service-delegate/defaults/#defaults","text":"open val defaults: ServiceDefaults Overrides NodeServiceDelegate.defaults","title":"defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService NodeService interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type Parameters T - the ContractState type Inherited Properties Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name Functions Name Summary countBy abstract fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId abstract fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? abstract fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List UUID = emptyList()): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inherited Functions Name Summary addresses abstract fun addresses(): List NetworkHostAndPort createStateService abstract fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. flows abstract fun flows(): List String getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getNodeInfo abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. identities abstract fun identities(): List Party isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean nodes abstract fun nodes(): List Party Get a list of nodes in the network, including self and notaries. notaries abstract fun notaries(): List Party openAttachment abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers abstract fun peers(): List Party Returns the node s network peers, excluding self and notaries. platformVersion abstract fun platformVersion(): Int queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault serverTime abstract fun serverTime(): LocalDateTime toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash. wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inheritors Name Summary BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation StateService interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#nodeservice","text":"interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type","title":"NodeService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#inherited-properties","text":"Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#functions","text":"Name Summary countBy abstract fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId abstract fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? abstract fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List UUID = emptyList()): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#inherited-functions","text":"Name Summary addresses abstract fun addresses(): List NetworkHostAndPort createStateService abstract fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. flows abstract fun flows(): List String getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getNodeInfo abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. identities abstract fun identities(): List Party isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean nodes abstract fun nodes(): List Party Get a list of nodes in the network, including self and notaries. notaries abstract fun notaries(): List Party openAttachment abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers abstract fun peers(): List Party Returns the node s network peers, excluding self and notaries. platformVersion abstract fun platformVersion(): Int queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault serverTime abstract fun serverTime(): LocalDateTime toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash. wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/#inheritors","text":"Name Summary BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation StateService interface StateService T : ContractState : NodeService , StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/count-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / countBy countBy abstract fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria","title":"Count by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/count-by/#countby","text":"abstract fun T : ContractState countBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria","title":"countBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/find-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / findByExternalId findByExternalId abstract fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"Find by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/find-by-external-id/#findbyexternalid","text":"abstract fun T : ContractState findByExternalId(contractStateType: Class T , externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"findByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/find-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / findByLinearId findByLinearId @Suspendable open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any @Suspendable open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? @Suspendable abstract fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any","title":"Find by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/find-by-linear-id/#findbylinearid","text":"@Suspendable open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any @Suspendable open fun T : ContractState findByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? @Suspendable abstract fun T : ContractState findByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any","title":"findByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-external-id/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / getByExternalId getByExternalId @Suspendable open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise Exceptions NotFoundException - if no match is found","title":"Get by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-external-id/#getbyexternalid","text":"@Suspendable open fun T : ContractState getByExternalId(contractStateType: Class T , externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise","title":"getByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-external-id/#exceptions","text":"NotFoundException - if no match is found","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-linear-id/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / getByLinearId getByLinearId @Suspendable open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List UUID = emptyList()): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise Exceptions NotFoundException - if no match is found @Suspendable open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T @Suspendable open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise Exceptions NotFoundException - if no match is found","title":"Get by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-linear-id/#getbylinearid","text":"@Suspendable open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, externalIds: List UUID = emptyList()): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise","title":"getByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-linear-id/#exceptions","text":"NotFoundException - if no match is found @Suspendable open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T @Suspendable open fun T : ContractState getByLinearId(contractStateType: Class T , linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/get-by-linear-id/#exceptions_1","text":"NotFoundException - if no match is found","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / queryBy queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/query-by/#queryby","text":"abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeService / trackBy trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service/track-by/#trackby","text":"abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate NodeServiceDelegate interface NodeServiceDelegate NodeService delegate for vault operations Properties Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name Functions Name Summary addresses abstract fun addresses(): List NetworkHostAndPort createStateService abstract fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. flows abstract fun flows(): List String getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getNodeInfo abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. identities abstract fun identities(): List Party isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean nodes abstract fun nodes(): List Party Get a list of nodes in the network, including self and notaries. notaries abstract fun notaries(): List Party openAttachment abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers abstract fun peers(): List Party Returns the node s network peers, excluding self and notaries. platformVersion abstract fun platformVersion(): Int queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault serverTime abstract fun serverTime(): LocalDateTime toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash. wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inheritors Name Summary AbstractNodeServiceHubDelegate abstract class AbstractNodeServiceHubDelegate S : ServiceHub : SingletonSerializeAsToken, NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation NodeService interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type NodeServiceRpcPoolBoyDelegate open class NodeServiceRpcPoolBoyDelegate : NodeServiceDelegate RPC implementation base StateServiceDelegate interface StateServiceDelegate T : ContractState : NodeServiceDelegate StateService delegate for vault operations","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/#nodeservicedelegate","text":"interface NodeServiceDelegate NodeService delegate for vault operations","title":"NodeServiceDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/#properties","text":"Name Summary defaults abstract val defaults: ServiceDefaults nodeIdentity abstract val nodeIdentity: Party nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName abstract val nodeLegalName: CordaX500Name","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/#functions","text":"Name Summary addresses abstract fun addresses(): List NetworkHostAndPort createStateService abstract fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. flows abstract fun flows(): List String getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getNodeInfo abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. identities abstract fun identities(): List Party isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean nodes abstract fun nodes(): List Party Get a list of nodes in the network, including self and notaries. notaries abstract fun notaries(): List Party openAttachment abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault partiesFromName abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers abstract fun peers(): List Party Returns the node s network peers, excluding self and notaries. platformVersion abstract fun platformVersion(): Int queryBy abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault serverTime abstract fun serverTime(): LocalDateTime toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name trackBy abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash. wellKnownPartyFromX500Name abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/#inheritors","text":"Name Summary AbstractNodeServiceHubDelegate abstract class AbstractNodeServiceHubDelegate S : ServiceHub : SingletonSerializeAsToken, NodeServiceDelegate ServiceHub -based NodeServiceDelegate implementation BasicNodeService open class BasicNodeService : NodeServiceDelegate , NodeService Basic NodeService implementation NodeService interface NodeService : NodeServiceDelegate Short-lived helper, used for vault operations on a specific ContractState type NodeServiceRpcPoolBoyDelegate open class NodeServiceRpcPoolBoyDelegate : NodeServiceDelegate RPC implementation base StateServiceDelegate interface StateServiceDelegate T : ContractState : NodeServiceDelegate StateService delegate for vault operations","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/addresses/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / addresses addresses abstract fun addresses(): List NetworkHostAndPort","title":"Addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/addresses/#addresses","text":"abstract fun addresses(): List NetworkHostAndPort","title":"addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/create-state-service/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / createStateService createStateService abstract fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized.","title":"Create state service"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/create-state-service/#createstateservice","text":"abstract fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized.","title":"createStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/defaults/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / defaults defaults abstract val defaults: ServiceDefaults","title":"Defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/defaults/#defaults","text":"abstract val defaults: ServiceDefaults","title":"defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/find-party-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / findPartyFromName findPartyFromName @Suspendable open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. Parameters name - The name to convert to a party","title":"Find party from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/find-party-from-name/#findpartyfromname","text":"@Suspendable open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching.","title":"findPartyFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/find-party-from-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/flows/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / flows flows abstract fun flows(): List String","title":"Flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/flows/#flows","text":"abstract fun flows(): List String","title":"flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-extended-info/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / getExtendedInfo getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo","title":"Get extended info"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-extended-info/#getextendedinfo","text":"open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo","title":"getExtendedInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-node-info/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / getNodeInfo getNodeInfo abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo","title":"Get node info"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-node-info/#getnodeinfo","text":"abstract fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo","title":"getNodeInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-party-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / getPartyFromName getPartyFromName @Suspendable open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. Parameters name - The name to convert to a party","title":"Get party from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-party-from-name/#getpartyfromname","text":"@Suspendable open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown.","title":"getPartyFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/get-party-from-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/identities/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / identities identities abstract fun identities(): List Party","title":"Identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/identities/#identities","text":"abstract fun identities(): List Party","title":"identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/is-linear-state/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / isLinearState isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean","title":"Is linear state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/is-linear-state/#islinearstate","text":"open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean","title":"isLinearState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/is-queryable-state/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / isQueryableState isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean","title":"Is queryable state"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/is-queryable-state/#isqueryablestate","text":"open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean","title":"isQueryableState"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-identity-criteria/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / nodeIdentityCriteria nodeIdentityCriteria abstract val nodeIdentityCriteria: LinearStateQueryCriteria","title":"Node identity criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-identity-criteria/#nodeidentitycriteria","text":"abstract val nodeIdentityCriteria: LinearStateQueryCriteria","title":"nodeIdentityCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-identity/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / nodeIdentity nodeIdentity abstract val nodeIdentity: Party","title":"Node identity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-identity/#nodeidentity","text":"abstract val nodeIdentity: Party","title":"nodeIdentity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-legal-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / nodeLegalName nodeLegalName abstract val nodeLegalName: CordaX500Name","title":"Node legal name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/node-legal-name/#nodelegalname","text":"abstract val nodeLegalName: CordaX500Name","title":"nodeLegalName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/nodes/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / nodes nodes abstract fun nodes(): List Party Get a list of nodes in the network, including self and notaries.","title":"Nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/nodes/#nodes","text":"abstract fun nodes(): List Party Get a list of nodes in the network, including self and notaries.","title":"nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/notaries/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / notaries notaries abstract fun notaries(): List Party","title":"Notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/notaries/#notaries","text":"abstract fun notaries(): List Party","title":"notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/open-attachment/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / openAttachment openAttachment abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault","title":"Open attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/open-attachment/#openattachment","text":"abstract fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault","title":"openAttachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/parties-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / partiesFromName partiesFromName @Suspendable abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. Parameters query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parties from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/parties-from-name/#partiesfromname","text":"@Suspendable abstract fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted.","title":"partiesFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/parties-from-name/#parameters","text":"query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/peers/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / peers peers abstract fun peers(): List Party Returns the node s network peers, excluding self and notaries.","title":"Peers"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/peers/#peers","text":"abstract fun peers(): List Party Returns the node s network peers, excluding self and notaries.","title":"peers"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/platform-version/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / platformVersion platformVersion abstract fun platformVersion(): Int","title":"Platform version"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/platform-version/#platformversion","text":"abstract fun platformVersion(): Int","title":"platformVersion"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / queryBy queryBy @Suspendable abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/query-by/#queryby","text":"@Suspendable abstract fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/save-attachment/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / saveAttachment saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault","title":"Save attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/save-attachment/#saveattachment","text":"open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault","title":"saveAttachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/server-time/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / serverTime serverTime abstract fun serverTime(): LocalDateTime","title":"Server time"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/server-time/#servertime","text":"abstract fun serverTime(): LocalDateTime","title":"serverTime"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/to-corda-x500-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / toCordaX500Name toCordaX500Name @Suspendable open fun toCordaX500Name(query: String): CordaX500Name","title":"To corda x500 name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/to-corda-x500-name/#tocordax500name","text":"@Suspendable open fun toCordaX500Name(query: String): CordaX500Name","title":"toCordaX500Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / trackBy trackBy @Suspendable abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/track-by/#trackby","text":"@Suspendable abstract fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/upload-attachment/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / uploadAttachment uploadAttachment abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash.","title":"Upload attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/upload-attachment/#uploadattachment","text":"abstract fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. abstract fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash.","title":"uploadAttachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/well-known-party-from-x500-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceDelegate / wellKnownPartyFromX500Name wellKnownPartyFromX500Name @Suspendable abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Parameters name - The name to convert to a party","title":"Well known party from x500 name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/well-known-party-from-x500-name/#wellknownpartyfromx500name","text":"@Suspendable abstract fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"wellKnownPartyFromX500Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-delegate/well-known-party-from-x500-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate NodeServiceRpcPoolBoyDelegate open class NodeServiceRpcPoolBoyDelegate : NodeServiceDelegate RPC implementation base Constructors Name Summary init NodeServiceRpcPoolBoyDelegate(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) RPC implementation base Properties Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name poolBoy val poolBoy: PoolBoyConnection Functions Name Summary addresses open fun addresses(): List NetworkHostAndPort createStateService open fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flows open fun flows(): List String getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List Party nodes open fun nodes(): List Party Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List Party openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List Party Returns the node s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise Inherited Functions Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean openAttachment open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name Inheritors Name Summary StateServicePoolBoyDelegate open class StateServicePoolBoyDelegate T : ContractState : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate T","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/#nodeservicerpcpoolboydelegate","text":"open class NodeServiceRpcPoolBoyDelegate : NodeServiceDelegate RPC implementation base","title":"NodeServiceRpcPoolBoyDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/#constructors","text":"Name Summary init NodeServiceRpcPoolBoyDelegate(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) RPC implementation base","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/#properties","text":"Name Summary defaults open val defaults: ServiceDefaults nodeIdentity open val nodeIdentity: Party nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria nodeLegalName open val nodeLegalName: CordaX500Name poolBoy val poolBoy: PoolBoyConnection","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/#functions","text":"Name Summary addresses open fun addresses(): List NetworkHostAndPort createStateService open fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized. flows open fun flows(): List String getNodeInfo open fun getNodeInfo(): NodeInfo Get information about the node in context as an NodeInfo identities open fun identities(): List Party nodes open fun nodes(): List Party Get a list of nodes in the network, including self and notaries. notaries open fun notaries(): List Party openAttachment open fun openAttachment(hash: SecureHash): InputStream Retrieve the attachment matching the given secure hash from the vault partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. peers open fun peers(): List Party Returns the node s network peers, excluding self and notaries. platformVersion open fun platformVersion(): Int queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any serverTime open fun serverTime(): LocalDateTime trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Uploads a jar to the node, returns it s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Uploads a jar including metadata to the node, returns it s hash. wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Returns a Party match for the given CordaX500Name if found, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/#inherited-functions","text":"Name Summary findPartyFromName open fun findPartyFromName(query: String): Party? Returns a Party match for the given name string, trying exact and if needed fuzzy matching. getExtendedInfo open fun getExtendedInfo(): ExtendedNodeInfo Get information about the node in context as an ExtendedNodeInfo getPartyFromName open fun getPartyFromName(query: String): Party Returns a Party match for the given name string, trying exact and if needed fuzzy matching. If not exactly one match is found an error will be thrown. isLinearState open fun T : ContractState isLinearState(contractStateType: Class T ): Boolean isQueryableState open fun T : ContractState isQueryableState(contractStateType: Class T ): Boolean openAttachment open fun openAttachment(hash: String): InputStream Retrieve the attachment matching the given hash string from the vault saveAttachment open fun saveAttachment(attachment: Attachment ): AttachmentReceipt Persist the given attachment to the vault toCordaX500Name open fun toCordaX500Name(query: String): CordaX500Name","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/#inheritors","text":"Name Summary StateServicePoolBoyDelegate open class StateServicePoolBoyDelegate T : ContractState : NodeServiceRpcPoolBoyDelegate , StateServiceDelegate T","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / init init NodeServiceRpcPoolBoyDelegate(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) RPC implementation base","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/-init-/#init","text":"NodeServiceRpcPoolBoyDelegate(poolBoy: PoolBoyConnection, defaults: ServiceDefaults = SimpleServiceDefaults()) RPC implementation base","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/addresses/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / addresses addresses open fun addresses(): List NetworkHostAndPort Overrides NodeServiceDelegate.addresses","title":"Addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/addresses/#addresses","text":"open fun addresses(): List NetworkHostAndPort Overrides NodeServiceDelegate.addresses","title":"addresses"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/create-state-service/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / createStateService createStateService open fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Overrides NodeServiceDelegate.createStateService Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized.","title":"Create state service"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/create-state-service/#createstateservice","text":"open fun T : ContractState, S : StateService T createStateService(contractStateType: Class T ): S Overrides NodeServiceDelegate.createStateService Get a state service targeting the given ContractState type. Default implementations assume a Registry has been properly initialized.","title":"createStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/defaults/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / defaults defaults open val defaults: ServiceDefaults Overrides NodeServiceDelegate.defaults","title":"Defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/defaults/#defaults","text":"open val defaults: ServiceDefaults Overrides NodeServiceDelegate.defaults","title":"defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/flows/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / flows flows open fun flows(): List String Overrides NodeServiceDelegate.flows","title":"Flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/flows/#flows","text":"open fun flows(): List String Overrides NodeServiceDelegate.flows","title":"flows"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/get-node-info/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / getNodeInfo getNodeInfo open fun getNodeInfo(): NodeInfo Overrides NodeServiceDelegate.getNodeInfo Get information about the node in context as an NodeInfo","title":"Get node info"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/get-node-info/#getnodeinfo","text":"open fun getNodeInfo(): NodeInfo Overrides NodeServiceDelegate.getNodeInfo Get information about the node in context as an NodeInfo","title":"getNodeInfo"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/identities/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / identities identities open fun identities(): List Party Overrides NodeServiceDelegate.identities","title":"Identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/identities/#identities","text":"open fun identities(): List Party Overrides NodeServiceDelegate.identities","title":"identities"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/node-identity-criteria/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / nodeIdentityCriteria nodeIdentityCriteria open val nodeIdentityCriteria: LinearStateQueryCriteria Overrides NodeServiceDelegate.nodeIdentityCriteria","title":"Node identity criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/node-identity-criteria/#nodeidentitycriteria","text":"open val nodeIdentityCriteria: LinearStateQueryCriteria Overrides NodeServiceDelegate.nodeIdentityCriteria","title":"nodeIdentityCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/node-identity/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / nodeIdentity nodeIdentity open val nodeIdentity: Party Overrides NodeServiceDelegate.nodeIdentity","title":"Node identity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/node-identity/#nodeidentity","text":"open val nodeIdentity: Party Overrides NodeServiceDelegate.nodeIdentity","title":"nodeIdentity"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/node-legal-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / nodeLegalName nodeLegalName open val nodeLegalName: CordaX500Name Overrides NodeServiceDelegate.nodeLegalName","title":"Node legal name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/node-legal-name/#nodelegalname","text":"open val nodeLegalName: CordaX500Name Overrides NodeServiceDelegate.nodeLegalName","title":"nodeLegalName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/nodes/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / nodes nodes open fun nodes(): List Party Overrides NodeServiceDelegate.nodes Get a list of nodes in the network, including self and notaries.","title":"Nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/nodes/#nodes","text":"open fun nodes(): List Party Overrides NodeServiceDelegate.nodes Get a list of nodes in the network, including self and notaries.","title":"nodes"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/notaries/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / notaries notaries open fun notaries(): List Party Overrides NodeServiceDelegate.notaries","title":"Notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/notaries/#notaries","text":"open fun notaries(): List Party Overrides NodeServiceDelegate.notaries","title":"notaries"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/open-attachment/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / openAttachment openAttachment open fun openAttachment(hash: SecureHash): InputStream Overrides NodeServiceDelegate.openAttachment Retrieve the attachment matching the given secure hash from the vault","title":"Open attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/open-attachment/#openattachment","text":"open fun openAttachment(hash: SecureHash): InputStream Overrides NodeServiceDelegate.openAttachment Retrieve the attachment matching the given secure hash from the vault","title":"openAttachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/parties-from-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / partiesFromName partiesFromName open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Overrides NodeServiceDelegate.partiesFromName Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted. Parameters query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parties from name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/parties-from-name/#partiesfromname","text":"open fun partiesFromName(query: String, exactMatch: Boolean): Set Party Overrides NodeServiceDelegate.partiesFromName Returns a list of candidate matches for a given string, with optional fuzzy(ish) matching. Fuzzy matching may get smarter with time e.g. to correct spelling errors, so you should not hard-code indexes into the results but rather show them via a user interface and let the user pick the one they wanted.","title":"partiesFromName"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/parties-from-name/#parameters","text":"query - The string to check against the X.500 name components exactMatch - If true, a case sensitive match is done against each component of each X.500 name.","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/peers/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / peers peers open fun peers(): List Party Overrides NodeServiceDelegate.peers Returns the node s network peers, excluding self and notaries.","title":"Peers"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/peers/#peers","text":"open fun peers(): List Party Overrides NodeServiceDelegate.peers Returns the node s network peers, excluding self and notaries.","title":"peers"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/platform-version/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / platformVersion platformVersion open fun platformVersion(): Int Overrides NodeServiceDelegate.platformVersion","title":"Platform version"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/platform-version/#platformversion","text":"open fun platformVersion(): Int Overrides NodeServiceDelegate.platformVersion","title":"platformVersion"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/pool-boy/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / poolBoy poolBoy val poolBoy: PoolBoyConnection","title":"Pool boy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/pool-boy/#poolboy","text":"val poolBoy: PoolBoyConnection","title":"poolBoy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/query-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / queryBy queryBy open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Overrides NodeServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/query-by/#queryby","text":"open fun T : ContractState queryBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Overrides NodeServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/server-time/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / serverTime serverTime open fun serverTime(): LocalDateTime Overrides NodeServiceDelegate.serverTime","title":"Server time"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/server-time/#servertime","text":"open fun serverTime(): LocalDateTime Overrides NodeServiceDelegate.serverTime","title":"serverTime"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/track-by/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / trackBy trackBy open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Overrides NodeServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/track-by/#trackby","text":"open fun T : ContractState trackBy(contractStateType: Class T , criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Overrides NodeServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/upload-attachment/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / uploadAttachment uploadAttachment open fun uploadAttachment(inputStream: InputStream): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar to the node, returns it s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar including metadata to the node, returns it s hash.","title":"Upload attachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/upload-attachment/#uploadattachment","text":"open fun uploadAttachment(inputStream: InputStream): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar to the node, returns it s hash. open fun uploadAttachment(inputStream: InputStream, uploader: String, filename: String): SecureHash Overrides NodeServiceDelegate.uploadAttachment Uploads a jar including metadata to the node, returns it s hash.","title":"uploadAttachment"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/well-known-party-from-x500-name/","text":"com.github.manosbatsis.vaultaire.service.node / NodeServiceRpcPoolBoyDelegate / wellKnownPartyFromX500Name wellKnownPartyFromX500Name open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Overrides NodeServiceDelegate.wellKnownPartyFromX500Name Returns a Party match for the given CordaX500Name if found, null otherwise Parameters name - The name to convert to a party","title":"Well known party from x500 name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/well-known-party-from-x500-name/#wellknownpartyfromx500name","text":"open fun wellKnownPartyFromX500Name(name: CordaX500Name): Party? Overrides NodeServiceDelegate.wellKnownPartyFromX500Name Returns a Party match for the given CordaX500Name if found, null otherwise","title":"wellKnownPartyFromX500Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-node-service-rpc-pool-boy-delegate/well-known-party-from-x500-name/#parameters","text":"name - The name to convert to a party","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-not-found-exception/","text":"com.github.manosbatsis.vaultaire.service.node / NotFoundException NotFoundException class NotFoundException : RuntimeException Constructors Name Summary init NotFoundException(id: String, stateType: Class * )","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-not-found-exception/#notfoundexception","text":"class NotFoundException : RuntimeException","title":"NotFoundException"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-not-found-exception/#constructors","text":"Name Summary init NotFoundException(id: String, stateType: Class * )","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-not-found-exception/-init-/","text":"com.github.manosbatsis.vaultaire.service.node / NotFoundException / init init NotFoundException(id: String, stateType: Class * )","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.service.node/-not-found-exception/-init-/#init","text":"NotFoundException(id: String, stateType: Class * )","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/","text":"com.github.manosbatsis.vaultaire.util Package com.github.manosbatsis.vaultaire.util Types Name Summary Fields interface Fields T Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type FieldWrapper interface FieldWrapper T GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Extensions for External Classes Name Summary kotlin.String","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/#package-comgithubmanosbatsisvaultaireutil","text":"","title":"Package com.github.manosbatsis.vaultaire.util"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/#types","text":"Name Summary Fields interface Fields T Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type FieldWrapper interface FieldWrapper T GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/#extensions-for-external-classes","text":"Name Summary kotlin.String","title":"Extensions for External Classes"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / FieldWrapper FieldWrapper interface FieldWrapper T Properties Name Summary property abstract val property: KProperty1 T , * Inheritors Name Summary TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/#fieldwrapper","text":"interface FieldWrapper T","title":"FieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/#properties","text":"Name Summary property abstract val property: KProperty1 T , *","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/#inheritors","text":"Name Summary TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / FieldWrapper / property property abstract val property: KProperty1 T , *","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/property/#property","text":"abstract val property: KProperty1 T , *","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/","text":"com.github.manosbatsis.vaultaire.util / Fields Fields interface Fields T Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type Properties Name Summary fieldsByName abstract val fieldsByName: Map String, FieldWrapper T Functions Name Summary contains open fun contains(name: String): Boolean get open operator fun get(name: String): FieldWrapper T","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/#fields","text":"interface Fields T Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/#properties","text":"Name Summary fieldsByName abstract val fieldsByName: Map String, FieldWrapper T","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/#functions","text":"Name Summary contains open fun contains(name: String): Boolean get open operator fun get(name: String): FieldWrapper T","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/contains/","text":"com.github.manosbatsis.vaultaire.util / Fields / contains contains open fun contains(name: String): Boolean","title":"Contains"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/contains/#contains","text":"open fun contains(name: String): Boolean","title":"contains"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/fields-by-name/","text":"com.github.manosbatsis.vaultaire.util / Fields / fieldsByName fieldsByName abstract val fieldsByName: Map String, FieldWrapper T","title":"Fields by name"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/fields-by-name/#fieldsbyname","text":"abstract val fieldsByName: Map String, FieldWrapper T","title":"fieldsByName"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/get/","text":"com.github.manosbatsis.vaultaire.util / Fields / get get open operator fun get(name: String): FieldWrapper T","title":"Get"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/get/#get","text":"open operator fun get(name: String): FieldWrapper T","title":"get"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / GenericFieldWrapper GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Constructors Name Summary init GenericFieldWrapper(property: KProperty1 T , S ) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Properties Name Summary property val property: KProperty1 T , S","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/#genericfieldwrapper","text":"class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"GenericFieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/#constructors","text":"Name Summary init GenericFieldWrapper(property: KProperty1 T , S ) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/#properties","text":"Name Summary property val property: KProperty1 T , S","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/-init-/","text":"com.github.manosbatsis.vaultaire.util / GenericFieldWrapper / init init GenericFieldWrapper(property: KProperty1 T , S ) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/-init-/#init","text":"GenericFieldWrapper(property: KProperty1 T , S ) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / GenericFieldWrapper / property property val property: KProperty1 T , S Overrides TypedFieldWrapper.property","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/property/#property","text":"val property: KProperty1 T , S Overrides TypedFieldWrapper.property","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / NullableGenericFieldWrapper NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Constructors Name Summary init NullableGenericFieldWrapper(property: KProperty1 T , S ? ) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Properties Name Summary property val property: KProperty1 T , S ?","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/#nullablegenericfieldwrapper","text":"class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"NullableGenericFieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/#constructors","text":"Name Summary init NullableGenericFieldWrapper(property: KProperty1 T , S ? ) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/#properties","text":"Name Summary property val property: KProperty1 T , S ?","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/-init-/","text":"com.github.manosbatsis.vaultaire.util / NullableGenericFieldWrapper / init init NullableGenericFieldWrapper(property: KProperty1 T , S ? ) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/-init-/#init","text":"NullableGenericFieldWrapper(property: KProperty1 T , S ? ) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / NullableGenericFieldWrapper / property property val property: KProperty1 T , S ? Overrides TypedFieldWrapper.property","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/property/#property","text":"val property: KProperty1 T , S ? Overrides TypedFieldWrapper.property","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / TypedFieldWrapper TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Properties Name Summary property abstract val property: KProperty1 T , S Inheritors Name Summary GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/#typedfieldwrapper","text":"interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"TypedFieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/#properties","text":"Name Summary property abstract val property: KProperty1 T , S","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/#inheritors","text":"Name Summary GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / TypedFieldWrapper / property property abstract val property: KProperty1 T , S Overrides FieldWrapper.property","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/property/#property","text":"abstract val property: KProperty1 T , S Overrides FieldWrapper.property","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/","text":"com.github.manosbatsis.vaultaire.util / kotlin.String Extensions for kotlin.String Name Summary asUniqueIdentifier fun String.asUniqueIdentifier(): UniqueIdentifier","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/#extensions-for-kotlinstring","text":"Name Summary asUniqueIdentifier fun String.asUniqueIdentifier(): UniqueIdentifier","title":"Extensions for kotlin.String"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/as-unique-identifier/","text":"com.github.manosbatsis.vaultaire.util / kotlin.String / asUniqueIdentifier asUniqueIdentifier fun String.asUniqueIdentifier(): UniqueIdentifier","title":"As unique identifier"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/as-unique-identifier/#asuniqueidentifier","text":"fun String.asUniqueIdentifier(): UniqueIdentifier","title":"asUniqueIdentifier"},{"location":"core/other-utils/","text":"Other Utilities Miscellaneous utilities provides by Vaultaire Generated Responders Some times you might want to use the same responding flow with multiple initiating flows. Since @InitiatedBy is not a repeatable annotation, the only option would be to subclass the same responder for each initiating flow, adding the appropriate @InitiatedBy . Vaultaire s annotation processor can help you automate this using a @VaultaireGenerateResponder instead of maintaning such responders manually. Usage example: // or simply: @VaultaireGenerateResponder(BaseBookFlowResponder::class) @VaultaireGenerateResponder ( value = BaseBookFlowResponder :: class , comment = A basic responder to listen for finality ) @InitiatingFlow @StartableByRPC class CreateBookFlow ( input : BookMessage ) : FlowLogic SignedTransaction The above will automatically generate a responder flow: /** * A basic responder to listen for finality */ @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( otherPartySession : FlowSession ) : BaseBookFlowResponder ( otherPartySession ) Note : if the base responder flow is a final type, the generated responder will attempt to call it as a subflow instead of extending it: @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( val otherPartySession : FlowSession ) : FlowLogic Unit () { @Suspendable override fun call () { subFlow ( BaseBookFlowResponder ( otherPartySession )) } } ... or `@VaultaireGenerateDtoForDependency` when targetting a contract state within your dependencies e.g. from your contract states module or a third party class: ```kotlin @VaultaireGenerateDtoForDependency( persistentStateType = PersistentBookState::class, contractStateType = BookState::class, // optional: properties to ignore ignoreProperties = [ foo ] ) class Dummy // just a placeholder for our annotation In both cases the following DTO will be generated, along with proper implementations of [Dto] s mapping/patching utility methods: /** * A [BookState]-specific [Dto] implementation */ @CordaSerializable data class BookStateDto ( var publisher : Party ? = null , var author : Party ? = null , var price : BigDecimal ? = null , var genre : BookContract . Genre ? = null , var editions : Int ? = 1 , var title : String ? = null , var published : Date ? = null , @field : JsonProperty ( value = alias ) var alternativeTitle : String ? = null , var linearId : UniqueIdentifier ? = null ) : Dto BookState { /** * Alternative constructor, used to map * from the given [BookState] instance. */ constructor ( original : BookState ) : this ( publisher = original . publisher , author = original . author , price = original . price , genre = original . genre , editions = original . editions , title = original . title , published = original . published , alternativeTitle = original . alternativeTitle , linearId = original . linearId ) /** * Create a patched copy of the given [BookState] instance, * updated using this DTO s non-null properties. */ override fun toPatched ( original : BookState ): BookState { val patched = BookState ( publisher = this . publisher ?: original . publisher , author = this . author ?: original . author , price = this . price ?: original . price , genre = this . genre ?: original . genre , editions = this . editions ?: original . editions , title = this . title ?: original . title , published = this . published ?: original . published , alternativeTitle = this . alternativeTitle ?: original . alternativeTitle , linearId = this . linearId ?: original . linearId ) return patched } /** * Create an instance of [BookState], using this DTO s properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ override fun toState (): BookState { try { val state = BookState ( publisher = this . publisher !! , author = this . author !! , price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return state } catch ( e : Exception ) { throw DtoInsufficientStateMappingException ( exception = e ) } } } DTO Strategies Both @VaultaireGenerateDto and @VaultaireGenerateDtoForDependency support generation strategies. By default the strategy used is VaultaireDtoStrategyKeys.DEFAULT . @VaultaireGenerateDto ( // optional: properties to ignore ignoreProperties = [ foo ], // Default is [VaultaireDtoStrategyKeys.DEFAULT] strategies = [ VaultaireDtoStrategyKeys . DEFAULT , VaultaireDtoStrategyKeys . LITE ]) ) data class BookState ( val publisher : Party , val author : Party , val price : BigDecimal , val genre : Genre , @DefaultValue ( 1 ) val editions : Int = 1 , val title : String = Uknown , val published : Date = Date (), @field : JsonProperty ( alias ) val alternativeTitle : String ? = null , override val linearId : UniqueIdentifier = UniqueIdentifier ()) : LinearState , QueryableState { //... } The lite strategy is provided to help where deserialization would normally require either a ServiceHub or RpcOps , e.g. when the target property is a Party , in which case the DTO will use a more accessible type like CordaX500Name , and require a service to convert to or patch a ContractState instance. Note that lite DTO classname also have a LiteDto suffix. Here s the lite DTO generated for the above example: /** * A [BookContract.BookState]-specific [com.github.manotbatsis.kotlin.utils.api.Dto] implementation */ data class BookStateLiteDto ( var publisher : CordaX500Name ? = null , var author : CordaX500Name ? = null , var price : BigDecimal ? = null , var genre : BookContract . Genre ? = null , var editions : Int ? = 1 , var title : String ? = null , var published : Date ? = null , @field : JsonProperty ( value = alias ) var alternativeTitle : String ? = null , var linearId : UniqueIdentifier ? = null ) : VaultaireDto BookContract . BookState { /** * Alternative constructor, used to map * from the given [BookContract.BookState] instance. */ constructor ( original : BookContract . BookState ) : this ( publisher = original . publisher . name , author = original . author . name , price = original . price , genre = original . genre , editions = original . editions , title = original . title , published = original . published , alternativeTitle = original . alternativeTitle , linearId = original . linearId ) /** * Create a patched copy of the given [BookContract.BookState] instance, * updated using this DTO s non-null properties. */ override fun toPatched ( original : BookContract . BookState , stateService : StateService BookContract . BookState ): BookContract . BookState { val patched = BookContract . BookState ( publisher = if ( this . publisher != null ) stateService . wellKnownPartyFromX500Name ( this . publisher !! ) !! else original . publisher !! , author = if ( this . author != null ) stateService . wellKnownPartyFromX500Name ( this . author !! ) !! else original . author !! , price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return patched } /** * Create an instance of [BookContract.BookState], using this DTO s properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ override fun toTargetType ( stateService : StateService BookContract . BookState ): BookContract . BookState { try { val originalTypeInstance = BookContract . BookState ( publisher = if ( this . publisher != null ) stateService . wellKnownPartyFromX500Name ( this . publisher !! ) !! else throw DtoInsufficientMappingException ( No value given for property publisher ), author = if ( this . author != null ) stateService . wellKnownPartyFromX500Name ( this . author !! ) !! else throw DtoInsufficientMappingException ( No value given for property author ), price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return originalTypeInstance } catch ( e : Exception ) { throw DtoInsufficientMappingException ( exception = e ) } } }","title":"Other Utilities"},{"location":"core/other-utils/#other-utilities","text":"Miscellaneous utilities provides by Vaultaire","title":"Other Utilities"},{"location":"core/other-utils/#generated-responders","text":"Some times you might want to use the same responding flow with multiple initiating flows. Since @InitiatedBy is not a repeatable annotation, the only option would be to subclass the same responder for each initiating flow, adding the appropriate @InitiatedBy . Vaultaire s annotation processor can help you automate this using a @VaultaireGenerateResponder instead of maintaning such responders manually. Usage example: // or simply: @VaultaireGenerateResponder(BaseBookFlowResponder::class) @VaultaireGenerateResponder ( value = BaseBookFlowResponder :: class , comment = A basic responder to listen for finality ) @InitiatingFlow @StartableByRPC class CreateBookFlow ( input : BookMessage ) : FlowLogic SignedTransaction The above will automatically generate a responder flow: /** * A basic responder to listen for finality */ @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( otherPartySession : FlowSession ) : BaseBookFlowResponder ( otherPartySession ) Note : if the base responder flow is a final type, the generated responder will attempt to call it as a subflow instead of extending it: @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( val otherPartySession : FlowSession ) : FlowLogic Unit () { @Suspendable override fun call () { subFlow ( BaseBookFlowResponder ( otherPartySession )) } } ... or `@VaultaireGenerateDtoForDependency` when targetting a contract state within your dependencies e.g. from your contract states module or a third party class: ```kotlin @VaultaireGenerateDtoForDependency( persistentStateType = PersistentBookState::class, contractStateType = BookState::class, // optional: properties to ignore ignoreProperties = [ foo ] ) class Dummy // just a placeholder for our annotation In both cases the following DTO will be generated, along with proper implementations of [Dto] s mapping/patching utility methods: /** * A [BookState]-specific [Dto] implementation */ @CordaSerializable data class BookStateDto ( var publisher : Party ? = null , var author : Party ? = null , var price : BigDecimal ? = null , var genre : BookContract . Genre ? = null , var editions : Int ? = 1 , var title : String ? = null , var published : Date ? = null , @field : JsonProperty ( value = alias ) var alternativeTitle : String ? = null , var linearId : UniqueIdentifier ? = null ) : Dto BookState { /** * Alternative constructor, used to map * from the given [BookState] instance. */ constructor ( original : BookState ) : this ( publisher = original . publisher , author = original . author , price = original . price , genre = original . genre , editions = original . editions , title = original . title , published = original . published , alternativeTitle = original . alternativeTitle , linearId = original . linearId ) /** * Create a patched copy of the given [BookState] instance, * updated using this DTO s non-null properties. */ override fun toPatched ( original : BookState ): BookState { val patched = BookState ( publisher = this . publisher ?: original . publisher , author = this . author ?: original . author , price = this . price ?: original . price , genre = this . genre ?: original . genre , editions = this . editions ?: original . editions , title = this . title ?: original . title , published = this . published ?: original . published , alternativeTitle = this . alternativeTitle ?: original . alternativeTitle , linearId = this . linearId ?: original . linearId ) return patched } /** * Create an instance of [BookState], using this DTO s properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ override fun toState (): BookState { try { val state = BookState ( publisher = this . publisher !! , author = this . author !! , price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return state } catch ( e : Exception ) { throw DtoInsufficientStateMappingException ( exception = e ) } } }","title":"Generated Responders"},{"location":"core/other-utils/#dto-strategies","text":"Both @VaultaireGenerateDto and @VaultaireGenerateDtoForDependency support generation strategies. By default the strategy used is VaultaireDtoStrategyKeys.DEFAULT . @VaultaireGenerateDto ( // optional: properties to ignore ignoreProperties = [ foo ], // Default is [VaultaireDtoStrategyKeys.DEFAULT] strategies = [ VaultaireDtoStrategyKeys . DEFAULT , VaultaireDtoStrategyKeys . LITE ]) ) data class BookState ( val publisher : Party , val author : Party , val price : BigDecimal , val genre : Genre , @DefaultValue ( 1 ) val editions : Int = 1 , val title : String = Uknown , val published : Date = Date (), @field : JsonProperty ( alias ) val alternativeTitle : String ? = null , override val linearId : UniqueIdentifier = UniqueIdentifier ()) : LinearState , QueryableState { //... } The lite strategy is provided to help where deserialization would normally require either a ServiceHub or RpcOps , e.g. when the target property is a Party , in which case the DTO will use a more accessible type like CordaX500Name , and require a service to convert to or patch a ContractState instance. Note that lite DTO classname also have a LiteDto suffix. Here s the lite DTO generated for the above example: /** * A [BookContract.BookState]-specific [com.github.manotbatsis.kotlin.utils.api.Dto] implementation */ data class BookStateLiteDto ( var publisher : CordaX500Name ? = null , var author : CordaX500Name ? = null , var price : BigDecimal ? = null , var genre : BookContract . Genre ? = null , var editions : Int ? = 1 , var title : String ? = null , var published : Date ? = null , @field : JsonProperty ( value = alias ) var alternativeTitle : String ? = null , var linearId : UniqueIdentifier ? = null ) : VaultaireDto BookContract . BookState { /** * Alternative constructor, used to map * from the given [BookContract.BookState] instance. */ constructor ( original : BookContract . BookState ) : this ( publisher = original . publisher . name , author = original . author . name , price = original . price , genre = original . genre , editions = original . editions , title = original . title , published = original . published , alternativeTitle = original . alternativeTitle , linearId = original . linearId ) /** * Create a patched copy of the given [BookContract.BookState] instance, * updated using this DTO s non-null properties. */ override fun toPatched ( original : BookContract . BookState , stateService : StateService BookContract . BookState ): BookContract . BookState { val patched = BookContract . BookState ( publisher = if ( this . publisher != null ) stateService . wellKnownPartyFromX500Name ( this . publisher !! ) !! else original . publisher !! , author = if ( this . author != null ) stateService . wellKnownPartyFromX500Name ( this . author !! ) !! else original . author !! , price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return patched } /** * Create an instance of [BookContract.BookState], using this DTO s properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ override fun toTargetType ( stateService : StateService BookContract . BookState ): BookContract . BookState { try { val originalTypeInstance = BookContract . BookState ( publisher = if ( this . publisher != null ) stateService . wellKnownPartyFromX500Name ( this . publisher !! ) !! else throw DtoInsufficientMappingException ( No value given for property publisher ), author = if ( this . author != null ) stateService . wellKnownPartyFromX500Name ( this . author !! ) !! else throw DtoInsufficientMappingException ( No value given for property author ), price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return originalTypeInstance } catch ( e : Exception ) { throw DtoInsufficientMappingException ( exception = e ) } } }","title":"DTO Strategies"},{"location":"core/query-dsl/","text":"Query DSL Vaultaire uses an annotation processor at build-time to create a query DSL for your contract/persistent states. Quick Example Consider the following Contract/Persistent States: /** Book ContractState */ data class BookState ( val publisher : Party , val author : Party , val title : String , val published : Date = Date () ) : ContractState , QueryableState { // ... } // Use Vaultaire s code generation! @VaultaireGenerate ( name = booksQuery , contractStateType = BookState :: class ) @Entity @Table ( name = books ) data class PersistentBookState ( @Column ( name = publisher ) var publisher : String = , @Column ( name = author ) var author : String = , @Column ( name = title ) var title : String = , @Column ( name = published ) var published : Date ) : PersistentState () Before Vaultaire Before Vaultaire, you probably had to create query criteria with something like: val query = VaultQueryCriteria ( contractStateTypes = setOf ( BookState :: class . java ), status = Vault . StateStatus . ALL ) // Check publisher? if ( checkPublisher ) query = query . and ( VaultCustomQueryCriteria ( PersistentBookState :: publisher . equal ( Corda Books Ltd. ))) // Add more criteria query . and ( VaultCustomQueryCriteria ( PersistentBookState :: title . equal ( A book on Corda )) . or ( VaultCustomQueryCriteria ( PersistentBookState :: author . notEqual ( John Doe )))) val sort = Sort ( listOf ( Sort . SortColumn ( SortAttribute . Custom ( PersistentBookState :: class . java , published ), Sort . Direction . DESC ))) // Finally! queryBy ( query , sort ) A bit verbose so get s difficult to read as the query becomes more complex. Let s try to simplify things bellow. With Vaultaire DSL With Vaultaire s @VaultaireGenerate and the generated DSL this becomes: // Use the generated DSL to create query criteria val query = booksQuery { status = Vault . StateStatus . ALL and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` Corda Books Ltd. or { fields . title ` == ` A book on Corda fields . author ` != ` John Doe } } orderBy { fields . title sort DESC } }. toCriteria () queryBy ( query . toCriteria (), query . toSort ()) Create a DSL Project Module States To create a query DSL for your state after installing Vaultaire, annotate the corresponding PersistentState with @VaultaireGenerate : // Use Vaultaire s DSL generation! @VaultaireGenerate ( // If you omit the name, the DSL function will be named by appending Query // to the decapitalized contract state name, e.g. bookStateQuery name = booksQuery , contractStateType = BookState :: class ) @Entity @Table ( name = books ) data class PersistentBookState ( // state properties... ) : PersistentState () Project Dependency States To create a query DSL for a state from your project dependencies, annotate the any class in your project using the special @VaultaireGenerateFor annotation, providing the state s ContractState and PersistentState : @VaultaireGenerateForDependency ( name = fungibleTokenConditions , persistentStateType = PersistentFungibleToken :: class , contractStateType = FungibleToken :: class ) class Fungible Query Settings The generated DSL allows setting QueryCriteria.VaultQueryCriteria members. Here s an example using the defaults: val query = booksQuery { // settings status = Vault . StateStatus . UNCONSUMED stateRefs = null notary = null softLockingCondition = null timeCondition = null relevancyStatus = Vault . RelevancyStatus . ALL constraintTypes = emptySet () constraints = emptySet () participants = null // criteria and sorting... } Adding Criteria Query riteria are defined within the and / or functions. Both functions can be nested and mixed with criteria like: val query = booksQuery { // settings... // criteria or { // Match at least one fields . foo1 ` == ` someValue and { // Match all fields . foo1 . isNull () fields . foo2 ` == ` someOtherValue and { // ... } or { // ... } } } // sorting... } Adding Aggregates Aggregates can be specified within the and / or functions: val bookStateQuery = bookStateQuery { // settings... // criteria and { fields . title `like` %Corda Foundation% fields . genre ` == ` BookContract . BookGenre . SCIENCE_FICTION } // aggregates aggregate { // add some aggregates fields . externalId . count () fields . id . count () fields . editions . sum () fields . price . min () fields . price . avg () fields . price . max () } } Note : Corda paged queries can include either query results or other results based on the above aggregates. For that purpose, the toCriteria functions accepts an optional boolean to ignore aggregates, thus allowing the reuse of the same query to obtain either paged state or aggregate results. Accessing Fields Fields can be accessed via the generated DSL s fields object within and , or , or orderBy functions using dot notation e.g. fields.foo . You can also retrieve fields by name with e.g. fields[\"foo\"] or fields.get(\"foo\") and use non typesafe functions like _equal , _notEqual , _like , _notLike but this may change in a future release. Functions and Operators Name Aliases Examples isNull fields.foo.isNull() notNull fields.foo.notNull() equal `==` fields.foo `==` bar fields.foo equal bar fields.foo.equal(bar) notEqual `!=` fields.foo `!=` bar fields.foo notEqual bar fields.foo.notEqual(bar) lessThan lt fields.foo lt bar fields.foo lessThan bar fields.foo.lessThan(bar) lessThanOrEqual lte fields.foo lte bar fields.foo lessThanOrEqual bar fields.foo.lessThanOrEqual(bar) greaterThan gt fields.foo gt bar fields.foo greaterThan bar fields.foo.greaterThan(bar) greaterThanOrEqual gte fields.foo gte bar fields.foo greaterThanOrEqual bar fields.foo.greaterThanOrEqual(bar) between btw fields.foo btw Pair(bar1, bar2) fields.foo between Pair(bar1, bar2) fields.foo.between(bar1, bar2) like fields.foo like bar fields.foo.like(bar) notLike fields.foo notLike bar fields.foo.notLike(bar) isIn `in` fields.foo `in` bars fields.foo isIn bars fields.foo.isIn(bars) notIn `!in` fields.foo `!in` bars fields.foo notIn bars fields.foo.notIn(bars) Aggregate Functions Name Examples avg fields.foo.avg() fields.foo.avg(groupByColumns) fields.foo.avg(groupByColumns, sortDirection) count fields.foo.count() max fields.foo.max() fields.foo.max(groupByColumns) fields.foo.max(groupByColumns, sortDirection) min fields.foo.min() fields.foo.min(groupByColumns) fields.foo.min(groupByColumns, sortDirection) sum fields.foo.sum() fields.foo.sum(groupByColumns) fields.foo.sum(groupByColumns, sortDirection) Sorting Sorting is defined using the orderBy function. Both custom fields and standard attributes are supported, while aliases for standard attributes are provided for convenience: val criteria = bookConditions { // settings and criteria... // sorting orderBy { // Sort by standard attribute alias, same as // Sort.VaultStateAttribute.RECORDED_TIME sort ASC recordedTime sort ASC // Sort by custom field fields . title sort DESC } } The following standard attribute aliases are provided: Alias Standard Attribute stateRef Sort.CommonStateAttribute.STATE_REF stateRefTxnId Sort.CommonStateAttribute.STATE_REF_TXN_ID stateRefIndex Sort.CommonStateAttribute.STATE_REF_INDEX notaryName Sort.VaultStateAttribute.NOTARY_NAME contractStateType Sort.VaultStateAttribute.CONTRACT_STATE_TYPE stateStatus Sort.VaultStateAttribute.STATE_STATUS recordedTime Sort.VaultStateAttribute.RECORDED_TIME consumedTime Sort.VaultStateAttribute.CONSUMED_TIME lockId Sort.VaultStateAttribute.LOCK_ID constraintType Sort.VaultStateAttribute.CONSTRAINT_TYPE uuid Sort.LinearStateAttribute.UUID externalId Sort.LinearStateAttribute.EXTERNAL_ID quantity Sort.FungibleStateAttribute.QUANTITY issuerRef Sort.FungibleStateAttribute.ISSUER_REF","title":"Query DSL"},{"location":"core/query-dsl/#query-dsl","text":"Vaultaire uses an annotation processor at build-time to create a query DSL for your contract/persistent states.","title":"Query DSL"},{"location":"core/query-dsl/#quick-example","text":"Consider the following Contract/Persistent States: /** Book ContractState */ data class BookState ( val publisher : Party , val author : Party , val title : String , val published : Date = Date () ) : ContractState , QueryableState { // ... } // Use Vaultaire s code generation! @VaultaireGenerate ( name = booksQuery , contractStateType = BookState :: class ) @Entity @Table ( name = books ) data class PersistentBookState ( @Column ( name = publisher ) var publisher : String = , @Column ( name = author ) var author : String = , @Column ( name = title ) var title : String = , @Column ( name = published ) var published : Date ) : PersistentState ()","title":"Quick Example"},{"location":"core/query-dsl/#before-vaultaire","text":"Before Vaultaire, you probably had to create query criteria with something like: val query = VaultQueryCriteria ( contractStateTypes = setOf ( BookState :: class . java ), status = Vault . StateStatus . ALL ) // Check publisher? if ( checkPublisher ) query = query . and ( VaultCustomQueryCriteria ( PersistentBookState :: publisher . equal ( Corda Books Ltd. ))) // Add more criteria query . and ( VaultCustomQueryCriteria ( PersistentBookState :: title . equal ( A book on Corda )) . or ( VaultCustomQueryCriteria ( PersistentBookState :: author . notEqual ( John Doe )))) val sort = Sort ( listOf ( Sort . SortColumn ( SortAttribute . Custom ( PersistentBookState :: class . java , published ), Sort . Direction . DESC ))) // Finally! queryBy ( query , sort ) A bit verbose so get s difficult to read as the query becomes more complex. Let s try to simplify things bellow.","title":"Before Vaultaire"},{"location":"core/query-dsl/#with-vaultaire-dsl","text":"With Vaultaire s @VaultaireGenerate and the generated DSL this becomes: // Use the generated DSL to create query criteria val query = booksQuery { status = Vault . StateStatus . ALL and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` Corda Books Ltd. or { fields . title ` == ` A book on Corda fields . author ` != ` John Doe } } orderBy { fields . title sort DESC } }. toCriteria () queryBy ( query . toCriteria (), query . toSort ())","title":"With Vaultaire DSL"},{"location":"core/query-dsl/#create-a-dsl","text":"","title":"Create a DSL"},{"location":"core/query-dsl/#project-module-states","text":"To create a query DSL for your state after installing Vaultaire, annotate the corresponding PersistentState with @VaultaireGenerate : // Use Vaultaire s DSL generation! @VaultaireGenerate ( // If you omit the name, the DSL function will be named by appending Query // to the decapitalized contract state name, e.g. bookStateQuery name = booksQuery , contractStateType = BookState :: class ) @Entity @Table ( name = books ) data class PersistentBookState ( // state properties... ) : PersistentState ()","title":"Project Module States"},{"location":"core/query-dsl/#project-dependency-states","text":"To create a query DSL for a state from your project dependencies, annotate the any class in your project using the special @VaultaireGenerateFor annotation, providing the state s ContractState and PersistentState : @VaultaireGenerateForDependency ( name = fungibleTokenConditions , persistentStateType = PersistentFungibleToken :: class , contractStateType = FungibleToken :: class ) class Fungible","title":"Project Dependency States"},{"location":"core/query-dsl/#query-settings","text":"The generated DSL allows setting QueryCriteria.VaultQueryCriteria members. Here s an example using the defaults: val query = booksQuery { // settings status = Vault . StateStatus . UNCONSUMED stateRefs = null notary = null softLockingCondition = null timeCondition = null relevancyStatus = Vault . RelevancyStatus . ALL constraintTypes = emptySet () constraints = emptySet () participants = null // criteria and sorting... }","title":"Query Settings"},{"location":"core/query-dsl/#adding-criteria","text":"Query riteria are defined within the and / or functions. Both functions can be nested and mixed with criteria like: val query = booksQuery { // settings... // criteria or { // Match at least one fields . foo1 ` == ` someValue and { // Match all fields . foo1 . isNull () fields . foo2 ` == ` someOtherValue and { // ... } or { // ... } } } // sorting... }","title":"Adding Criteria"},{"location":"core/query-dsl/#adding-aggregates","text":"Aggregates can be specified within the and / or functions: val bookStateQuery = bookStateQuery { // settings... // criteria and { fields . title `like` %Corda Foundation% fields . genre ` == ` BookContract . BookGenre . SCIENCE_FICTION } // aggregates aggregate { // add some aggregates fields . externalId . count () fields . id . count () fields . editions . sum () fields . price . min () fields . price . avg () fields . price . max () } } Note : Corda paged queries can include either query results or other results based on the above aggregates. For that purpose, the toCriteria functions accepts an optional boolean to ignore aggregates, thus allowing the reuse of the same query to obtain either paged state or aggregate results.","title":"Adding Aggregates"},{"location":"core/query-dsl/#accessing-fields","text":"Fields can be accessed via the generated DSL s fields object within and , or , or orderBy functions using dot notation e.g. fields.foo . You can also retrieve fields by name with e.g. fields[\"foo\"] or fields.get(\"foo\") and use non typesafe functions like _equal , _notEqual , _like , _notLike but this may change in a future release.","title":"Accessing Fields"},{"location":"core/query-dsl/#functions-and-operators","text":"Name Aliases Examples isNull fields.foo.isNull() notNull fields.foo.notNull() equal `==` fields.foo `==` bar fields.foo equal bar fields.foo.equal(bar) notEqual `!=` fields.foo `!=` bar fields.foo notEqual bar fields.foo.notEqual(bar) lessThan lt fields.foo lt bar fields.foo lessThan bar fields.foo.lessThan(bar) lessThanOrEqual lte fields.foo lte bar fields.foo lessThanOrEqual bar fields.foo.lessThanOrEqual(bar) greaterThan gt fields.foo gt bar fields.foo greaterThan bar fields.foo.greaterThan(bar) greaterThanOrEqual gte fields.foo gte bar fields.foo greaterThanOrEqual bar fields.foo.greaterThanOrEqual(bar) between btw fields.foo btw Pair(bar1, bar2) fields.foo between Pair(bar1, bar2) fields.foo.between(bar1, bar2) like fields.foo like bar fields.foo.like(bar) notLike fields.foo notLike bar fields.foo.notLike(bar) isIn `in` fields.foo `in` bars fields.foo isIn bars fields.foo.isIn(bars) notIn `!in` fields.foo `!in` bars fields.foo notIn bars fields.foo.notIn(bars)","title":"Functions and Operators"},{"location":"core/query-dsl/#aggregate-functions","text":"Name Examples avg fields.foo.avg() fields.foo.avg(groupByColumns) fields.foo.avg(groupByColumns, sortDirection) count fields.foo.count() max fields.foo.max() fields.foo.max(groupByColumns) fields.foo.max(groupByColumns, sortDirection) min fields.foo.min() fields.foo.min(groupByColumns) fields.foo.min(groupByColumns, sortDirection) sum fields.foo.sum() fields.foo.sum(groupByColumns) fields.foo.sum(groupByColumns, sortDirection)","title":"Aggregate Functions"},{"location":"core/query-dsl/#sorting","text":"Sorting is defined using the orderBy function. Both custom fields and standard attributes are supported, while aliases for standard attributes are provided for convenience: val criteria = bookConditions { // settings and criteria... // sorting orderBy { // Sort by standard attribute alias, same as // Sort.VaultStateAttribute.RECORDED_TIME sort ASC recordedTime sort ASC // Sort by custom field fields . title sort DESC } } The following standard attribute aliases are provided: Alias Standard Attribute stateRef Sort.CommonStateAttribute.STATE_REF stateRefTxnId Sort.CommonStateAttribute.STATE_REF_TXN_ID stateRefIndex Sort.CommonStateAttribute.STATE_REF_INDEX notaryName Sort.VaultStateAttribute.NOTARY_NAME contractStateType Sort.VaultStateAttribute.CONTRACT_STATE_TYPE stateStatus Sort.VaultStateAttribute.STATE_STATUS recordedTime Sort.VaultStateAttribute.RECORDED_TIME consumedTime Sort.VaultStateAttribute.CONSUMED_TIME lockId Sort.VaultStateAttribute.LOCK_ID constraintType Sort.VaultStateAttribute.CONSTRAINT_TYPE uuid Sort.LinearStateAttribute.UUID externalId Sort.LinearStateAttribute.EXTERNAL_ID quantity Sort.FungibleStateAttribute.QUANTITY issuerRef Sort.FungibleStateAttribute.ISSUER_REF","title":"Sorting"},{"location":"core/state-dtos/","text":"State DTOs Overview Maintaining Data Transfer Objects for your contract states can be a mundane, error-prone task. Vaultaire\u2019s annotation processing automates this by (re)generating those DTOs for you. Usage Patterns A typical use for generated DTOs is messaging over HTTP REST or RPC as input and output of Corda Flows. The provided conversion utilities can be used to create, update or even patch ContractState types they correspond to. DTO to State To convert from DTO to state, use the DTO s toTargetType() method: // Using default strategy // ---------------------- // Get the DTO val dto1 : BookStateDto = //... // Convert to State val state1 : BookState = dto1 . toTargetType () // Using lite strategy // ---------------------- // Get the Service val stateService : BookStateService = //... // Get the lite DTO val dto2 : BookStateLiteDto = // ... // Convert to State val state2 : BookState = dto2 . toTargetType ( stateService ) DTO as Patch Update DTOs can be used to transfer and apply a patch to update an existing state: // Get the Service val stateService = BookStateService ( serviceHub_or_RPCOps ) // Load state from Node Vault val state : BookState = stateService . getByLinearId ( id ) // Apply DTO as patch // ---------------------- val patchedState1 : BookState = dto1 . toPatched ( state ) // Apply lite DTO as patch // ---------------------- val patchedState2 : BookState = dto2 . toPatched ( state , stateService ) State to DTO To convert from state to DTO, use the DTO s latter s alternative, state-based constructor: // Get the state val state : BookState = stateService . getByLinearId ( id ) // Convert to DTO val dto = BookStateDto . mapToDto ( state ) DTO Generation This section explains the annotations and strategies involved in generating DTOs. Annotations Local States To have Vaultaire generate DTOs for ContractState s within local (Gradle module) sources, annotate them with @VaultaireGenerateDto : @VaultaireGenerateDto ( // optional: properties to ignore ignoreProperties = [ foo ], // optional, default is false includeParticipants = false ) data class BookState ( val publisher : Party , val author : Party , val price : BigDecimal , val genre : Genre , @DefaultValue ( 1 ) val editions : Int = 1 , val title : String = Uknown , val published : Date = Date (), @field : JsonProperty ( alias ) val alternativeTitle : String ? = null , override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { /* ... */ } Dependency States To generate DTOs for ContractState s outside the sources in context, e.g. from a contract states module or a project dependency, create a mixin class as a placeholder and annotate it with @VaultaireGenerateDtoForDependency . This approach might be preferred or necessary even for state sources in context or under your control, e.g. when having (the good practice of) separate cordapp modules for contracts/states and flows. Mixin example: @VaultaireGenerateDtoForDependency ( persistentStateType = PersistentBookState :: class , contractStateType = BookState :: class , // optional: properties to ignore ignoreProperties = [ foo ] ) class BookStateMixin // just a placeholder for our annotation Utility Annotations The @DefaultValue can be used to provide default property initializers. It can be used equally on either ContractState or mixin properties: @VaultaireGenerateForDependency ( /*...*/ ) @VaultaireGenerateDtoForDependency ( /*...*/ ) data class MagazineMixin ( @DefaultValue ( 1 ) var issues : Int , @DefaultValue ( Date() ) val published : Date , @DefaultValue ( UniqueIdentifier() ) val linearId : UniqueIdentifier ) Sample DTO In both cases above the following DTO will be generated. Note the nullable var members and utilities to convert between the two types or to patch an existing state: /** * A [BookState]-specific [Dto] implementation */ @CordaSerializable data class BookStateDto ( var publisher : Party ? = null , var author : Party ? = null , var price : BigDecimal ? = null , var genre : BookContract . Genre ? = null , var editions : Int ? = 1 , var title : String ? = null , var published : Date ? = null , @field : JsonProperty ( value = alias ) var alternativeTitle : String ? = null , var linearId : UniqueIdentifier ? = null ) : Dto BookState { /** * Alternative constructor, used to map * from the given [BookState] instance. */ constructor ( original : BookState ) : this ( publisher = original . publisher , author = original . author , price = original . price , genre = original . genre , editions = original . editions , title = original . title , published = original . published , alternativeTitle = original . alternativeTitle , linearId = original . linearId ) /** * Create a patched copy of the given [BookState] instance, * updated using this DTO s non-null properties. */ override fun toPatched ( original : BookState ): BookState { val patched = BookState ( publisher = this . publisher ?: original . publisher , author = this . author ?: original . author , price = this . price ?: original . price , genre = this . genre ?: original . genre , editions = this . editions ?: original . editions , title = this . title ?: original . title , published = this . published ?: original . published , alternativeTitle = this . alternativeTitle ?: original . alternativeTitle , linearId = this . linearId ?: original . linearId ) return patched } /** * Create an instance of [BookState], using this DTO s properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ override fun toState (): BookState { try { val state = BookState ( publisher = this . publisher !! , author = this . author !! , price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return state } catch ( e : Exception ) { throw DtoInsufficientStateMappingException ( exception = e ) } } } Strategies Both @VaultaireGenerateDto and @VaultaireGenerateDtoForDependency support generation strategy hints. By default the strategy used is VaultaireDtoStrategyKeys.DEFAULT . The only additional strategy provided is the more REST-friendly VaultaireDtoStrategyKeys.LITE . Using both, as in the following example, will generate separate DTOs for each. @VaultaireGenerateDto ( ignoreProperties = [ foo ], strategies = [ VaultaireDtoStrategyKeys . DEFAULT , VaultaireDtoStrategyKeys . LITE ]) ) data class BookState ( //... ) : LinearState , QueryableState { //... } The lite strategy is provided to help where deserialization would normally require either a ServiceHub or RpcOps , e.g. when the target property is a Party , in which case the DTO will use a more manageable type like CordaX500Name , and require a service to convert to or patch a ContractState instance. Note that lite DTO classnames will also have a LiteDto suffix. Here s the lite DTO generated for the above example: /** * A [BookContract.BookState]-specific [com.github.manotbatsis.kotlin.utils.api.Dto] implementation */ data class BookStateLiteDto ( var publisher : CordaX500Name ? = null , var author : CordaX500Name ? = null , var price : BigDecimal ? = null , var genre : BookContract . Genre ? = null , var editions : Int ? = 1 , var title : String ? = null , var published : Date ? = null , @field : JsonProperty ( value = alias ) var alternativeTitle : String ? = null , var linearId : UniqueIdentifier ? = null ) : VaultaireDto BookContract . BookState { /** * Alternative constructor, used to map * from the given [BookContract.BookState] instance. */ constructor ( original : BookContract . BookState ) : this ( publisher = original . publisher . name , author = original . author . name , price = original . price , genre = original . genre , editions = original . editions , title = original . title , published = original . published , alternativeTitle = original . alternativeTitle , linearId = original . linearId ) /** * Create a patched copy of the given [BookContract.BookState] instance, * updated using this DTO s non-null properties. */ override fun toPatched ( original : BookContract . BookState , stateService : StateService BookContract . BookState ): BookContract . BookState { val patched = BookContract . BookState ( publisher = if ( this . publisher != null ) stateService . wellKnownPartyFromX500Name ( this . publisher !! ) !! else original . publisher !! , author = if ( this . author != null ) stateService . wellKnownPartyFromX500Name ( this . author !! ) !! else original . author !! , price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return patched } /** * Create an instance of [BookContract.BookState], using this DTO s properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ override fun toTargetType ( stateService : StateService BookContract . BookState ): BookContract . BookState { try { val originalTypeInstance = BookContract . BookState ( publisher = if ( this . publisher != null ) stateService . wellKnownPartyFromX500Name ( this . publisher !! ) !! else throw DtoInsufficientMappingException ( No value given for property publisher ), author = if ( this . author != null ) stateService . wellKnownPartyFromX500Name ( this . author !! ) !! else throw DtoInsufficientMappingException ( No value given for property author ), price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return originalTypeInstance } catch ( e : Exception ) { throw DtoInsufficientMappingException ( exception = e ) } } }","title":"State DTOs"},{"location":"core/state-dtos/#state-dtos","text":"","title":"State DTOs"},{"location":"core/state-dtos/#overview","text":"Maintaining Data Transfer Objects for your contract states can be a mundane, error-prone task. Vaultaire\u2019s annotation processing automates this by (re)generating those DTOs for you.","title":"Overview"},{"location":"core/state-dtos/#usage-patterns","text":"A typical use for generated DTOs is messaging over HTTP REST or RPC as input and output of Corda Flows. The provided conversion utilities can be used to create, update or even patch ContractState types they correspond to.","title":"Usage Patterns"},{"location":"core/state-dtos/#dto-to-state","text":"To convert from DTO to state, use the DTO s toTargetType() method: // Using default strategy // ---------------------- // Get the DTO val dto1 : BookStateDto = //... // Convert to State val state1 : BookState = dto1 . toTargetType () // Using lite strategy // ---------------------- // Get the Service val stateService : BookStateService = //... // Get the lite DTO val dto2 : BookStateLiteDto = // ... // Convert to State val state2 : BookState = dto2 . toTargetType ( stateService )","title":"DTO to State"},{"location":"core/state-dtos/#dto-as-patch-update","text":"DTOs can be used to transfer and apply a patch to update an existing state: // Get the Service val stateService = BookStateService ( serviceHub_or_RPCOps ) // Load state from Node Vault val state : BookState = stateService . getByLinearId ( id ) // Apply DTO as patch // ---------------------- val patchedState1 : BookState = dto1 . toPatched ( state ) // Apply lite DTO as patch // ---------------------- val patchedState2 : BookState = dto2 . toPatched ( state , stateService )","title":"DTO as Patch Update"},{"location":"core/state-dtos/#state-to-dto","text":"To convert from state to DTO, use the DTO s latter s alternative, state-based constructor: // Get the state val state : BookState = stateService . getByLinearId ( id ) // Convert to DTO val dto = BookStateDto . mapToDto ( state )","title":"State to DTO"},{"location":"core/state-dtos/#dto-generation","text":"This section explains the annotations and strategies involved in generating DTOs.","title":"DTO Generation"},{"location":"core/state-dtos/#annotations","text":"","title":"Annotations"},{"location":"core/state-dtos/#local-states","text":"To have Vaultaire generate DTOs for ContractState s within local (Gradle module) sources, annotate them with @VaultaireGenerateDto : @VaultaireGenerateDto ( // optional: properties to ignore ignoreProperties = [ foo ], // optional, default is false includeParticipants = false ) data class BookState ( val publisher : Party , val author : Party , val price : BigDecimal , val genre : Genre , @DefaultValue ( 1 ) val editions : Int = 1 , val title : String = Uknown , val published : Date = Date (), @field : JsonProperty ( alias ) val alternativeTitle : String ? = null , override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { /* ... */ }","title":"Local States"},{"location":"core/state-dtos/#dependency-states","text":"To generate DTOs for ContractState s outside the sources in context, e.g. from a contract states module or a project dependency, create a mixin class as a placeholder and annotate it with @VaultaireGenerateDtoForDependency . This approach might be preferred or necessary even for state sources in context or under your control, e.g. when having (the good practice of) separate cordapp modules for contracts/states and flows. Mixin example: @VaultaireGenerateDtoForDependency ( persistentStateType = PersistentBookState :: class , contractStateType = BookState :: class , // optional: properties to ignore ignoreProperties = [ foo ] ) class BookStateMixin // just a placeholder for our annotation","title":"Dependency States"},{"location":"core/state-dtos/#utility-annotations","text":"The @DefaultValue can be used to provide default property initializers. It can be used equally on either ContractState or mixin properties: @VaultaireGenerateForDependency ( /*...*/ ) @VaultaireGenerateDtoForDependency ( /*...*/ ) data class MagazineMixin ( @DefaultValue ( 1 ) var issues : Int , @DefaultValue ( Date() ) val published : Date , @DefaultValue ( UniqueIdentifier() ) val linearId : UniqueIdentifier )","title":"Utility Annotations"},{"location":"core/state-dtos/#sample-dto","text":"In both cases above the following DTO will be generated. Note the nullable var members and utilities to convert between the two types or to patch an existing state: /** * A [BookState]-specific [Dto] implementation */ @CordaSerializable data class BookStateDto ( var publisher : Party ? = null , var author : Party ? = null , var price : BigDecimal ? = null , var genre : BookContract . Genre ? = null , var editions : Int ? = 1 , var title : String ? = null , var published : Date ? = null , @field : JsonProperty ( value = alias ) var alternativeTitle : String ? = null , var linearId : UniqueIdentifier ? = null ) : Dto BookState { /** * Alternative constructor, used to map * from the given [BookState] instance. */ constructor ( original : BookState ) : this ( publisher = original . publisher , author = original . author , price = original . price , genre = original . genre , editions = original . editions , title = original . title , published = original . published , alternativeTitle = original . alternativeTitle , linearId = original . linearId ) /** * Create a patched copy of the given [BookState] instance, * updated using this DTO s non-null properties. */ override fun toPatched ( original : BookState ): BookState { val patched = BookState ( publisher = this . publisher ?: original . publisher , author = this . author ?: original . author , price = this . price ?: original . price , genre = this . genre ?: original . genre , editions = this . editions ?: original . editions , title = this . title ?: original . title , published = this . published ?: original . published , alternativeTitle = this . alternativeTitle ?: original . alternativeTitle , linearId = this . linearId ?: original . linearId ) return patched } /** * Create an instance of [BookState], using this DTO s properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ override fun toState (): BookState { try { val state = BookState ( publisher = this . publisher !! , author = this . author !! , price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return state } catch ( e : Exception ) { throw DtoInsufficientStateMappingException ( exception = e ) } } }","title":"Sample DTO"},{"location":"core/state-dtos/#strategies","text":"Both @VaultaireGenerateDto and @VaultaireGenerateDtoForDependency support generation strategy hints. By default the strategy used is VaultaireDtoStrategyKeys.DEFAULT . The only additional strategy provided is the more REST-friendly VaultaireDtoStrategyKeys.LITE . Using both, as in the following example, will generate separate DTOs for each. @VaultaireGenerateDto ( ignoreProperties = [ foo ], strategies = [ VaultaireDtoStrategyKeys . DEFAULT , VaultaireDtoStrategyKeys . LITE ]) ) data class BookState ( //... ) : LinearState , QueryableState { //... } The lite strategy is provided to help where deserialization would normally require either a ServiceHub or RpcOps , e.g. when the target property is a Party , in which case the DTO will use a more manageable type like CordaX500Name , and require a service to convert to or patch a ContractState instance. Note that lite DTO classnames will also have a LiteDto suffix. Here s the lite DTO generated for the above example: /** * A [BookContract.BookState]-specific [com.github.manotbatsis.kotlin.utils.api.Dto] implementation */ data class BookStateLiteDto ( var publisher : CordaX500Name ? = null , var author : CordaX500Name ? = null , var price : BigDecimal ? = null , var genre : BookContract . Genre ? = null , var editions : Int ? = 1 , var title : String ? = null , var published : Date ? = null , @field : JsonProperty ( value = alias ) var alternativeTitle : String ? = null , var linearId : UniqueIdentifier ? = null ) : VaultaireDto BookContract . BookState { /** * Alternative constructor, used to map * from the given [BookContract.BookState] instance. */ constructor ( original : BookContract . BookState ) : this ( publisher = original . publisher . name , author = original . author . name , price = original . price , genre = original . genre , editions = original . editions , title = original . title , published = original . published , alternativeTitle = original . alternativeTitle , linearId = original . linearId ) /** * Create a patched copy of the given [BookContract.BookState] instance, * updated using this DTO s non-null properties. */ override fun toPatched ( original : BookContract . BookState , stateService : StateService BookContract . BookState ): BookContract . BookState { val patched = BookContract . BookState ( publisher = if ( this . publisher != null ) stateService . wellKnownPartyFromX500Name ( this . publisher !! ) !! else original . publisher !! , author = if ( this . author != null ) stateService . wellKnownPartyFromX500Name ( this . author !! ) !! else original . author !! , price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return patched } /** * Create an instance of [BookContract.BookState], using this DTO s properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ override fun toTargetType ( stateService : StateService BookContract . BookState ): BookContract . BookState { try { val originalTypeInstance = BookContract . BookState ( publisher = if ( this . publisher != null ) stateService . wellKnownPartyFromX500Name ( this . publisher !! ) !! else throw DtoInsufficientMappingException ( No value given for property publisher ), author = if ( this . author != null ) stateService . wellKnownPartyFromX500Name ( this . author !! ) !! else throw DtoInsufficientMappingException ( No value given for property author ), price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return originalTypeInstance } catch ( e : Exception ) { throw DtoInsufficientMappingException ( exception = e ) } } }","title":"Strategies"},{"location":"core/state-services/","text":"State Services Overview Vaultaire s StateService s provide a simple, consistent API to load, query and track vault states. StateService implementations are usually auto-generated at build time and specific to a single ContractState type. State Services can also decouple you code from ServiceHub and CordaRPCOps by providing constructors for either, thus helping increase code reuse between cordapps and their clients. They also support RPC connection pooling, i.e. provide a constructor that accepts a PoolBoy PoolBoyConnection . Basic Services Basic implementations of NodeService and StateService are more limited and/or less easy to use than generated ones but functional nevertheless: val bookStateService = BasicStateService ( serviceHubOrRpcOpsOrPoolBoy , BookContract . BookState :: class . java ) State Services Vaultaire s annotation processor will generate optimal StateService implementations, each specific to one of the ContractState - PersistentState pairs found at build-time based on the annotations found in your code. Service classnames are based on the contract state classname, suffixed by Service . Usage example: // Create an instance of the generated service type, // passing a ServiceHub, CordaRPCOps, NodeRpcConnection // or even a custom StateServiceDelegate val bookStateService = BookStateService ( serviceHub ) // Load a book bookStateService . getByLinearId ( identifier ) // Try finding one by UniqueIdentifier.externalId, // in this case an ISBN bookStateService . findByExternalId ( isbn ) // Count the book states that match our query criteria val booksCount = bookStateService . countBy ( queryCriteria ) // Query the vault for a results page of the same books val searchResultsPage : Vault . Page BookState = bookStateService . queryBy ( queryCriteria , // Optional PageSpecification or page number/size params page , // Optional Sort or vararg of Pair String, Sort.Direction sort ) // Track the vault for book events val trackResults = bookStateService . queryBy ( criteria ) Custom Services You can also subclass (or, perhaps preferably, use as delegates) generated service types or BasicNodeService , BasicStateService , ExtendedStateService etc. to create custom components. /** Extend the generated [BookStateService] */ class MyExtendedBookStateService ( delegate : StateServiceDelegate BookState ) : BookStateService ( delegate ){ // Add the appropriate constructors // to initialize per delegate type: /** [CordaRPCOps]-based constructor */ constructor ( rpcOps : CordaRPCOps , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceRpcDelegate ( rpcOps , BookState :: class . java , defaults )) /** [ServiceHub]-based constructor */ constructor ( serviceHub : ServiceHub , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceHubDelegate ( serviceHub , BookState :: class . java , defaults )) // Custom business methods... }","title":"State Services"},{"location":"core/state-services/#state-services","text":"","title":"State Services"},{"location":"core/state-services/#overview","text":"Vaultaire s StateService s provide a simple, consistent API to load, query and track vault states. StateService implementations are usually auto-generated at build time and specific to a single ContractState type. State Services can also decouple you code from ServiceHub and CordaRPCOps by providing constructors for either, thus helping increase code reuse between cordapps and their clients. They also support RPC connection pooling, i.e. provide a constructor that accepts a PoolBoy PoolBoyConnection .","title":"Overview"},{"location":"core/state-services/#basic-services","text":"Basic implementations of NodeService and StateService are more limited and/or less easy to use than generated ones but functional nevertheless: val bookStateService = BasicStateService ( serviceHubOrRpcOpsOrPoolBoy , BookContract . BookState :: class . java )","title":"Basic Services"},{"location":"core/state-services/#state-services_1","text":"Vaultaire s annotation processor will generate optimal StateService implementations, each specific to one of the ContractState - PersistentState pairs found at build-time based on the annotations found in your code. Service classnames are based on the contract state classname, suffixed by Service . Usage example: // Create an instance of the generated service type, // passing a ServiceHub, CordaRPCOps, NodeRpcConnection // or even a custom StateServiceDelegate val bookStateService = BookStateService ( serviceHub ) // Load a book bookStateService . getByLinearId ( identifier ) // Try finding one by UniqueIdentifier.externalId, // in this case an ISBN bookStateService . findByExternalId ( isbn ) // Count the book states that match our query criteria val booksCount = bookStateService . countBy ( queryCriteria ) // Query the vault for a results page of the same books val searchResultsPage : Vault . Page BookState = bookStateService . queryBy ( queryCriteria , // Optional PageSpecification or page number/size params page , // Optional Sort or vararg of Pair String, Sort.Direction sort ) // Track the vault for book events val trackResults = bookStateService . queryBy ( criteria )","title":"State Services"},{"location":"core/state-services/#custom-services","text":"You can also subclass (or, perhaps preferably, use as delegates) generated service types or BasicNodeService , BasicStateService , ExtendedStateService etc. to create custom components. /** Extend the generated [BookStateService] */ class MyExtendedBookStateService ( delegate : StateServiceDelegate BookState ) : BookStateService ( delegate ){ // Add the appropriate constructors // to initialize per delegate type: /** [CordaRPCOps]-based constructor */ constructor ( rpcOps : CordaRPCOps , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceRpcDelegate ( rpcOps , BookState :: class . java , defaults )) /** [ServiceHub]-based constructor */ constructor ( serviceHub : ServiceHub , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceHubDelegate ( serviceHub , BookState :: class . java , defaults )) // Custom business methods... }","title":"Custom Services"},{"location":"plugins/corda-accounts/","text":"Corda Accounts Plugin This plugin provides support for Corda Accounts to Vaultaire s runtime and build-time modules. Installation Add Vaultaire s plugin for Corda Accounts to your Cordapp s Gradle dependencies using compile, cordapp or cordaCompile to match the core Vaultaire dependency. cordaCompile com.github.manosbatsis.vaultaire:vaultaire-plugin-accounts:$vaultaire_version Depending on the above dependency type, you may also need to add the plugin to your client app and deployNodes dependency configuration. Features The plugin adds both new and enhanced versions of core component types. It also overrides Vaultaire s internal configuration options to effectively apply them. These include the default base types extended by components generated by the annotation processor. DTO Enhancements VaultaireAccountInfo Annotation The plugin introduces the VaultaireAccountInfo annotation as the means to mark participant or other properties of a ContractState that map to a Corda Account. Supported types include: AbstractParty AnonymousParty PublicKey AccountParty Using the annotation for the last one is optional. Accounts-Aware DTO Types The plugin also adds: AccountInfoDto as a convenient model that maps from app-level users or state properties (as supported by @VaultaireAccountInfo above) to Corda Accounts, i.e. AccountInfo states. AccountsAwareLiteDto as the equivalent of LiteDto , including it s use as the base DTO type by the lite DTO strategy. All the above effectively provide the lite DTO strategy with enhanced DTO - state conversion and patching utilities, i.e. mainly with support for mapping between the applicable types (see @VaultaireAccountInfo ) and AccountInfoDto . As an example, consider the following state: data class MagazineState ( val publisher : AccountParty , @VaultaireAccountInfo val author : PublicKey , @VaultaireAccountInfo val editor : AbstractParty , //... override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { override val participants get () = listOf ( publisher . party , AbstractParty ( author ), editor ) //... } The generated DTO for the above: data class MagazineStateLiteDto ( var publisher : AccountInfoLiteDto ? = null , var author : AccountInfoLiteDto ? = null , var editor : AccountInfoLiteDto ? = null , //... var linearId : UniqueIdentifier ? = null ) : AccountsAwareLiteDto BookContract . MagazineState { Query DSL Enhancements Corda 4.3 added the possibility to map any public key to an external id of type UUID. Corda Accounts uses this feature to map an account s key to the account s id. Thus, using externalIds creates query criteria aware of state participants, without the need to embed account identifiers within the state itself. This is now supported by the generated Query DSL for your contract state: val magazineStateQuery = magazineStateQuery { // Match participants using the following // AccountInfo identifiers externalIds = listOfNotNull ( publisher . identifier ) status = Vault . StateStatus . UNCONSUMED // the default // The rest of the query.. //... Service Enhancements The plugin also adds and applies various accounts-aware service types as replacements of their default equivalents, along with a number of utility methods around accounts. // Create an instance of the generated service type, // passing a ServiceHub, CordaRPCOps, NodeRpcConnection // or even a custom StateServiceDelegate val stateService = AccountInfoService ( serviceHub ) // Get the account that is already stored locally // and matching the given [id] if found, null otherwise val accountOrNull : AccountInfo ? = stateService . findStoredAccount ( accountId ) ?: stateService . requestAccount ( accountId , accountHost ) // Get the account that is already stored locally // and matching the given [id] if found, null otherwise val account : AccountInfo = stateService . getStoredAccount ( accountId ) // Find accounts that are already stored locally // and match the given [criteria] val accountsPage : Vault . Page AccountInfo = stateService . findStoredAccounts ( queryCriteria ) // Create a public key for the given [accountInfo] */ val anonymousParty = stateService . createPublicKey ( accountInfo )","title":"Corda Accounts"},{"location":"plugins/corda-accounts/#corda-accounts-plugin","text":"This plugin provides support for Corda Accounts to Vaultaire s runtime and build-time modules.","title":"Corda Accounts Plugin"},{"location":"plugins/corda-accounts/#installation","text":"Add Vaultaire s plugin for Corda Accounts to your Cordapp s Gradle dependencies using compile, cordapp or cordaCompile to match the core Vaultaire dependency. cordaCompile com.github.manosbatsis.vaultaire:vaultaire-plugin-accounts:$vaultaire_version Depending on the above dependency type, you may also need to add the plugin to your client app and deployNodes dependency configuration.","title":"Installation"},{"location":"plugins/corda-accounts/#features","text":"The plugin adds both new and enhanced versions of core component types. It also overrides Vaultaire s internal configuration options to effectively apply them. These include the default base types extended by components generated by the annotation processor.","title":"Features"},{"location":"plugins/corda-accounts/#dto-enhancements","text":"","title":"DTO Enhancements"},{"location":"plugins/corda-accounts/#vaultaireaccountinfo-annotation","text":"The plugin introduces the VaultaireAccountInfo annotation as the means to mark participant or other properties of a ContractState that map to a Corda Account. Supported types include: AbstractParty AnonymousParty PublicKey AccountParty Using the annotation for the last one is optional.","title":"VaultaireAccountInfo Annotation"},{"location":"plugins/corda-accounts/#accounts-aware-dto-types","text":"The plugin also adds: AccountInfoDto as a convenient model that maps from app-level users or state properties (as supported by @VaultaireAccountInfo above) to Corda Accounts, i.e. AccountInfo states. AccountsAwareLiteDto as the equivalent of LiteDto , including it s use as the base DTO type by the lite DTO strategy. All the above effectively provide the lite DTO strategy with enhanced DTO - state conversion and patching utilities, i.e. mainly with support for mapping between the applicable types (see @VaultaireAccountInfo ) and AccountInfoDto . As an example, consider the following state: data class MagazineState ( val publisher : AccountParty , @VaultaireAccountInfo val author : PublicKey , @VaultaireAccountInfo val editor : AbstractParty , //... override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { override val participants get () = listOf ( publisher . party , AbstractParty ( author ), editor ) //... } The generated DTO for the above: data class MagazineStateLiteDto ( var publisher : AccountInfoLiteDto ? = null , var author : AccountInfoLiteDto ? = null , var editor : AccountInfoLiteDto ? = null , //... var linearId : UniqueIdentifier ? = null ) : AccountsAwareLiteDto BookContract . MagazineState {","title":"Accounts-Aware DTO Types"},{"location":"plugins/corda-accounts/#query-dsl-enhancements","text":"Corda 4.3 added the possibility to map any public key to an external id of type UUID. Corda Accounts uses this feature to map an account s key to the account s id. Thus, using externalIds creates query criteria aware of state participants, without the need to embed account identifiers within the state itself. This is now supported by the generated Query DSL for your contract state: val magazineStateQuery = magazineStateQuery { // Match participants using the following // AccountInfo identifiers externalIds = listOfNotNull ( publisher . identifier ) status = Vault . StateStatus . UNCONSUMED // the default // The rest of the query.. //...","title":"Query DSL Enhancements"},{"location":"plugins/corda-accounts/#service-enhancements","text":"The plugin also adds and applies various accounts-aware service types as replacements of their default equivalents, along with a number of utility methods around accounts. // Create an instance of the generated service type, // passing a ServiceHub, CordaRPCOps, NodeRpcConnection // or even a custom StateServiceDelegate val stateService = AccountInfoService ( serviceHub ) // Get the account that is already stored locally // and matching the given [id] if found, null otherwise val accountOrNull : AccountInfo ? = stateService . findStoredAccount ( accountId ) ?: stateService . requestAccount ( accountId , accountHost ) // Get the account that is already stored locally // and matching the given [id] if found, null otherwise val account : AccountInfo = stateService . getStoredAccount ( accountId ) // Find accounts that are already stored locally // and match the given [criteria] val accountsPage : Vault . Page AccountInfo = stateService . findStoredAccounts ( queryCriteria ) // Create a public key for the given [accountInfo] */ val anonymousParty = stateService . createPublicKey ( accountInfo )","title":"Service Enhancements"}]}