{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Vaultaire \u00b6 Query DSL and data access utilities for Corda developers. Query DSL \u00b6 Use DSL will make your queries much easier to read and maintain. Each query DSL is automatically (re)generated at build time using annotation processing. Usage example: val queryCriteria : QueryCriteria = booksQuery { and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` \"Corda Books Ltd.\" or { fields . title ` == ` \"A book on Corda\" fields . author ` != ` \"John Doe\" } } orderBy { fields . title sort DESC } }. toCriteria () For more details see Query DSL . RSQL Plugin \u00b6 A plugin with support for RSQL , a URL-friendly query language for dynamic, complex queries and maintenance-free REST endpoints for searching the Vault. For more details see RSQL Support . Accounts Plugin \u00b6 A plugin for adding Corda Accounts support to Vaultaire\u2019s runtime and build-time modules. For more details see Corda Accounts . State Services \u00b6 Vaultaire\u2019s StateService interface provide a simple, consistent API to load, query and track vault states. StateService implementations are usually auto-generated at build time and specific to a single ContractState type. State Services can also decouple you code from ServiceHub and CordaRPCOps amd help increase code reuse between cordapps and their clients. For more details see State Services . State DTOs \u00b6 Maintaining Data Transfer Objects for your contract states can be a mundane, error-prone task. Vaultaire\u2019s annotation processing automates this by (re)generating those DTOs for you. For more info checkout State DTOs Other Utils \u00b6 Vaultaire includes a few other utilities like: REST-friendly pages for query results. Annotation to generate responder flows from commonly used supertypes. For more info checkout Other Utilities Sample Projects \u00b6 For simple examples, checkout the vaultaire-example-contract and vaultaire-example-workflow modules in Vaultaire\u2019s repository on Github. For an extensive Cordapp example including a Spring Boot client checkout the corbeans-yo-cordapp repository.","title":"Overview"},{"location":"#vaultaire","text":"Query DSL and data access utilities for Corda developers.","title":"Vaultaire"},{"location":"#query-dsl","text":"Use DSL will make your queries much easier to read and maintain. Each query DSL is automatically (re)generated at build time using annotation processing. Usage example: val queryCriteria : QueryCriteria = booksQuery { and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` \"Corda Books Ltd.\" or { fields . title ` == ` \"A book on Corda\" fields . author ` != ` \"John Doe\" } } orderBy { fields . title sort DESC } }. toCriteria () For more details see Query DSL .","title":"Query DSL"},{"location":"#rsql-plugin","text":"A plugin with support for RSQL , a URL-friendly query language for dynamic, complex queries and maintenance-free REST endpoints for searching the Vault. For more details see RSQL Support .","title":"RSQL Plugin"},{"location":"#accounts-plugin","text":"A plugin for adding Corda Accounts support to Vaultaire\u2019s runtime and build-time modules. For more details see Corda Accounts .","title":"Accounts Plugin"},{"location":"#state-services","text":"Vaultaire\u2019s StateService interface provide a simple, consistent API to load, query and track vault states. StateService implementations are usually auto-generated at build time and specific to a single ContractState type. State Services can also decouple you code from ServiceHub and CordaRPCOps amd help increase code reuse between cordapps and their clients. For more details see State Services .","title":"State Services"},{"location":"#state-dtos","text":"Maintaining Data Transfer Objects for your contract states can be a mundane, error-prone task. Vaultaire\u2019s annotation processing automates this by (re)generating those DTOs for you. For more info checkout State DTOs","title":"State DTOs"},{"location":"#other-utils","text":"Vaultaire includes a few other utilities like: REST-friendly pages for query results. Annotation to generate responder flows from commonly used supertypes. For more info checkout Other Utilities","title":"Other Utils"},{"location":"#sample-projects","text":"For simple examples, checkout the vaultaire-example-contract and vaultaire-example-workflow modules in Vaultaire\u2019s repository on Github. For an extensive Cordapp example including a Spring Boot client checkout the corbeans-yo-cordapp repository.","title":"Sample Projects"},{"location":"changelog/","text":"Changelog \u00b6 The following sections describe major changes per version and can be helpful with version upgrades. 0.47 \u00b6 Updated deps, tested side-by-side with corda-lean-state 0.46 \u00b6 Fixed account resolution when using only name and host 0.42 - 0.45 \u00b6 VaultaireView annotation changes: Enhanced control of the generated Class name with name and nameSuffix attributes, check the KDoc The namedFields property has been renamed to includeNamedFields . The property is optional. An optional excludeNamedFields has been added. An optional viewFields property has been added as an array of VaultaireViewField , allowing more control like nullability. Generated views now implement VaultaireDto<T> where T is the (DTO) type generated by the parent annotation. Thus, views generated e.g. for a DTO will now include toPatched and toTargetType methods targeting the full DTO. DTO Companion\u2019s mapToDto was renamed to from . Services\u2019 queryBy no longer provides defaults for paging, sorting etc. to make different signatures in serviceHub , RPC etc. more accessible; they do have their uses e.g. in aggregate quries. In short expect you\u2019ll need queryBy(criteria, 1, 10) VS queryBy(criteria) for it to work as expected. 0.41 \u00b6 Minor view fixes 0.40 \u00b6 This is a release with BREAKING CHANGES. Annotations have been renamed: Previous Name New Name VaultaireGenerate VaultaireStateUtils VaultaireGenerateForDependency VaultaireStateUtilsMixin VaultaireGenerateDto VaultaireStateDto VaultaireGenerateDtoForDependency VaultaireStateDtoMixin VaultaireFlowInput VaultaireModelDto VaultaireFlowInputForDependency VaultaireModelDtoMixin VaultaireGenerateResponder VaultaireFlowResponder Class and file names of generated state-based DTOs use new suffixes: LiteDto has changed to StateClientDto Dto has changed to StateDto DTO generation strategies have been updated: DEFAULT is now CORDAPP_LOCAL_DTO LITE is now CORDAPP_CLIENT_DTO The default DTO strategy is now CORDAPP_CLIENT_DTO This release also brings new features: VaultaireModelDto and VaultaireModelDtoMixin are now focused in DTO generation for non-state models. The resulting class and file name suffix is ModelClientDto with support for the usual REST or otherwise client-friendly auto-conversion of Corda-specific types. All DTO-generating annotations now have a views: Array<VaultaireView> member, to allow additional classes to be generated, each with a subset of fields from the target state or model type. All DTO-generating annotations now have a nonDataClass: Boolean member, that should be set to true for target state or model types that are NOT data classes. 0.39 \u00b6 Added @VaultaireFlowInput and @VaultaireFlowInputForDependency to support generating REST-friendly DTOs and utils for non-state data classes. 0.38 \u00b6 Minor accounts update 0.37 \u00b6 RSQL support: removed =notnull= and refactored =null= to accept a boolean argument instead, according to the RSQL parser grammar. 0.36 \u00b6 RSQL improvements: Fixed =in= , =out= comparisons. Moved wildcard-based comparisons to dedicated =like= and =unlike= operators. The converterFactory parameter in VaultQueryCriteriaCondition.withRsql is now optional. 0.35 \u00b6 Added plugin for RSQL support. 0.34 \u00b6 Support DTO-only fields with mixins. 0.33 \u00b6 Upgraded to Corda 4.6, Partiture 0.15, Poolboy 0.4. 0.32 \u00b6 Added VaultaireAttachmentService as a utility for attaching Vaultaire\u2019s JAR to a transaction. 0.31 \u00b6 Updated corda-rpc-poolboy dependency. 0.30 \u00b6 Reverted to forcing root state status to criteria as Corda seems to have an issue with StateStatus.ALL . 0.29 \u00b6 Added ResultsPage as a REST-friendly alternative to Vault.Page combined with mapping from StateAndRef to either contract states or DTOs. Removed explicit state status from DSL criteria, applied root criterion last instead. 0.28 \u00b6 Fixed generated DTOs missing @CordaSerializable . (Service) Registry is now more accessible. Fixed service defaults parameter type from SimpleServiceDefaults to interface ServiceDefaults in NodeService, StateService and delegates. Fixed pool-based initialization of services from network service. 0.26-27 \u00b6 Bumped Corda to OS 4.5 Refactored to support RPC connection pooling based on Corda RPC PoolBoy 0.25 \u00b6 Bumped Corda to OS 4.4 Added support for \u201clite\u201d DTO strategy Added Query DSL root externalIds property to support querying the vault by Corda Account(s) 0.24 \u00b6 Added default parameter value false to VaultQueryCriteriaCondition.toCriteria(boolean) , so that aggregates are not ignored by default. 0.23 \u00b6 Fixed corda API design issue, where a secondary VaultCustomQueryCriteria \u2018s implicit/default status of UNCONSUMED (VS null) is applied, overriding the root DSL status 0.22 \u00b6 Bumped kotlin-utils, fixing issue with DTO generation including companion object members of the source type. 0.21 \u00b6 Bumped KotlinPoet, util versions Added @DefaultValue example in the docs 0.20 \u00b6 Added CordaSerializable annotation to generated DTOs Added ignoreProperties to VaultaireGenerateDto and VaultaireGenerateDtoForDependency , useful with derived/backed properties like participants 0.19 \u00b6 Added [NodeRpcConnection] interface and [StateServiceRpcConnectionDelegate] for libraries in need of more flexible [StateServiceDelegate] integration e.g. Corbeans/Spring or other IoC containers 0.18 \u00b6 Bumped deps i.e. Corda to OS 4.3 0.17 \u00b6 Added support for sorting based on standard attributes and aliases of those, i.e. enum values of Sort.CommonStateAttribute , Sort.VaultStateAttribute , Sort.LinearStateAttribute and Sort.FungibleStateAttribute . 0.16 \u00b6 Added copyAnnotationPackages property to VaultaireGenerateDto and VaultaireGenerateDtoForDependency . The property can be used to define a list of base packages for matching annotations to be copied automatically from a source ContractState to it\u2019s generated DTO. This is useful when replication of e.g. Jackson or Bean Validation annotations can be useful. 0.15 \u00b6 Replaced com.github.manosbatsis.vaultaire.dto.Dto and com.github.manosbatsis.vaultaire.util.DtoInsufficientStateMappingException with kotlin-utils equivalents extracted there. You may need to update package/method names in your code if you make use of generated DTOs. 0.14 \u00b6 Vaultaire\u2019s *ForDependency annotations now use the annotated element\u2019s package (suffixed with .generated ) for output. This leaves the original (state) packages exclusive to their modules if needed, avoiding when cordapp package conflicts while testing. 0.13 \u00b6 Add support for final responder flow supertypes in VaultaireGenerateResponder 0.12 \u00b6 Fixed dependency scope for kotlin-utils 0.11 \u00b6 Added VaultaireGenerateDto , VaultaireGenerateDtoForDependency annotations for generating DTOs for contract states Added VaultaireGenerateResponder annotation for generating responder flows extending common supertypes Refactored to extract kotlin-utils 0.10 \u00b6 Added @VaultaireGenerateForDependency to support generation (of DSL, Services etc.) for states contributed to the classpath by project dependencies Enhanced generated subclasses of ExtendedStateService with DSL-aware buildQuery , queryBy and trackBy Fixed typo from VaultaireGenerate.constractStateType to VaultaireGenerate.contractStateType 0.9 \u00b6 0.8 re-release fix 0.8 \u00b6 Allow annotation processing to generate code to another Gradle module or location using the kapt.kotlin.vaultaire.generated kapt argument, see installation docs. 0.7 \u00b6 Fixed, improved and added tests for StateService get/find by id/externalId methods StateService get by id/externalId will throw a StateNotFoundException when no match is found 0.6 \u00b6 Added support for aggregate functions . Added getByExternalId and findByExternalId methods to StateService Added optional Vault.RelevancyStatus parameter to StateService getByLinearId and findByLinearId methods 0.5 \u00b6 Removed param from String.asUniqueIdentifier() 0.4 \u00b6 Fixed handling of nullable fields Added string input signatures for getByLinearId , findByLinearId 0.3 \u00b6 Refactored StateService to an interface 0.2 \u00b6 Renamed VaultQueryDsl annotation to VaultaireGenerate Renamed StateService to BasicStateService , added extended StateService type. The annotation processor will now generate a subclass of StateService per annotated PersistentState 0.1 \u00b6 Initial release","title":"Change Log"},{"location":"changelog/#changelog","text":"The following sections describe major changes per version and can be helpful with version upgrades.","title":"Changelog"},{"location":"changelog/#047","text":"Updated deps, tested side-by-side with corda-lean-state","title":"0.47"},{"location":"changelog/#046","text":"Fixed account resolution when using only name and host","title":"0.46"},{"location":"changelog/#042-045","text":"VaultaireView annotation changes: Enhanced control of the generated Class name with name and nameSuffix attributes, check the KDoc The namedFields property has been renamed to includeNamedFields . The property is optional. An optional excludeNamedFields has been added. An optional viewFields property has been added as an array of VaultaireViewField , allowing more control like nullability. Generated views now implement VaultaireDto<T> where T is the (DTO) type generated by the parent annotation. Thus, views generated e.g. for a DTO will now include toPatched and toTargetType methods targeting the full DTO. DTO Companion\u2019s mapToDto was renamed to from . Services\u2019 queryBy no longer provides defaults for paging, sorting etc. to make different signatures in serviceHub , RPC etc. more accessible; they do have their uses e.g. in aggregate quries. In short expect you\u2019ll need queryBy(criteria, 1, 10) VS queryBy(criteria) for it to work as expected.","title":"0.42 - 0.45"},{"location":"changelog/#041","text":"Minor view fixes","title":"0.41"},{"location":"changelog/#040","text":"This is a release with BREAKING CHANGES. Annotations have been renamed: Previous Name New Name VaultaireGenerate VaultaireStateUtils VaultaireGenerateForDependency VaultaireStateUtilsMixin VaultaireGenerateDto VaultaireStateDto VaultaireGenerateDtoForDependency VaultaireStateDtoMixin VaultaireFlowInput VaultaireModelDto VaultaireFlowInputForDependency VaultaireModelDtoMixin VaultaireGenerateResponder VaultaireFlowResponder Class and file names of generated state-based DTOs use new suffixes: LiteDto has changed to StateClientDto Dto has changed to StateDto DTO generation strategies have been updated: DEFAULT is now CORDAPP_LOCAL_DTO LITE is now CORDAPP_CLIENT_DTO The default DTO strategy is now CORDAPP_CLIENT_DTO This release also brings new features: VaultaireModelDto and VaultaireModelDtoMixin are now focused in DTO generation for non-state models. The resulting class and file name suffix is ModelClientDto with support for the usual REST or otherwise client-friendly auto-conversion of Corda-specific types. All DTO-generating annotations now have a views: Array<VaultaireView> member, to allow additional classes to be generated, each with a subset of fields from the target state or model type. All DTO-generating annotations now have a nonDataClass: Boolean member, that should be set to true for target state or model types that are NOT data classes.","title":"0.40"},{"location":"changelog/#039","text":"Added @VaultaireFlowInput and @VaultaireFlowInputForDependency to support generating REST-friendly DTOs and utils for non-state data classes.","title":"0.39"},{"location":"changelog/#038","text":"Minor accounts update","title":"0.38"},{"location":"changelog/#037","text":"RSQL support: removed =notnull= and refactored =null= to accept a boolean argument instead, according to the RSQL parser grammar.","title":"0.37"},{"location":"changelog/#036","text":"RSQL improvements: Fixed =in= , =out= comparisons. Moved wildcard-based comparisons to dedicated =like= and =unlike= operators. The converterFactory parameter in VaultQueryCriteriaCondition.withRsql is now optional.","title":"0.36"},{"location":"changelog/#035","text":"Added plugin for RSQL support.","title":"0.35"},{"location":"changelog/#034","text":"Support DTO-only fields with mixins.","title":"0.34"},{"location":"changelog/#033","text":"Upgraded to Corda 4.6, Partiture 0.15, Poolboy 0.4.","title":"0.33"},{"location":"changelog/#032","text":"Added VaultaireAttachmentService as a utility for attaching Vaultaire\u2019s JAR to a transaction.","title":"0.32"},{"location":"changelog/#031","text":"Updated corda-rpc-poolboy dependency.","title":"0.31"},{"location":"changelog/#030","text":"Reverted to forcing root state status to criteria as Corda seems to have an issue with StateStatus.ALL .","title":"0.30"},{"location":"changelog/#029","text":"Added ResultsPage as a REST-friendly alternative to Vault.Page combined with mapping from StateAndRef to either contract states or DTOs. Removed explicit state status from DSL criteria, applied root criterion last instead.","title":"0.29"},{"location":"changelog/#028","text":"Fixed generated DTOs missing @CordaSerializable . (Service) Registry is now more accessible. Fixed service defaults parameter type from SimpleServiceDefaults to interface ServiceDefaults in NodeService, StateService and delegates. Fixed pool-based initialization of services from network service.","title":"0.28"},{"location":"changelog/#026-27","text":"Bumped Corda to OS 4.5 Refactored to support RPC connection pooling based on Corda RPC PoolBoy","title":"0.26-27"},{"location":"changelog/#025","text":"Bumped Corda to OS 4.4 Added support for \u201clite\u201d DTO strategy Added Query DSL root externalIds property to support querying the vault by Corda Account(s)","title":"0.25"},{"location":"changelog/#024","text":"Added default parameter value false to VaultQueryCriteriaCondition.toCriteria(boolean) , so that aggregates are not ignored by default.","title":"0.24"},{"location":"changelog/#023","text":"Fixed corda API design issue, where a secondary VaultCustomQueryCriteria \u2018s implicit/default status of UNCONSUMED (VS null) is applied, overriding the root DSL status","title":"0.23"},{"location":"changelog/#022","text":"Bumped kotlin-utils, fixing issue with DTO generation including companion object members of the source type.","title":"0.22"},{"location":"changelog/#021","text":"Bumped KotlinPoet, util versions Added @DefaultValue example in the docs","title":"0.21"},{"location":"changelog/#020","text":"Added CordaSerializable annotation to generated DTOs Added ignoreProperties to VaultaireGenerateDto and VaultaireGenerateDtoForDependency , useful with derived/backed properties like participants","title":"0.20"},{"location":"changelog/#019","text":"Added [NodeRpcConnection] interface and [StateServiceRpcConnectionDelegate] for libraries in need of more flexible [StateServiceDelegate] integration e.g. Corbeans/Spring or other IoC containers","title":"0.19"},{"location":"changelog/#018","text":"Bumped deps i.e. Corda to OS 4.3","title":"0.18"},{"location":"changelog/#017","text":"Added support for sorting based on standard attributes and aliases of those, i.e. enum values of Sort.CommonStateAttribute , Sort.VaultStateAttribute , Sort.LinearStateAttribute and Sort.FungibleStateAttribute .","title":"0.17"},{"location":"changelog/#016","text":"Added copyAnnotationPackages property to VaultaireGenerateDto and VaultaireGenerateDtoForDependency . The property can be used to define a list of base packages for matching annotations to be copied automatically from a source ContractState to it\u2019s generated DTO. This is useful when replication of e.g. Jackson or Bean Validation annotations can be useful.","title":"0.16"},{"location":"changelog/#015","text":"Replaced com.github.manosbatsis.vaultaire.dto.Dto and com.github.manosbatsis.vaultaire.util.DtoInsufficientStateMappingException with kotlin-utils equivalents extracted there. You may need to update package/method names in your code if you make use of generated DTOs.","title":"0.15"},{"location":"changelog/#014","text":"Vaultaire\u2019s *ForDependency annotations now use the annotated element\u2019s package (suffixed with .generated ) for output. This leaves the original (state) packages exclusive to their modules if needed, avoiding when cordapp package conflicts while testing.","title":"0.14"},{"location":"changelog/#013","text":"Add support for final responder flow supertypes in VaultaireGenerateResponder","title":"0.13"},{"location":"changelog/#012","text":"Fixed dependency scope for kotlin-utils","title":"0.12"},{"location":"changelog/#011","text":"Added VaultaireGenerateDto , VaultaireGenerateDtoForDependency annotations for generating DTOs for contract states Added VaultaireGenerateResponder annotation for generating responder flows extending common supertypes Refactored to extract kotlin-utils","title":"0.11"},{"location":"changelog/#010","text":"Added @VaultaireGenerateForDependency to support generation (of DSL, Services etc.) for states contributed to the classpath by project dependencies Enhanced generated subclasses of ExtendedStateService with DSL-aware buildQuery , queryBy and trackBy Fixed typo from VaultaireGenerate.constractStateType to VaultaireGenerate.contractStateType","title":"0.10"},{"location":"changelog/#09","text":"0.8 re-release fix","title":"0.9"},{"location":"changelog/#08","text":"Allow annotation processing to generate code to another Gradle module or location using the kapt.kotlin.vaultaire.generated kapt argument, see installation docs.","title":"0.8"},{"location":"changelog/#07","text":"Fixed, improved and added tests for StateService get/find by id/externalId methods StateService get by id/externalId will throw a StateNotFoundException when no match is found","title":"0.7"},{"location":"changelog/#06","text":"Added support for aggregate functions . Added getByExternalId and findByExternalId methods to StateService Added optional Vault.RelevancyStatus parameter to StateService getByLinearId and findByLinearId methods","title":"0.6"},{"location":"changelog/#05","text":"Removed param from String.asUniqueIdentifier()","title":"0.5"},{"location":"changelog/#04","text":"Fixed handling of nullable fields Added string input signatures for getByLinearId , findByLinearId","title":"0.4"},{"location":"changelog/#03","text":"Refactored StateService to an interface","title":"0.3"},{"location":"changelog/#02","text":"Renamed VaultQueryDsl annotation to VaultaireGenerate Renamed StateService to BasicStateService , added extended StateService type. The annotation processor will now generate a subclass of StateService per annotated PersistentState","title":"0.2"},{"location":"changelog/#01","text":"Initial release","title":"0.1"},{"location":"credits/","text":"Credits \u00b6 The following projects where of great help in creating my first DSL: AutoDsl , SqlDsl . Annotation processing is of course based on KotlinPoet . The RSQL module depends on the lovely jirutka/rsql:rsql-parser .","title":"Credits"},{"location":"credits/#credits","text":"The following projects where of great help in creating my first DSL: AutoDsl , SqlDsl . Annotation processing is of course based on KotlinPoet . The RSQL module depends on the lovely jirutka/rsql:rsql-parser .","title":"Credits"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 Answers to common questions. License: Can I use Vaultaire with my project? \u00b6 Yes, Vaultaire can be used as a library/dependency with no side-effect to your project. Vaultaire is distributed under the GNU Lesser General Public License or LGPL, the same license adopted by Corda dependencies like Hibernate. Use with Corda Enterprise \u00b6 To use Vaultaire with Corda Enterprise, you will have to update your build to use the CE release . After switching to the appropriate corda_release_group and corda_release_version in your ext section, you can instruct your build to substitute transitive Corda OS dependencies with their CE equivalents: allprojects { //... configurations { all { //... resolutionStrategy { // ... eachDependency { DependencyResolveDetails details -> // Exclude from substitutions as appropriate, e.g. def exclusions = [ 'corda-finance-contracts' ] // Substitute the rest, assumes `ext.corda_release_group` and `ext.corda_release_version` are set if ( details . requested . group == \"net.corda\" && ! exclusions . contains ( details . requested . name )) { // Force Corda Enterprise details . useTarget group: corda_release_group , name: details . requested . name , version: corda_release_version } } } } } } Note : The above assumes ext.corda_release_group and ext.corda_release_version are already set, e.g. to com.r3.corda and 4.2 respectively.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"Answers to common questions.","title":"Frequently Asked Questions"},{"location":"faq/#license-can-i-use-vaultaire-with-my-project","text":"Yes, Vaultaire can be used as a library/dependency with no side-effect to your project. Vaultaire is distributed under the GNU Lesser General Public License or LGPL, the same license adopted by Corda dependencies like Hibernate.","title":"License: Can I use Vaultaire with my project?"},{"location":"faq/#use-with-corda-enterprise","text":"To use Vaultaire with Corda Enterprise, you will have to update your build to use the CE release . After switching to the appropriate corda_release_group and corda_release_version in your ext section, you can instruct your build to substitute transitive Corda OS dependencies with their CE equivalents: allprojects { //... configurations { all { //... resolutionStrategy { // ... eachDependency { DependencyResolveDetails details -> // Exclude from substitutions as appropriate, e.g. def exclusions = [ 'corda-finance-contracts' ] // Substitute the rest, assumes `ext.corda_release_group` and `ext.corda_release_version` are set if ( details . requested . group == \"net.corda\" && ! exclusions . contains ( details . requested . name )) { // Force Corda Enterprise details . useTarget group: corda_release_group , name: details . requested . name , version: corda_release_version } } } } } } Note : The above assumes ext.corda_release_group and ext.corda_release_version are already set, e.g. to com.r3.corda and 4.2 respectively.","title":"Use with Corda Enterprise"},{"location":"installation/","text":"Installation \u00b6 For Cordapps \u00b6 Step 1: Add to your Cordapp\u2019s Gradle dependencies: // apply the kapt plugin apply plugin: 'kotlin-kapt' // Optional: for IntelliJ users, see also sourceSets bellow apply plugin: \"idea\" dependencies { // Core dependency cordaCompile \"com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version\" // Annotation processing kapt \"com.github.manosbatsis.vaultaire:vaultaire-processor:$vaultaire_version\" // Corda dependencies etc. // ... } Alternatively, you might want to add Vaultaire in the Cordapp\u2019s fat JAR, in which case use compile instead of cordacompile and skip step 2 bellow. Step 2: Add Vaultaire and Kotlin Utils as Cordapps to your deployNodes task: // Use Vaultaire for query DSL, DTOs and services generation cordapp \"com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version\" cordapp ( \"com.github.manosbatsis.kotlin-utils:kotlin-utils-api:$kotlinutils_version\" ) Step 3: You may also want to add the generated sources to your build\u2019s sourceSets // Define an extra sources variable def generatedSourcesDir = project . file ( \"build/generated/source/kaptKotlin/main\" ) // Tell Gradle about the extra source set sourceSets { main { kotlin . srcDirs += generatedSourcesDir } } // Optional: Tell IntelliJ about the extra source set idea { module { sourceDirs += generatedSourcesDir generatedSourceDirs += generatedSourcesDir } } Note that setting kotlin.incremental=true in gradle.properties may break non-clean builds earlier versions of kotlin like 1.2.71 - if you enable incremental then you\u2019ll need to ./gradlew clean when building. For Client Apps \u00b6 The core module can also be useful outside a cordapp, e.g. in a Spring application interacting with Corda nodes via RPC: // Core dependency compile \"com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version\" // Corda dependencies etc. // ...","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#for-cordapps","text":"Step 1: Add to your Cordapp\u2019s Gradle dependencies: // apply the kapt plugin apply plugin: 'kotlin-kapt' // Optional: for IntelliJ users, see also sourceSets bellow apply plugin: \"idea\" dependencies { // Core dependency cordaCompile \"com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version\" // Annotation processing kapt \"com.github.manosbatsis.vaultaire:vaultaire-processor:$vaultaire_version\" // Corda dependencies etc. // ... } Alternatively, you might want to add Vaultaire in the Cordapp\u2019s fat JAR, in which case use compile instead of cordacompile and skip step 2 bellow. Step 2: Add Vaultaire and Kotlin Utils as Cordapps to your deployNodes task: // Use Vaultaire for query DSL, DTOs and services generation cordapp \"com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version\" cordapp ( \"com.github.manosbatsis.kotlin-utils:kotlin-utils-api:$kotlinutils_version\" ) Step 3: You may also want to add the generated sources to your build\u2019s sourceSets // Define an extra sources variable def generatedSourcesDir = project . file ( \"build/generated/source/kaptKotlin/main\" ) // Tell Gradle about the extra source set sourceSets { main { kotlin . srcDirs += generatedSourcesDir } } // Optional: Tell IntelliJ about the extra source set idea { module { sourceDirs += generatedSourcesDir generatedSourceDirs += generatedSourcesDir } } Note that setting kotlin.incremental=true in gradle.properties may break non-clean builds earlier versions of kotlin like 1.2.71 - if you enable incremental then you\u2019ll need to ./gradlew clean when building.","title":"For Cordapps"},{"location":"installation/#for-client-apps","text":"The core module can also be useful outside a cordapp, e.g. in a Spring application interacting with Corda nodes via RPC: // Core dependency compile \"com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version\" // Corda dependencies etc. // ...","title":"For Client Apps"},{"location":"core/other-utils/","text":"Other Utilities \u00b6 Miscellaneous utilities provides by Vaultaire Generated Responders \u00b6 Some times you might want to use the same responding flow with multiple initiating flows. Since @InitiatedBy is not a repeatable annotation, the only option would be to subclass the same responder for each initiating flow, adding the appropriate @InitiatedBy . Vaultaire\u2019s annotation processor can help you automate this using a @VaultaireFlowResponder instead of maintaning such responders manually. Usage example: // or simply: @VaultaireFlowResponder(BaseBookFlowResponder::class) @VaultaireFlowResponder ( value = BaseBookFlowResponder :: class , comment = \"A basic responder to listen for finality\" ) @InitiatingFlow @StartableByRPC class CreateBookFlow ( input : BookMessage ) : FlowLogic < SignedTransaction > The above will automatically generate a responder flow: /** * A basic responder to listen for finality */ @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( otherPartySession : FlowSession ) : BaseBookFlowResponder ( otherPartySession ) Note : if the base responder flow is a final type, the generated responder will attempt to call it as a subflow instead of extending it: @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( val otherPartySession : FlowSession ) : FlowLogic < Unit > () { @Suspendable override fun call () { subFlow ( BaseBookFlowResponder ( otherPartySession )) } } Results Page \u00b6 The ResultsPage is a more REST-friendly alternative to Vault.Page . While it can be used to carry any type of results, it mainly focuses on mapping StateAndRef query results to either contract states or DTOs. Sample use: // Use a generated state service to query val vaultPage : Vault . Page < MyState > = stateService . queryBy ( criteria , pageSpecification , sort ) // As states val statesPage = ResultsPage . from ( vaultPage , pageSpecification , sort ) // As DTOs val dtosPage = ResultsPage . from ( vaultPage , pageSpecification , sort ) { stateAndRefs -> stateAndRefs . map { MyStateClientDto . from ( it . state . data , stateService ) } } Vaultaire JAR Attachment \u00b6 In some cases you may want to attach Vaultaire\u2019s JAR to a Corda transaction when creating a new accounts-aware state. VaultaireAttachmentService is a Corda service to do just that: // Obtain Vaultaire's JAR hash val vaultaireJarAttachment = serviceHub . cordaService ( VaultaireAttachmentService :: class . java ) . vaultaireSecureHash // Attach JAR to TX transactionBuilder . addAttachment ( vaultaireJarAttachment )","title":"Other Utilities"},{"location":"core/other-utils/#other-utilities","text":"Miscellaneous utilities provides by Vaultaire","title":"Other Utilities"},{"location":"core/other-utils/#generated-responders","text":"Some times you might want to use the same responding flow with multiple initiating flows. Since @InitiatedBy is not a repeatable annotation, the only option would be to subclass the same responder for each initiating flow, adding the appropriate @InitiatedBy . Vaultaire\u2019s annotation processor can help you automate this using a @VaultaireFlowResponder instead of maintaning such responders manually. Usage example: // or simply: @VaultaireFlowResponder(BaseBookFlowResponder::class) @VaultaireFlowResponder ( value = BaseBookFlowResponder :: class , comment = \"A basic responder to listen for finality\" ) @InitiatingFlow @StartableByRPC class CreateBookFlow ( input : BookMessage ) : FlowLogic < SignedTransaction > The above will automatically generate a responder flow: /** * A basic responder to listen for finality */ @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( otherPartySession : FlowSession ) : BaseBookFlowResponder ( otherPartySession ) Note : if the base responder flow is a final type, the generated responder will attempt to call it as a subflow instead of extending it: @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( val otherPartySession : FlowSession ) : FlowLogic < Unit > () { @Suspendable override fun call () { subFlow ( BaseBookFlowResponder ( otherPartySession )) } }","title":"Generated Responders"},{"location":"core/other-utils/#results-page","text":"The ResultsPage is a more REST-friendly alternative to Vault.Page . While it can be used to carry any type of results, it mainly focuses on mapping StateAndRef query results to either contract states or DTOs. Sample use: // Use a generated state service to query val vaultPage : Vault . Page < MyState > = stateService . queryBy ( criteria , pageSpecification , sort ) // As states val statesPage = ResultsPage . from ( vaultPage , pageSpecification , sort ) // As DTOs val dtosPage = ResultsPage . from ( vaultPage , pageSpecification , sort ) { stateAndRefs -> stateAndRefs . map { MyStateClientDto . from ( it . state . data , stateService ) } }","title":"Results Page"},{"location":"core/other-utils/#vaultaire-jar-attachment","text":"In some cases you may want to attach Vaultaire\u2019s JAR to a Corda transaction when creating a new accounts-aware state. VaultaireAttachmentService is a Corda service to do just that: // Obtain Vaultaire's JAR hash val vaultaireJarAttachment = serviceHub . cordaService ( VaultaireAttachmentService :: class . java ) . vaultaireSecureHash // Attach JAR to TX transactionBuilder . addAttachment ( vaultaireJarAttachment )","title":"Vaultaire JAR Attachment"},{"location":"core/query-dsl/","text":"Query DSL \u00b6 Vaultaire uses an annotation processor at build-time to create a query DSL for your contract/persistent states. Quick Example \u00b6 Consider the following Contract/Persistent States: /** Book ContractState */ data class BookState ( val publisher : Party , val author : Party , val title : String , val published : Date = Date () ) : ContractState , QueryableState { // ... } // Use Vaultaire's code generation! @VaultaireStateUtils ( name = \"booksQuery\" , contractStateType = BookState :: class ) @Entity @Table ( name = \"books\" ) data class PersistentBookState ( @Column ( name = \"publisher\" ) var publisher : String = \"\" , @Column ( name = \"author\" ) var author : String = \"\" , @Column ( name = \"title\" ) var title : String = \"\" , @Column ( name = \"published\" ) var published : Date ) : PersistentState () Before Vaultaire \u00b6 Before Vaultaire, you probably had to create query criteria with something like: val query = VaultQueryCriteria ( contractStateTypes = setOf ( BookState :: class . java ), status = Vault . StateStatus . ALL ) // Check publisher? if ( checkPublisher ) query = query . and ( VaultCustomQueryCriteria ( PersistentBookState :: publisher . equal ( \"Corda Books Ltd.\" ))) // Add more criteria query . and ( VaultCustomQueryCriteria ( PersistentBookState :: title . equal ( \"A book on Corda\" )) . or ( VaultCustomQueryCriteria ( PersistentBookState :: author . notEqual ( \"John Doe\" )))) val sort = Sort ( listOf ( Sort . SortColumn ( SortAttribute . Custom ( PersistentBookState :: class . java , \"published\" ), Sort . Direction . DESC ))) // Finally! queryBy ( query , sort ) A bit verbose so get\u2019s difficult to read as the query becomes more complex. Let\u2019s try to simplify things bellow. With Vaultaire DSL \u00b6 With Vaultaire\u2019s @VaultaireStateUtils and the generated DSL this becomes: // Use the generated DSL to create query criteria val query = booksQuery { status = Vault . StateStatus . ALL and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` \"Corda Books Ltd.\" or { fields . title ` == ` \"A book on Corda\" fields . author ` != ` \"John Doe\" } } orderBy { fields . title sort DESC } } queryBy ( query . toCriteria (), query . toSort ()) Create a DSL \u00b6 Project Module States \u00b6 To create a query DSL for your state after installing Vaultaire, annotate the corresponding PersistentState with @VaultaireStateUtils : // Use Vaultaire's DSL generation! @VaultaireStateUtils ( // If you omit the name, the DSL function will be named by appending \"Query\" // to the decapitalized contract state name, e.g. \"bookStateQuery\" name = \"booksQuery\" , contractStateType = BookState :: class ) @Entity @Table ( name = \"books\" ) data class PersistentBookState ( // state properties... ) : PersistentState () Project Dependency States \u00b6 To create a query DSL for a state from your project dependencies, annotate the any class in your project using the special @VaultaireStateUtilsFor annotation, providing the state\u2019s ContractState and PersistentState : @VaultaireStateUtilsMixin ( name = \"fungibleTokenConditions\" , persistentStateType = PersistentFungibleToken :: class , contractStateType = FungibleToken :: class ) class FungibleMixin Query Settings \u00b6 The generated DSL allows setting QueryCriteria.VaultQueryCriteria members. Here\u2019s an example using the defaults: val query = booksQuery { // settings status = Vault . StateStatus . UNCONSUMED stateRefs = null notary = null softLockingCondition = null timeCondition = null relevancyStatus = Vault . RelevancyStatus . ALL constraintTypes = emptySet () constraints = emptySet () participants = null // criteria and sorting... } Adding Criteria \u00b6 Query riteria are defined within the and / or functions. Both functions can be nested and mixed with criteria like: val query = booksQuery { // settings... // criteria or { // Match at least one fields . foo1 ` == ` someValue and { // Match all fields . foo1 . isNull () fields . foo2 ` == ` someOtherValue and { // ... } or { // ... } } } // sorting... } Adding Aggregates \u00b6 Aggregates can be specified within the and / or functions: val bookStateQuery = bookStateQuery { // settings... // criteria and { fields . title `like` \"%Corda Foundation%\" fields . genre ` == ` BookContract . BookGenre . SCIENCE_FICTION } // aggregates aggregate { // add some aggregates fields . externalId . count () fields . id . count () fields . editions . sum () fields . price . min () fields . price . avg () fields . price . max () } } Note : Corda paged queries can include either query results or \u201cother\u201d results based on the above aggregates. For that purpose, the toCriteria functions accepts an optional boolean to ignore aggregates, thus allowing the reuse of the same query to obtain either paged state or aggregate results. Accessing Fields \u00b6 Fields can be accessed via the generated DSL\u2019s fields object within and , or , or orderBy functions using dot notation e.g. fields.foo . You can also retrieve fields by name with e.g. fields[\"foo\"] or fields.get(\"foo\") and use non typesafe functions like _equal , _notEqual , _like , _notLike but this may change in a future release. Functions and Operators \u00b6 Name Aliases Examples isNull fields.foo.isNull() notNull fields.foo.notNull() equal `==` fields.foo `==` bar fields.foo equal bar fields.foo.equal(bar) notEqual `!=` fields.foo `!=` bar fields.foo notEqual bar fields.foo.notEqual(bar) lessThan lt fields.foo lt bar fields.foo lessThan bar fields.foo.lessThan(bar) lessThanOrEqual lte fields.foo lte bar fields.foo lessThanOrEqual bar fields.foo.lessThanOrEqual(bar) greaterThan gt fields.foo gt bar fields.foo greaterThan bar fields.foo.greaterThan(bar) greaterThanOrEqual gte fields.foo gte bar fields.foo greaterThanOrEqual bar fields.foo.greaterThanOrEqual(bar) between btw fields.foo btw Pair(bar1, bar2) fields.foo between Pair(bar1, bar2) fields.foo.between(bar1, bar2) like fields.foo like bar fields.foo.like(bar) notLike fields.foo notLike bar fields.foo.notLike(bar) isIn `in` fields.foo `in` bars fields.foo isIn bars fields.foo.isIn(bars) notIn `!in` fields.foo `!in` bars fields.foo notIn bars fields.foo.notIn(bars) Aggregate Functions \u00b6 Name Examples avg fields.foo.avg() fields.foo.avg(groupByColumns) fields.foo.avg(groupByColumns, sortDirection) count fields.foo.count() max fields.foo.max() fields.foo.max(groupByColumns) fields.foo.max(groupByColumns, sortDirection) min fields.foo.min() fields.foo.min(groupByColumns) fields.foo.min(groupByColumns, sortDirection) sum fields.foo.sum() fields.foo.sum(groupByColumns) fields.foo.sum(groupByColumns, sortDirection) Sorting \u00b6 Sorting is defined using the orderBy function. Both custom fields and standard attributes are supported, while aliases for standard attributes are provided for convenience: val criteria = bookConditions { // settings and criteria... // sorting orderBy { // Sort by standard attribute alias, same as // Sort.VaultStateAttribute.RECORDED_TIME sort ASC recordedTime sort ASC // Sort by custom field fields . title sort DESC } } The following standard attribute aliases are provided: Alias Standard Attribute stateRef Sort.CommonStateAttribute.STATE_REF stateRefTxnId Sort.CommonStateAttribute.STATE_REF_TXN_ID stateRefIndex Sort.CommonStateAttribute.STATE_REF_INDEX notaryName Sort.VaultStateAttribute.NOTARY_NAME contractStateType Sort.VaultStateAttribute.CONTRACT_STATE_TYPE stateStatus Sort.VaultStateAttribute.STATE_STATUS recordedTime Sort.VaultStateAttribute.RECORDED_TIME consumedTime Sort.VaultStateAttribute.CONSUMED_TIME lockId Sort.VaultStateAttribute.LOCK_ID constraintType Sort.VaultStateAttribute.CONSTRAINT_TYPE uuid Sort.LinearStateAttribute.UUID externalId Sort.LinearStateAttribute.EXTERNAL_ID quantity Sort.FungibleStateAttribute.QUANTITY issuerRef Sort.FungibleStateAttribute.ISSUER_REF","title":"Query DSL"},{"location":"core/query-dsl/#query-dsl","text":"Vaultaire uses an annotation processor at build-time to create a query DSL for your contract/persistent states.","title":"Query DSL"},{"location":"core/query-dsl/#quick-example","text":"Consider the following Contract/Persistent States: /** Book ContractState */ data class BookState ( val publisher : Party , val author : Party , val title : String , val published : Date = Date () ) : ContractState , QueryableState { // ... } // Use Vaultaire's code generation! @VaultaireStateUtils ( name = \"booksQuery\" , contractStateType = BookState :: class ) @Entity @Table ( name = \"books\" ) data class PersistentBookState ( @Column ( name = \"publisher\" ) var publisher : String = \"\" , @Column ( name = \"author\" ) var author : String = \"\" , @Column ( name = \"title\" ) var title : String = \"\" , @Column ( name = \"published\" ) var published : Date ) : PersistentState ()","title":"Quick Example"},{"location":"core/query-dsl/#before-vaultaire","text":"Before Vaultaire, you probably had to create query criteria with something like: val query = VaultQueryCriteria ( contractStateTypes = setOf ( BookState :: class . java ), status = Vault . StateStatus . ALL ) // Check publisher? if ( checkPublisher ) query = query . and ( VaultCustomQueryCriteria ( PersistentBookState :: publisher . equal ( \"Corda Books Ltd.\" ))) // Add more criteria query . and ( VaultCustomQueryCriteria ( PersistentBookState :: title . equal ( \"A book on Corda\" )) . or ( VaultCustomQueryCriteria ( PersistentBookState :: author . notEqual ( \"John Doe\" )))) val sort = Sort ( listOf ( Sort . SortColumn ( SortAttribute . Custom ( PersistentBookState :: class . java , \"published\" ), Sort . Direction . DESC ))) // Finally! queryBy ( query , sort ) A bit verbose so get\u2019s difficult to read as the query becomes more complex. Let\u2019s try to simplify things bellow.","title":"Before Vaultaire"},{"location":"core/query-dsl/#with-vaultaire-dsl","text":"With Vaultaire\u2019s @VaultaireStateUtils and the generated DSL this becomes: // Use the generated DSL to create query criteria val query = booksQuery { status = Vault . StateStatus . ALL and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` \"Corda Books Ltd.\" or { fields . title ` == ` \"A book on Corda\" fields . author ` != ` \"John Doe\" } } orderBy { fields . title sort DESC } } queryBy ( query . toCriteria (), query . toSort ())","title":"With Vaultaire DSL"},{"location":"core/query-dsl/#create-a-dsl","text":"","title":"Create a DSL"},{"location":"core/query-dsl/#project-module-states","text":"To create a query DSL for your state after installing Vaultaire, annotate the corresponding PersistentState with @VaultaireStateUtils : // Use Vaultaire's DSL generation! @VaultaireStateUtils ( // If you omit the name, the DSL function will be named by appending \"Query\" // to the decapitalized contract state name, e.g. \"bookStateQuery\" name = \"booksQuery\" , contractStateType = BookState :: class ) @Entity @Table ( name = \"books\" ) data class PersistentBookState ( // state properties... ) : PersistentState ()","title":"Project Module States"},{"location":"core/query-dsl/#project-dependency-states","text":"To create a query DSL for a state from your project dependencies, annotate the any class in your project using the special @VaultaireStateUtilsFor annotation, providing the state\u2019s ContractState and PersistentState : @VaultaireStateUtilsMixin ( name = \"fungibleTokenConditions\" , persistentStateType = PersistentFungibleToken :: class , contractStateType = FungibleToken :: class ) class FungibleMixin","title":"Project Dependency States"},{"location":"core/query-dsl/#query-settings","text":"The generated DSL allows setting QueryCriteria.VaultQueryCriteria members. Here\u2019s an example using the defaults: val query = booksQuery { // settings status = Vault . StateStatus . UNCONSUMED stateRefs = null notary = null softLockingCondition = null timeCondition = null relevancyStatus = Vault . RelevancyStatus . ALL constraintTypes = emptySet () constraints = emptySet () participants = null // criteria and sorting... }","title":"Query Settings"},{"location":"core/query-dsl/#adding-criteria","text":"Query riteria are defined within the and / or functions. Both functions can be nested and mixed with criteria like: val query = booksQuery { // settings... // criteria or { // Match at least one fields . foo1 ` == ` someValue and { // Match all fields . foo1 . isNull () fields . foo2 ` == ` someOtherValue and { // ... } or { // ... } } } // sorting... }","title":"Adding Criteria"},{"location":"core/query-dsl/#adding-aggregates","text":"Aggregates can be specified within the and / or functions: val bookStateQuery = bookStateQuery { // settings... // criteria and { fields . title `like` \"%Corda Foundation%\" fields . genre ` == ` BookContract . BookGenre . SCIENCE_FICTION } // aggregates aggregate { // add some aggregates fields . externalId . count () fields . id . count () fields . editions . sum () fields . price . min () fields . price . avg () fields . price . max () } } Note : Corda paged queries can include either query results or \u201cother\u201d results based on the above aggregates. For that purpose, the toCriteria functions accepts an optional boolean to ignore aggregates, thus allowing the reuse of the same query to obtain either paged state or aggregate results.","title":"Adding Aggregates"},{"location":"core/query-dsl/#accessing-fields","text":"Fields can be accessed via the generated DSL\u2019s fields object within and , or , or orderBy functions using dot notation e.g. fields.foo . You can also retrieve fields by name with e.g. fields[\"foo\"] or fields.get(\"foo\") and use non typesafe functions like _equal , _notEqual , _like , _notLike but this may change in a future release.","title":"Accessing Fields"},{"location":"core/query-dsl/#functions-and-operators","text":"Name Aliases Examples isNull fields.foo.isNull() notNull fields.foo.notNull() equal `==` fields.foo `==` bar fields.foo equal bar fields.foo.equal(bar) notEqual `!=` fields.foo `!=` bar fields.foo notEqual bar fields.foo.notEqual(bar) lessThan lt fields.foo lt bar fields.foo lessThan bar fields.foo.lessThan(bar) lessThanOrEqual lte fields.foo lte bar fields.foo lessThanOrEqual bar fields.foo.lessThanOrEqual(bar) greaterThan gt fields.foo gt bar fields.foo greaterThan bar fields.foo.greaterThan(bar) greaterThanOrEqual gte fields.foo gte bar fields.foo greaterThanOrEqual bar fields.foo.greaterThanOrEqual(bar) between btw fields.foo btw Pair(bar1, bar2) fields.foo between Pair(bar1, bar2) fields.foo.between(bar1, bar2) like fields.foo like bar fields.foo.like(bar) notLike fields.foo notLike bar fields.foo.notLike(bar) isIn `in` fields.foo `in` bars fields.foo isIn bars fields.foo.isIn(bars) notIn `!in` fields.foo `!in` bars fields.foo notIn bars fields.foo.notIn(bars)","title":"Functions and Operators"},{"location":"core/query-dsl/#aggregate-functions","text":"Name Examples avg fields.foo.avg() fields.foo.avg(groupByColumns) fields.foo.avg(groupByColumns, sortDirection) count fields.foo.count() max fields.foo.max() fields.foo.max(groupByColumns) fields.foo.max(groupByColumns, sortDirection) min fields.foo.min() fields.foo.min(groupByColumns) fields.foo.min(groupByColumns, sortDirection) sum fields.foo.sum() fields.foo.sum(groupByColumns) fields.foo.sum(groupByColumns, sortDirection)","title":"Aggregate Functions"},{"location":"core/query-dsl/#sorting","text":"Sorting is defined using the orderBy function. Both custom fields and standard attributes are supported, while aliases for standard attributes are provided for convenience: val criteria = bookConditions { // settings and criteria... // sorting orderBy { // Sort by standard attribute alias, same as // Sort.VaultStateAttribute.RECORDED_TIME sort ASC recordedTime sort ASC // Sort by custom field fields . title sort DESC } } The following standard attribute aliases are provided: Alias Standard Attribute stateRef Sort.CommonStateAttribute.STATE_REF stateRefTxnId Sort.CommonStateAttribute.STATE_REF_TXN_ID stateRefIndex Sort.CommonStateAttribute.STATE_REF_INDEX notaryName Sort.VaultStateAttribute.NOTARY_NAME contractStateType Sort.VaultStateAttribute.CONTRACT_STATE_TYPE stateStatus Sort.VaultStateAttribute.STATE_STATUS recordedTime Sort.VaultStateAttribute.RECORDED_TIME consumedTime Sort.VaultStateAttribute.CONSUMED_TIME lockId Sort.VaultStateAttribute.LOCK_ID constraintType Sort.VaultStateAttribute.CONSTRAINT_TYPE uuid Sort.LinearStateAttribute.UUID externalId Sort.LinearStateAttribute.EXTERNAL_ID quantity Sort.FungibleStateAttribute.QUANTITY issuerRef Sort.FungibleStateAttribute.ISSUER_REF","title":"Sorting"},{"location":"core/state-dtos/","text":"State DTOs \u00b6 Overview \u00b6 Maintaining Data Transfer Objects for your contract states can be a mundane, error-prone task. Vaultaire\u2019s annotation processing automates this by (re)generating those DTOs for you. DTOs generation may require a VaultaireStateUtils annotation to be present for the target model/state. Usage Patterns \u00b6 A typical use for generated DTOs is messaging over HTTP REST or RPC as input and output of Corda Flows. The provided conversion utilities can be used to create, update or even patch ContractState types they correspond to. DTO to State \u00b6 To convert from DTO to state, use the DTO\u2019s toTargetType() method: // Using default strategy // ---------------------- // Get the DTO val dto1 : BookStateClientDto = //... // Convert to State val state1 : BookState = dto1 . toTargetType () // Using the default strategy // ---------------------- // Get the Service val stateService : BookStateService = //... // Get the 'client' DTO val dto2 : BookStateClientDto = // ... // Convert to State val state2 : BookState = dto2 . toTargetType ( stateService ) DTO as Patch Update \u00b6 DTOs can be used to transfer and apply a \u201cpatch\u201d to update an existing state: // Get the Service val stateService = BookStateService ( serviceHub_or_RPCOps ) // Load state from Node Vault val state : BookState = stateService . getByLinearId ( id ) // Apply DTO as patch // ---------------------- val patchedState1 : BookState = dto1 . toPatched ( state ) // Apply 'client' DTO as patch // ---------------------- val patchedState2 : BookState = dto2 . toPatched ( state , stateService ) State to DTO \u00b6 To convert from state to DTO, use the DTO\u2019s latter\u2019s alternative, state-based constructor: // Get the state val state : BookState = stateService . getByLinearId ( id ) // Convert to DTO val dto = BookStateClientDto . from ( state ) DTO Generation \u00b6 This section explains the annotations and strategies involved in generating DTOs. Annotations \u00b6 Local States \u00b6 To have Vaultaire generate DTOs for ContractState s within local (Gradle module) sources, annotate them with @VaultaireStateDto : @VaultaireStateDto ( // optional: properties to ignore ignoreProperties = [ \"foo\" ] , // optional, default is false includeParticipants = false ) data class BookState ( val publisher : Party , val author : Party , val price : BigDecimal , val genre : Genre , @DefaultValue ( \"1\" ) val editions : Int = 1 , val foo : String = \"foo1\" , val title : String = \"Uknown\" , val published : Date = Date (), @field : JsonProperty ( \"alias\" ) val alternativeTitle : String? = null , override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { /* ... */ } Dependency States \u00b6 To generate DTOs for ContractState s outside the sources in context, e.g. from a contract states module or a project dependency, create a \u201cmixin\u201d class as a placeholder and annotate it with @VaultaireStateDtoMixin . This approach might be preferred or necessary even for state sources in context or under your control, e.g. when having (the good practice of) separate cordapp modules for contracts/states and flows. Mixin example: @VaultaireStateDtoMixin ( persistentStateType = PersistentBookState :: class , contractStateType = BookState :: class , // optional: properties to ignore ignoreProperties = [ \"foo\" ] ) class BookStateMixin // just a placeholder for our annotation Non-State Models \u00b6 @VaultaireModelDto and @VaultaireModelDtoMixin can be used for generation of DTOs for regular, non-ContractState data classes. to similarly generate REST-friendly DTOs and conversion utils focused op Corda-related types like accounts etc. @VaultaireModelDtoMixin ( baseType = SomeModel :: class ) data class SomeModelMixin Views \u00b6 Some times using DTOs with a subset of the original state or model\u2019s members is desired. Vaultaire allows automating generation for those DTOs as well using the views property of the annotation in context. For example, to generate a MagazineStateClientDto as a DTO for MagazineState along with a couple of DTO Views like UpdatePartiesView and AddIssueView that include onle with only ( issues , published ) and ( issues , published ) respectively: @VaultaireStateUtilsMixin ( name = \"magazineConditions\" , persistentStateType = PersistentMagazineState :: class , contractStateType = MagazineState :: class ) @VaultaireStateDtoMixin ( persistentStateType = PersistentMagazineState :: class , contractStateType = MagazineState :: class , strategies = [ VaultaireDtoStrategyKeys . CORDAPP_LOCAL_DTO , VaultaireDtoStrategyKeys . CORDAPP_CLIENT_DTO ] , views = [ VaultaireView ( name = \"UpdatePartiesView\" , viewFields = [ VaultaireViewField ( name = \"author\" ), VaultaireViewField ( name = \"publisher\" ) ] ), VaultaireView ( name = \"AddIssueView\" , includeNamedFields = [ \"issues\" , \"published\" ] ) ] ) data class MagazineMixin ( @DefaultValue ( \"1\" ) var issues : Int , @DefaultValue ( \"Date()\" ) val published : Date , @DefaultValue ( \"UniqueIdentifier()\" ) val linearId : UniqueIdentifier , val customMixinField : Map < String , String > = emptyMap () ) The views property is available in @VaultaireStateDto , @VaultaireStateDtoMixin , @VaultaireModelDto and @VaultaireModelDtoMixin . Utility Annotations \u00b6 The @DefaultValue can be used to provide default property initializers. It can be used equally on either ContractState or \u201cmixin\u201d properties: @VaultaireStateUtilsMixin ( /*...*/ ) @VaultaireStateDtoMixin ( /*...*/ ) data class MagazineMixin ( @DefaultValue ( \"1\" ) var issues : Int , @DefaultValue ( \"Date()\" ) val published : Date , @DefaultValue ( \"UniqueIdentifier()\" ) val linearId : UniqueIdentifier ) Sample DTO \u00b6 Sample (state) client DTO: nullable var members and utilities to convert from/to or patch an instance of the target type: /** * A [MagazineContract.MagazineState]-specific * [com.github.manosbatsis.vaultaire.dto.VaultaireStateClientDto] implementation */ @CordaSerializable data class MagazineStateClientDto ( var publisher : AccountInfoStateClientDto? = null , var author : AccountInfoStateClientDto? = null , var price : BigDecimal? = null , var genre : MagazineContract . MagazineGenre ? = null , var issues : Int? = 1 , var title : String? = null , var published : Date? = Date (), var linearId : UniqueIdentifier? = UniqueIdentifier (), var customMixinField : Map < String , String >? = null ) : VaultaireAccountsAwareStateClientDto < MagazineContract . MagazineState > { /** * Create a patched copy of the given [MagazineContract.MagazineState] instance, * updated using this DTO's non-null properties. */ @Suspendable override fun toPatched ( original : MagazineContract . MagazineState , stateService : AccountsAwareStateService < MagazineContract . MagazineState > ): MagazineContract . MagazineState { val publisherResolved = stateService . toAccountPartyOrNull ( this . publisher , original . publisher ) val authorResolved = stateService . toAccountParty ( this . author , original . author ) val patched = original . copy ( publisher = publisherResolved , author = authorResolved , price = this . price ?: original . price , genre = this . genre ?: original . genre , issues = this . issues ?: original . issues , title = this . title ?: original . title , published = this . published ?: original . published , linearId = this . linearId ?: original . linearId ) return patched } /** * Create an instance of [MagazineContract.MagazineState], using this DTO's properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ @Suspendable override fun toTargetType ( stateService : AccountsAwareStateService < MagazineContract . MagazineState > ): MagazineContract . MagazineState { val publisherResolved = stateService . toAccountPartyOrNull ( this . publisher , null , false , \"publisher\" ) val authorResolved = stateService . toAccountParty ( this . author , null , false , \"author\" ) return MagazineContract . MagazineState ( publisher = publisherResolved , author = authorResolved , price = this . price ?: errNull ( \"price\" ), genre = this . genre ?: errNull ( \"genre\" ), issues = this . issues ?: errNull ( \"issues\" ), title = this . title ?: errNull ( \"title\" ), published = this . published ?: errNull ( \"published\" ), linearId = this . linearId ?: errNull ( \"linearId\" ) ) } companion object { /** * Create a new DTO instance using the given [MagazineContract.MagazineState] as source. */ @Suspendable fun from ( original : MagazineContract . MagazineState , stateService : AccountsAwareStateService < MagazineContract . MagazineState > ): MagazineStateClientDto { val publisherResolved = stateService . toAccountInfoClientDtoOrNull ( original . publisher ) val authorResolved = stateService . toAccountInfoClientDto ( original . author ) return MagazineStateClientDto ( publisher = publisherResolved , author = authorResolved , price = original . price , genre = original . genre , issues = original . issues , title = original . title , published = original . published , linearId = original . linearId ) } } } Strategies \u00b6 Both @VaultaireStateDto and @VaultaireStateDtoMixin support generation strategy hints. By default the strategy used is the REST-friendly VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO . The only additional strategy provided is VaultaireDtoStrategyKeys.CORDAPP_LOCAL_DTO that supports no type conversions. Using both, as in the following example, will generate separate DTOs for each. @VaultaireStateDto ( ignoreProperties = [ \"foo\" ] , strategies = [ VaultaireDtoStrategyKeys . CORDAPP_CLIENT_DTO , VaultaireDtoStrategyKeys . CORDAPP_LOCAL_DTO ] ) data class BookState ( //... ) : LinearState , QueryableState { //... }","title":"State DTOs"},{"location":"core/state-dtos/#state-dtos","text":"","title":"State DTOs"},{"location":"core/state-dtos/#overview","text":"Maintaining Data Transfer Objects for your contract states can be a mundane, error-prone task. Vaultaire\u2019s annotation processing automates this by (re)generating those DTOs for you. DTOs generation may require a VaultaireStateUtils annotation to be present for the target model/state.","title":"Overview"},{"location":"core/state-dtos/#usage-patterns","text":"A typical use for generated DTOs is messaging over HTTP REST or RPC as input and output of Corda Flows. The provided conversion utilities can be used to create, update or even patch ContractState types they correspond to.","title":"Usage Patterns"},{"location":"core/state-dtos/#dto-to-state","text":"To convert from DTO to state, use the DTO\u2019s toTargetType() method: // Using default strategy // ---------------------- // Get the DTO val dto1 : BookStateClientDto = //... // Convert to State val state1 : BookState = dto1 . toTargetType () // Using the default strategy // ---------------------- // Get the Service val stateService : BookStateService = //... // Get the 'client' DTO val dto2 : BookStateClientDto = // ... // Convert to State val state2 : BookState = dto2 . toTargetType ( stateService )","title":"DTO to State"},{"location":"core/state-dtos/#dto-as-patch-update","text":"DTOs can be used to transfer and apply a \u201cpatch\u201d to update an existing state: // Get the Service val stateService = BookStateService ( serviceHub_or_RPCOps ) // Load state from Node Vault val state : BookState = stateService . getByLinearId ( id ) // Apply DTO as patch // ---------------------- val patchedState1 : BookState = dto1 . toPatched ( state ) // Apply 'client' DTO as patch // ---------------------- val patchedState2 : BookState = dto2 . toPatched ( state , stateService )","title":"DTO as Patch Update"},{"location":"core/state-dtos/#state-to-dto","text":"To convert from state to DTO, use the DTO\u2019s latter\u2019s alternative, state-based constructor: // Get the state val state : BookState = stateService . getByLinearId ( id ) // Convert to DTO val dto = BookStateClientDto . from ( state )","title":"State to DTO"},{"location":"core/state-dtos/#dto-generation","text":"This section explains the annotations and strategies involved in generating DTOs.","title":"DTO Generation"},{"location":"core/state-dtos/#annotations","text":"","title":"Annotations"},{"location":"core/state-dtos/#local-states","text":"To have Vaultaire generate DTOs for ContractState s within local (Gradle module) sources, annotate them with @VaultaireStateDto : @VaultaireStateDto ( // optional: properties to ignore ignoreProperties = [ \"foo\" ] , // optional, default is false includeParticipants = false ) data class BookState ( val publisher : Party , val author : Party , val price : BigDecimal , val genre : Genre , @DefaultValue ( \"1\" ) val editions : Int = 1 , val foo : String = \"foo1\" , val title : String = \"Uknown\" , val published : Date = Date (), @field : JsonProperty ( \"alias\" ) val alternativeTitle : String? = null , override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { /* ... */ }","title":"Local States"},{"location":"core/state-dtos/#dependency-states","text":"To generate DTOs for ContractState s outside the sources in context, e.g. from a contract states module or a project dependency, create a \u201cmixin\u201d class as a placeholder and annotate it with @VaultaireStateDtoMixin . This approach might be preferred or necessary even for state sources in context or under your control, e.g. when having (the good practice of) separate cordapp modules for contracts/states and flows. Mixin example: @VaultaireStateDtoMixin ( persistentStateType = PersistentBookState :: class , contractStateType = BookState :: class , // optional: properties to ignore ignoreProperties = [ \"foo\" ] ) class BookStateMixin // just a placeholder for our annotation","title":"Dependency States"},{"location":"core/state-dtos/#non-state-models","text":"@VaultaireModelDto and @VaultaireModelDtoMixin can be used for generation of DTOs for regular, non-ContractState data classes. to similarly generate REST-friendly DTOs and conversion utils focused op Corda-related types like accounts etc. @VaultaireModelDtoMixin ( baseType = SomeModel :: class ) data class SomeModelMixin","title":"Non-State Models"},{"location":"core/state-dtos/#views","text":"Some times using DTOs with a subset of the original state or model\u2019s members is desired. Vaultaire allows automating generation for those DTOs as well using the views property of the annotation in context. For example, to generate a MagazineStateClientDto as a DTO for MagazineState along with a couple of DTO Views like UpdatePartiesView and AddIssueView that include onle with only ( issues , published ) and ( issues , published ) respectively: @VaultaireStateUtilsMixin ( name = \"magazineConditions\" , persistentStateType = PersistentMagazineState :: class , contractStateType = MagazineState :: class ) @VaultaireStateDtoMixin ( persistentStateType = PersistentMagazineState :: class , contractStateType = MagazineState :: class , strategies = [ VaultaireDtoStrategyKeys . CORDAPP_LOCAL_DTO , VaultaireDtoStrategyKeys . CORDAPP_CLIENT_DTO ] , views = [ VaultaireView ( name = \"UpdatePartiesView\" , viewFields = [ VaultaireViewField ( name = \"author\" ), VaultaireViewField ( name = \"publisher\" ) ] ), VaultaireView ( name = \"AddIssueView\" , includeNamedFields = [ \"issues\" , \"published\" ] ) ] ) data class MagazineMixin ( @DefaultValue ( \"1\" ) var issues : Int , @DefaultValue ( \"Date()\" ) val published : Date , @DefaultValue ( \"UniqueIdentifier()\" ) val linearId : UniqueIdentifier , val customMixinField : Map < String , String > = emptyMap () ) The views property is available in @VaultaireStateDto , @VaultaireStateDtoMixin , @VaultaireModelDto and @VaultaireModelDtoMixin .","title":"Views"},{"location":"core/state-dtos/#utility-annotations","text":"The @DefaultValue can be used to provide default property initializers. It can be used equally on either ContractState or \u201cmixin\u201d properties: @VaultaireStateUtilsMixin ( /*...*/ ) @VaultaireStateDtoMixin ( /*...*/ ) data class MagazineMixin ( @DefaultValue ( \"1\" ) var issues : Int , @DefaultValue ( \"Date()\" ) val published : Date , @DefaultValue ( \"UniqueIdentifier()\" ) val linearId : UniqueIdentifier )","title":"Utility Annotations"},{"location":"core/state-dtos/#sample-dto","text":"Sample (state) client DTO: nullable var members and utilities to convert from/to or patch an instance of the target type: /** * A [MagazineContract.MagazineState]-specific * [com.github.manosbatsis.vaultaire.dto.VaultaireStateClientDto] implementation */ @CordaSerializable data class MagazineStateClientDto ( var publisher : AccountInfoStateClientDto? = null , var author : AccountInfoStateClientDto? = null , var price : BigDecimal? = null , var genre : MagazineContract . MagazineGenre ? = null , var issues : Int? = 1 , var title : String? = null , var published : Date? = Date (), var linearId : UniqueIdentifier? = UniqueIdentifier (), var customMixinField : Map < String , String >? = null ) : VaultaireAccountsAwareStateClientDto < MagazineContract . MagazineState > { /** * Create a patched copy of the given [MagazineContract.MagazineState] instance, * updated using this DTO's non-null properties. */ @Suspendable override fun toPatched ( original : MagazineContract . MagazineState , stateService : AccountsAwareStateService < MagazineContract . MagazineState > ): MagazineContract . MagazineState { val publisherResolved = stateService . toAccountPartyOrNull ( this . publisher , original . publisher ) val authorResolved = stateService . toAccountParty ( this . author , original . author ) val patched = original . copy ( publisher = publisherResolved , author = authorResolved , price = this . price ?: original . price , genre = this . genre ?: original . genre , issues = this . issues ?: original . issues , title = this . title ?: original . title , published = this . published ?: original . published , linearId = this . linearId ?: original . linearId ) return patched } /** * Create an instance of [MagazineContract.MagazineState], using this DTO's properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ @Suspendable override fun toTargetType ( stateService : AccountsAwareStateService < MagazineContract . MagazineState > ): MagazineContract . MagazineState { val publisherResolved = stateService . toAccountPartyOrNull ( this . publisher , null , false , \"publisher\" ) val authorResolved = stateService . toAccountParty ( this . author , null , false , \"author\" ) return MagazineContract . MagazineState ( publisher = publisherResolved , author = authorResolved , price = this . price ?: errNull ( \"price\" ), genre = this . genre ?: errNull ( \"genre\" ), issues = this . issues ?: errNull ( \"issues\" ), title = this . title ?: errNull ( \"title\" ), published = this . published ?: errNull ( \"published\" ), linearId = this . linearId ?: errNull ( \"linearId\" ) ) } companion object { /** * Create a new DTO instance using the given [MagazineContract.MagazineState] as source. */ @Suspendable fun from ( original : MagazineContract . MagazineState , stateService : AccountsAwareStateService < MagazineContract . MagazineState > ): MagazineStateClientDto { val publisherResolved = stateService . toAccountInfoClientDtoOrNull ( original . publisher ) val authorResolved = stateService . toAccountInfoClientDto ( original . author ) return MagazineStateClientDto ( publisher = publisherResolved , author = authorResolved , price = original . price , genre = original . genre , issues = original . issues , title = original . title , published = original . published , linearId = original . linearId ) } } }","title":"Sample DTO"},{"location":"core/state-dtos/#strategies","text":"Both @VaultaireStateDto and @VaultaireStateDtoMixin support generation strategy hints. By default the strategy used is the REST-friendly VaultaireDtoStrategyKeys.CORDAPP_CLIENT_DTO . The only additional strategy provided is VaultaireDtoStrategyKeys.CORDAPP_LOCAL_DTO that supports no type conversions. Using both, as in the following example, will generate separate DTOs for each. @VaultaireStateDto ( ignoreProperties = [ \"foo\" ] , strategies = [ VaultaireDtoStrategyKeys . CORDAPP_CLIENT_DTO , VaultaireDtoStrategyKeys . CORDAPP_LOCAL_DTO ] ) data class BookState ( //... ) : LinearState , QueryableState { //... }","title":"Strategies"},{"location":"core/state-services/","text":"State Services \u00b6 Overview \u00b6 Vaultaire\u2019s StateService s provide a simple, consistent API to load, query and track vault states. StateService implementations are usually auto-generated at build time based on VaultaireStateUtils or VaultaireStateUtilsMixin annotations, i.e. specific to a single ContractState type. State Services can also decouple you code from ServiceHub and CordaRPCOps by providing constructors for either, thus helping increase code reuse between cordapps and their clients. They also support RPC connection pooling, i.e. provide a constructor that accepts a PoolBoy PoolBoyConnection . Basic Services \u00b6 Basic implementations of NodeService and StateService are more limited and/or less easy to use than generated ones but functional nevertheless: val bookStateService = BasicStateService ( serviceHubOrRpcOpsOrPoolBoy , BookContract . BookState :: class . java ) State Services \u00b6 Vaultaire\u2019s annotation processor will generate optimal StateService implementations, each specific to one of the ContractState - PersistentState pairs found at build-time based on the VaultaireStateUtils or VaultaireStateUtilsMixin annotations found in your code. Service classnames are based on the contract state classname, suffixed by \u201cService\u201d. Usage example: // Create an instance of the generated service type, // passing a ServiceHub, CordaRPCOps, NodeRpcConnection // or even a custom StateServiceDelegate val bookStateService = BookStateService ( serviceHub ) // Load a book bookStateService . getByLinearId ( identifier ) // Try finding one by UniqueIdentifier.externalId, // in this case an ISBN bookStateService . findByExternalId ( isbn ) // Count the book states that match our query criteria val booksCount = bookStateService . countBy ( queryCriteria ) // Query the vault for a results page of the same books val searchResultsPage : Vault . Page < BookState > = bookStateService . queryBy ( queryCriteria , // Optional PageSpecification or page number/size params page , // Optional Sort or vararg of Pair<String, Sort.Direction> sort ) // Track the vault for book events val trackResults = bookStateService . queryBy ( criteria ) Custom Services \u00b6 You can also subclass (or, perhaps preferably, use as delegates) generated service types or BasicNodeService , BasicStateService , ExtendedStateService etc. to create custom components. /** Extend the generated [BookStateService] */ class MyExtendedBookStateService ( delegate : StateServiceDelegate < BookState > ) : BookStateService ( delegate ){ // Add the appropriate constructors // to initialize per delegate type: /** [CordaRPCOps]-based constructor */ constructor ( rpcOps : CordaRPCOps , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceRpcDelegate ( rpcOps , BookState :: class . java , defaults )) /** [ServiceHub]-based constructor */ constructor ( serviceHub : ServiceHub , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceHubDelegate ( serviceHub , BookState :: class . java , defaults )) // Custom business methods... }","title":"State Services"},{"location":"core/state-services/#state-services","text":"","title":"State Services"},{"location":"core/state-services/#overview","text":"Vaultaire\u2019s StateService s provide a simple, consistent API to load, query and track vault states. StateService implementations are usually auto-generated at build time based on VaultaireStateUtils or VaultaireStateUtilsMixin annotations, i.e. specific to a single ContractState type. State Services can also decouple you code from ServiceHub and CordaRPCOps by providing constructors for either, thus helping increase code reuse between cordapps and their clients. They also support RPC connection pooling, i.e. provide a constructor that accepts a PoolBoy PoolBoyConnection .","title":"Overview"},{"location":"core/state-services/#basic-services","text":"Basic implementations of NodeService and StateService are more limited and/or less easy to use than generated ones but functional nevertheless: val bookStateService = BasicStateService ( serviceHubOrRpcOpsOrPoolBoy , BookContract . BookState :: class . java )","title":"Basic Services"},{"location":"core/state-services/#state-services_1","text":"Vaultaire\u2019s annotation processor will generate optimal StateService implementations, each specific to one of the ContractState - PersistentState pairs found at build-time based on the VaultaireStateUtils or VaultaireStateUtilsMixin annotations found in your code. Service classnames are based on the contract state classname, suffixed by \u201cService\u201d. Usage example: // Create an instance of the generated service type, // passing a ServiceHub, CordaRPCOps, NodeRpcConnection // or even a custom StateServiceDelegate val bookStateService = BookStateService ( serviceHub ) // Load a book bookStateService . getByLinearId ( identifier ) // Try finding one by UniqueIdentifier.externalId, // in this case an ISBN bookStateService . findByExternalId ( isbn ) // Count the book states that match our query criteria val booksCount = bookStateService . countBy ( queryCriteria ) // Query the vault for a results page of the same books val searchResultsPage : Vault . Page < BookState > = bookStateService . queryBy ( queryCriteria , // Optional PageSpecification or page number/size params page , // Optional Sort or vararg of Pair<String, Sort.Direction> sort ) // Track the vault for book events val trackResults = bookStateService . queryBy ( criteria )","title":"State Services"},{"location":"core/state-services/#custom-services","text":"You can also subclass (or, perhaps preferably, use as delegates) generated service types or BasicNodeService , BasicStateService , ExtendedStateService etc. to create custom components. /** Extend the generated [BookStateService] */ class MyExtendedBookStateService ( delegate : StateServiceDelegate < BookState > ) : BookStateService ( delegate ){ // Add the appropriate constructors // to initialize per delegate type: /** [CordaRPCOps]-based constructor */ constructor ( rpcOps : CordaRPCOps , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceRpcDelegate ( rpcOps , BookState :: class . java , defaults )) /** [ServiceHub]-based constructor */ constructor ( serviceHub : ServiceHub , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceHubDelegate ( serviceHub , BookState :: class . java , defaults )) // Custom business methods... }","title":"Custom Services"},{"location":"plugins/corda-accounts/","text":"Corda Accounts Plugin \u00b6 This plugin provides support for Corda Accounts to Vaultaire\u2019s runtime and build-time modules. Installation \u00b6 Add Vaultaire\u2019s plugin for Corda Accounts to your Cordapp\u2019s Gradle dependencies using compile, cordapp or cordaCompile to match the core Vaultaire dependency. cordaCompile \"com.github.manosbatsis.vaultaire:vaultaire-plugin-accounts:$vaultaire_version\" Depending on the above dependency type, you may also need to add the plugin to your client app and deployNodes dependency configuration. The plugin adds both new and enhanced versions of core component types. It also overrides Vaultaire\u2019s internal configuration options to effectively apply them. These include the default base types extended by components generated by the annotation processor. DTO Enhancements \u00b6 VaultaireAccountInfo Annotation \u00b6 The plugin introduces the VaultaireAccountInfo annotation as the means to mark participant or other properties of a ContractState that map to a Corda Account. Supported types include: AbstractParty AnonymousParty PublicKey AccountParty Using the annotation for the last one is optional. Accounts-Aware DTO Types \u00b6 The plugin also adds: AccountInfoStateDto as a convenient model that maps from app-level users or state properties (as supported by @VaultaireAccountInfo above) to Corda Accounts, i.e. AccountInfo states. AccountsAwareStateClientDto as the equivalent of REST/client-friendly equivalent,. All the above effectively provide the \u201clite\u201d DTO strategy with enhanced DTO<->state conversion and patching utilities, i.e. mainly with support for mapping between the applicable types (see @VaultaireAccountInfo ) and AccountInfoDto . As an example, consider the following state: data class MagazineState ( val publisher : AccountParty , @VaultaireAccountInfo val author : PublicKey , @VaultaireAccountInfo val editor : AbstractParty , //... override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { override val participants get () = listOf ( publisher . party , AbstractParty ( author ), editor ) //... } The generated client DTO for the above: data class MagazineStateClientDto ( var publisher : AccountInfoStateClientDto? = null , var author : AccountInfoStateClientDto? = null , var editor : AccountInfoStateClientDto? = null , //... var linearId : UniqueIdentifier? = null ) : AccountsAwareStateClientDto < BookContract . MagazineState > { //... } Query DSL Enhancements \u00b6 Corda 4.3 added the possibility to map any public key to an external id of type UUID. Corda Accounts uses this feature to map an account\u2019s key to the account\u2019s id. Thus, using externalIds creates query criteria aware of state participants, without the need to embed account identifiers within the state itself. This is now supported by the generated Query DSL for your contract state: val magazineStateQuery = magazineStateQuery { // Match participants using the following // AccountInfo identifiers externalIds = listOfNotNull ( publisher . identifier ) status = Vault . StateStatus . UNCONSUMED // the default // The rest of the query.. //... Service Enhancements \u00b6 The plugin also adds and applies various accounts-aware service types as replacements of their default equivalents, along with a number of utility methods around accounts. // Create an instance of the generated service type, // passing a ServiceHub, CordaRPCOps, NodeRpcConnection // or even a custom StateServiceDelegate val stateService = AccountInfoService ( serviceHub ) // Get the account that is already stored locally // and matching the given [id] if found, null otherwise val accountOrNull : AccountInfo? = stateService . findStoredAccount ( accountId ) ?: stateService . requestAccount ( accountId , accountHost ) // Get the account that is already stored locally // and matching the given [id] if found, null otherwise val account : AccountInfo = stateService . getStoredAccount ( accountId ) // Find accounts that are already stored locally // and match the given [criteria] val accountsPage : Vault . Page < AccountInfo > = stateService . findStoredAccounts ( queryCriteria ) // Create a public key for the given [accountInfo] */ val anonymousParty = stateService . createPublicKey ( accountInfo )","title":"Corda Accounts"},{"location":"plugins/corda-accounts/#corda-accounts-plugin","text":"This plugin provides support for Corda Accounts to Vaultaire\u2019s runtime and build-time modules.","title":"Corda Accounts Plugin"},{"location":"plugins/corda-accounts/#installation","text":"Add Vaultaire\u2019s plugin for Corda Accounts to your Cordapp\u2019s Gradle dependencies using compile, cordapp or cordaCompile to match the core Vaultaire dependency. cordaCompile \"com.github.manosbatsis.vaultaire:vaultaire-plugin-accounts:$vaultaire_version\" Depending on the above dependency type, you may also need to add the plugin to your client app and deployNodes dependency configuration. The plugin adds both new and enhanced versions of core component types. It also overrides Vaultaire\u2019s internal configuration options to effectively apply them. These include the default base types extended by components generated by the annotation processor.","title":"Installation"},{"location":"plugins/corda-accounts/#dto-enhancements","text":"","title":"DTO Enhancements"},{"location":"plugins/corda-accounts/#vaultaireaccountinfo-annotation","text":"The plugin introduces the VaultaireAccountInfo annotation as the means to mark participant or other properties of a ContractState that map to a Corda Account. Supported types include: AbstractParty AnonymousParty PublicKey AccountParty Using the annotation for the last one is optional.","title":"VaultaireAccountInfo Annotation"},{"location":"plugins/corda-accounts/#accounts-aware-dto-types","text":"The plugin also adds: AccountInfoStateDto as a convenient model that maps from app-level users or state properties (as supported by @VaultaireAccountInfo above) to Corda Accounts, i.e. AccountInfo states. AccountsAwareStateClientDto as the equivalent of REST/client-friendly equivalent,. All the above effectively provide the \u201clite\u201d DTO strategy with enhanced DTO<->state conversion and patching utilities, i.e. mainly with support for mapping between the applicable types (see @VaultaireAccountInfo ) and AccountInfoDto . As an example, consider the following state: data class MagazineState ( val publisher : AccountParty , @VaultaireAccountInfo val author : PublicKey , @VaultaireAccountInfo val editor : AbstractParty , //... override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { override val participants get () = listOf ( publisher . party , AbstractParty ( author ), editor ) //... } The generated client DTO for the above: data class MagazineStateClientDto ( var publisher : AccountInfoStateClientDto? = null , var author : AccountInfoStateClientDto? = null , var editor : AccountInfoStateClientDto? = null , //... var linearId : UniqueIdentifier? = null ) : AccountsAwareStateClientDto < BookContract . MagazineState > { //... }","title":"Accounts-Aware DTO Types"},{"location":"plugins/corda-accounts/#query-dsl-enhancements","text":"Corda 4.3 added the possibility to map any public key to an external id of type UUID. Corda Accounts uses this feature to map an account\u2019s key to the account\u2019s id. Thus, using externalIds creates query criteria aware of state participants, without the need to embed account identifiers within the state itself. This is now supported by the generated Query DSL for your contract state: val magazineStateQuery = magazineStateQuery { // Match participants using the following // AccountInfo identifiers externalIds = listOfNotNull ( publisher . identifier ) status = Vault . StateStatus . UNCONSUMED // the default // The rest of the query.. //...","title":"Query DSL Enhancements"},{"location":"plugins/corda-accounts/#service-enhancements","text":"The plugin also adds and applies various accounts-aware service types as replacements of their default equivalents, along with a number of utility methods around accounts. // Create an instance of the generated service type, // passing a ServiceHub, CordaRPCOps, NodeRpcConnection // or even a custom StateServiceDelegate val stateService = AccountInfoService ( serviceHub ) // Get the account that is already stored locally // and matching the given [id] if found, null otherwise val accountOrNull : AccountInfo? = stateService . findStoredAccount ( accountId ) ?: stateService . requestAccount ( accountId , accountHost ) // Get the account that is already stored locally // and matching the given [id] if found, null otherwise val account : AccountInfo = stateService . getStoredAccount ( accountId ) // Find accounts that are already stored locally // and match the given [criteria] val accountsPage : Vault . Page < AccountInfo > = stateService . findStoredAccounts ( queryCriteria ) // Create a public key for the given [accountInfo] */ val anonymousParty = stateService . createPublicKey ( accountInfo )","title":"Service Enhancements"},{"location":"plugins/rsql-support/","text":"RSQL Plugin \u00b6 Creating search endpoints in webapp is a tedious process, even with Vaultaire\u2019s query DSL. The main maintenance effort goes to mapping URL parameters to query criteria and operators. Why not evaluate those dynamically? This plugin uses jirutka/rsql-parser to provide support for RSQL and FIQL queries, which is great for REST: It\u2019s simple, compact and URL-friendly. There\u2019s no need to maintain endpoints as you add/modify state propperties/schemas. Supports complex queries with logical and comparison operators. Being able to store queries as strings allows to e.g. easily manage reports. Installation \u00b6 The plugin is mainly intended for Corda client applications using Spring, Spring Boot or Jackson. It can however be used with other JVM frameworks and even within cordapps. To use RSQL in your Corda client, add Vaultaire\u2019s plugin for RSQL to your Gradle build using an api , implementation or compile (deprecated) dependency. implementation \"com.github.manosbatsis.vaultaire:vaultaire-plugin-rsql:$vaultaire_version\" Note : To use the plugin in cordapps, follow the same rules as with the main Vaiultaire dependency. Plugin Features \u00b6 Extension Function \u00b6 The plugin introduces an extension function for generated DSL classes, i.e. subclasses of VaultQueryCriteriaCondition . Consider the following query DSL without RSQL: // Use the generated DSL to create query criteria val query = bookStateService . buildQuery { // blah and { fields . title `like` \"%Corda%\" fields . price gte 12 } // blah } bookStateService . queryBy ( query . toCriteria (), query . toSort ()) The equivalent using RSQL: // Use the generated DSL to create query criteria val query = bookStateService . buildQuery { // blah } // Use the RSQL extension function . withRsql ( \"title=like=*Corda*;price>=12\" , // Optional, default is // SimpleRsqlArgumentsConverter.Factory() converterFactory ) bookStateService . queryBy ( query . toCriteria (), query . toSort ()) If you\u2019re wondering about converterFactory , see the Value Converters section bellow. For an actual endpoint example that supports both \u201cregular\u201d and RSQL approaches above have a look at YoController.findPaged in the corbeans-yo-cordapp on Github. Operators \u00b6 The plugin supports the following operators: Operator(s) Examples Description == propName==queryValue Performs an equals query. Returns all entries where values in propName exactly equal queryValue != propName!=queryValue Performs a not equals query. Returns all entries where values in propName do not equal queryValue =like= propName=like=queryValue Performs an like query using * as a wildcard. Returns all entries where values in propName are like queryValue =unlike= , =notlike= , =nonlike= propName=unlike=queryValue Performs a not like query using * as a wildcard. Returns all entries where values in propName are not like queryValue =in= propName=in=(valueA, valueB) Performs an in query. Returns all entries where propName contains valueA OR valueB =out= propName=out=(valueA, valueB) Performs an not in query. Returns all entries where propName contains valueA OR valueB < , =lt= propName<queryValue , propName=lt=queryValue Performs a lesser than query. Returns all entries where values in propName are lesser than queryValue <= , =le= propName<=queryValue , propName=le=queryValue Performs a lesser than or equal to query. Returns all entries where values in propName are lesser than or equal to queryValue < , =gt= propName>queryValue , propName=gt=queryValue Performs a greater than query. Returns all entries where values in propName are greater than queryValue >= , =ge= propName>=queryValue , propName=ge=queryValue Performs a greater than or equal query. Returns all entries where values in propName are equal to or greater than queryValue =null= , =isnull= propName=null=true , propName=isnull=true Performs an is null or is not null query. Returns all entries where values in propName are null or not, based on the boolean argument. Argument Converters \u00b6 Since an RSQL query is basically a String , we need converters to transform criteria arguments to their intended type. For that purpose, the second parameter of the withRsql extension function accepts an optional RsqlArgumentsConverterFactory instance, with SimpleRsqlArgumentsConverter.Factory() being the default. You can create your own, custom RsqlArgumentsConverter and RsqlArgumentsConverterFactory types or use one already provided: Converter Class Nested Factory Description AbstractRsqlArgumentsConverter No Abstract base implementation, (optionally) extend to create your custom converter SimpleRsqlArgumentsConverter Yes The default. Simple, extensible, dependency-free implementation ObjectMapperAdapterRsqlArgumentsConverter Yes An implementation suitable for applications that make use of Jackson. Used as adapter for an ObjectMapper instance. ConversionServiceAdapterRsqlArgumentsConverter Yes An implementation suitable for applications that make use of Spring. Used as adapter for a ConversionService instance.","title":"RSQL Support"},{"location":"plugins/rsql-support/#rsql-plugin","text":"Creating search endpoints in webapp is a tedious process, even with Vaultaire\u2019s query DSL. The main maintenance effort goes to mapping URL parameters to query criteria and operators. Why not evaluate those dynamically? This plugin uses jirutka/rsql-parser to provide support for RSQL and FIQL queries, which is great for REST: It\u2019s simple, compact and URL-friendly. There\u2019s no need to maintain endpoints as you add/modify state propperties/schemas. Supports complex queries with logical and comparison operators. Being able to store queries as strings allows to e.g. easily manage reports.","title":"RSQL Plugin"},{"location":"plugins/rsql-support/#installation","text":"The plugin is mainly intended for Corda client applications using Spring, Spring Boot or Jackson. It can however be used with other JVM frameworks and even within cordapps. To use RSQL in your Corda client, add Vaultaire\u2019s plugin for RSQL to your Gradle build using an api , implementation or compile (deprecated) dependency. implementation \"com.github.manosbatsis.vaultaire:vaultaire-plugin-rsql:$vaultaire_version\" Note : To use the plugin in cordapps, follow the same rules as with the main Vaiultaire dependency.","title":"Installation"},{"location":"plugins/rsql-support/#plugin-features","text":"","title":"Plugin Features"},{"location":"plugins/rsql-support/#extension-function","text":"The plugin introduces an extension function for generated DSL classes, i.e. subclasses of VaultQueryCriteriaCondition . Consider the following query DSL without RSQL: // Use the generated DSL to create query criteria val query = bookStateService . buildQuery { // blah and { fields . title `like` \"%Corda%\" fields . price gte 12 } // blah } bookStateService . queryBy ( query . toCriteria (), query . toSort ()) The equivalent using RSQL: // Use the generated DSL to create query criteria val query = bookStateService . buildQuery { // blah } // Use the RSQL extension function . withRsql ( \"title=like=*Corda*;price>=12\" , // Optional, default is // SimpleRsqlArgumentsConverter.Factory() converterFactory ) bookStateService . queryBy ( query . toCriteria (), query . toSort ()) If you\u2019re wondering about converterFactory , see the Value Converters section bellow. For an actual endpoint example that supports both \u201cregular\u201d and RSQL approaches above have a look at YoController.findPaged in the corbeans-yo-cordapp on Github.","title":"Extension Function"},{"location":"plugins/rsql-support/#operators","text":"The plugin supports the following operators: Operator(s) Examples Description == propName==queryValue Performs an equals query. Returns all entries where values in propName exactly equal queryValue != propName!=queryValue Performs a not equals query. Returns all entries where values in propName do not equal queryValue =like= propName=like=queryValue Performs an like query using * as a wildcard. Returns all entries where values in propName are like queryValue =unlike= , =notlike= , =nonlike= propName=unlike=queryValue Performs a not like query using * as a wildcard. Returns all entries where values in propName are not like queryValue =in= propName=in=(valueA, valueB) Performs an in query. Returns all entries where propName contains valueA OR valueB =out= propName=out=(valueA, valueB) Performs an not in query. Returns all entries where propName contains valueA OR valueB < , =lt= propName<queryValue , propName=lt=queryValue Performs a lesser than query. Returns all entries where values in propName are lesser than queryValue <= , =le= propName<=queryValue , propName=le=queryValue Performs a lesser than or equal to query. Returns all entries where values in propName are lesser than or equal to queryValue < , =gt= propName>queryValue , propName=gt=queryValue Performs a greater than query. Returns all entries where values in propName are greater than queryValue >= , =ge= propName>=queryValue , propName=ge=queryValue Performs a greater than or equal query. Returns all entries where values in propName are equal to or greater than queryValue =null= , =isnull= propName=null=true , propName=isnull=true Performs an is null or is not null query. Returns all entries where values in propName are null or not, based on the boolean argument.","title":"Operators"},{"location":"plugins/rsql-support/#argument-converters","text":"Since an RSQL query is basically a String , we need converters to transform criteria arguments to their intended type. For that purpose, the second parameter of the withRsql extension function accepts an optional RsqlArgumentsConverterFactory instance, with SimpleRsqlArgumentsConverter.Factory() being the default. You can create your own, custom RsqlArgumentsConverter and RsqlArgumentsConverterFactory types or use one already provided: Converter Class Nested Factory Description AbstractRsqlArgumentsConverter No Abstract base implementation, (optionally) extend to create your custom converter SimpleRsqlArgumentsConverter Yes The default. Simple, extensible, dependency-free implementation ObjectMapperAdapterRsqlArgumentsConverter Yes An implementation suitable for applications that make use of Jackson. Used as adapter for an ObjectMapper instance. ConversionServiceAdapterRsqlArgumentsConverter Yes An implementation suitable for applications that make use of Spring. Used as adapter for a ConversionService instance.","title":"Argument Converters"}]}