{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Vaultaire Query DSL and data access utilities for Corda developers. See complete documentation at https://manosbatsis.github.io/vaultaire Query DSL Use DSL will make your queries much easier to read and maintain. Each query DSL is automatically generated and maintaind for you based on your states. al query = booksQuery { and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` Corda Books Ltd. or { fields . title ` == ` A book on Corda fields . author ` != ` John Doe } } orderBy { fields . title sort DESC } }. toCriteria () For more info on query DSL, checkout https://manosbatsis.github.io/vaultaire/query-dsl/ State Services Vaultaire s annotation processor will automatically subclass ExtendedStateService to generate an Fields aware state service service per annotated element. The generated service name is ${contractStateTypeName}Service . Usage example: // Create an instance of the generated service type val bookStateService = BookStateService ( serviceHub , // Service hub or RPC ops serviceDefaults ) // Optional: criteria, paging, sort defaults // Load a book bookStateService . getByLinearId ( identifier ) // Try finding one by ISBN bookStateService . findByExternalId ( identifier ) // query the vault for books val searchResults = bookStateService . queryBy ( criteria , paging , Pair ( published , DESC ), Pair ( title , DESC )) For more info on state services, checkout https://manosbatsis.github.io/vaultaire/state-services/ Other Utils Vaultaire includes a few other utilities like annotations to generate Data Transfer Objects for your contract states and responding flows from commonly used supertypes. For more info on these utilities, checkout https://manosbatsis.github.io/vaultaire/other-utils/","title":"Overview"},{"location":"#vaultaire","text":"Query DSL and data access utilities for Corda developers. See complete documentation at https://manosbatsis.github.io/vaultaire","title":"Vaultaire"},{"location":"#query-dsl","text":"Use DSL will make your queries much easier to read and maintain. Each query DSL is automatically generated and maintaind for you based on your states. al query = booksQuery { and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` Corda Books Ltd. or { fields . title ` == ` A book on Corda fields . author ` != ` John Doe } } orderBy { fields . title sort DESC } }. toCriteria () For more info on query DSL, checkout https://manosbatsis.github.io/vaultaire/query-dsl/","title":"Query DSL"},{"location":"#state-services","text":"Vaultaire s annotation processor will automatically subclass ExtendedStateService to generate an Fields aware state service service per annotated element. The generated service name is ${contractStateTypeName}Service . Usage example: // Create an instance of the generated service type val bookStateService = BookStateService ( serviceHub , // Service hub or RPC ops serviceDefaults ) // Optional: criteria, paging, sort defaults // Load a book bookStateService . getByLinearId ( identifier ) // Try finding one by ISBN bookStateService . findByExternalId ( identifier ) // query the vault for books val searchResults = bookStateService . queryBy ( criteria , paging , Pair ( published , DESC ), Pair ( title , DESC )) For more info on state services, checkout https://manosbatsis.github.io/vaultaire/state-services/","title":"State Services"},{"location":"#other-utils","text":"Vaultaire includes a few other utilities like annotations to generate Data Transfer Objects for your contract states and responding flows from commonly used supertypes. For more info on these utilities, checkout https://manosbatsis.github.io/vaultaire/other-utils/","title":"Other Utils"},{"location":"changelog/","text":"Changelog The following sections describe major changes per version and can be helpful with version upgrades. 0.12 Fixed dependency scope for kotlinpoet-utils 0.11 Added VaultaireGenerateDto , VaultaireGenerateDtoForDependency annotations for generating DTOs for contract states Added VaultaireGenerateResponder annotation for generating responder flows extending common supertypes Refactored to extract kotlinpoet-utils 0.10 Added @VaultaireGenerateForDependency to support generation (of DSL, Services etc.) for states contributed to the classpath by project dependencies Enhanced generated subclasses of ExtendedStateService with DSL-aware buildQuery , queryBy and trackBy Fixed typo from VaultaireGenerate.constractStateType to VaultaireGenerate.contractStateType 0.9 0.8 re-release fix 0.8 Allow annotation processing to generate code to another Gradle module or location using the kapt.kotlin.vaultaire.generated kapt argument, see installation docs. 0.7 Fixed, improved and added tests for StateService get/find by id/externalId methods StateService get by id/externalId will throw a StateNotFoundException when no match is found 0.6 Added support for aggregate functions . Added getByExternalId and findByExternalId methods to StateService Added optional Vault.RelevancyStatus parameter to StateService getByLinearId and findByLinearId methods 0.5 Removed param from String.asUniqueIdentifier() 0.4 Fixed handling of nullable fields Added string input signatures for getByLinearId , findByLinearId 0.3 Refactored StateService to an interface 0.2 Renamed VaultQueryDsl annotation to VaultaireGenerate Renamed StateService to BasicStateService , added extended StateService type. The annotation processor will now generate a subclass of StateService per annotated PersistentState 0.1 Initial release","title":"Change Log"},{"location":"changelog/#changelog","text":"The following sections describe major changes per version and can be helpful with version upgrades.","title":"Changelog"},{"location":"changelog/#012","text":"Fixed dependency scope for kotlinpoet-utils","title":"0.12"},{"location":"changelog/#011","text":"Added VaultaireGenerateDto , VaultaireGenerateDtoForDependency annotations for generating DTOs for contract states Added VaultaireGenerateResponder annotation for generating responder flows extending common supertypes Refactored to extract kotlinpoet-utils","title":"0.11"},{"location":"changelog/#010","text":"Added @VaultaireGenerateForDependency to support generation (of DSL, Services etc.) for states contributed to the classpath by project dependencies Enhanced generated subclasses of ExtendedStateService with DSL-aware buildQuery , queryBy and trackBy Fixed typo from VaultaireGenerate.constractStateType to VaultaireGenerate.contractStateType","title":"0.10"},{"location":"changelog/#09","text":"0.8 re-release fix","title":"0.9"},{"location":"changelog/#08","text":"Allow annotation processing to generate code to another Gradle module or location using the kapt.kotlin.vaultaire.generated kapt argument, see installation docs.","title":"0.8"},{"location":"changelog/#07","text":"Fixed, improved and added tests for StateService get/find by id/externalId methods StateService get by id/externalId will throw a StateNotFoundException when no match is found","title":"0.7"},{"location":"changelog/#06","text":"Added support for aggregate functions . Added getByExternalId and findByExternalId methods to StateService Added optional Vault.RelevancyStatus parameter to StateService getByLinearId and findByLinearId methods","title":"0.6"},{"location":"changelog/#05","text":"Removed param from String.asUniqueIdentifier()","title":"0.5"},{"location":"changelog/#04","text":"Fixed handling of nullable fields Added string input signatures for getByLinearId , findByLinearId","title":"0.4"},{"location":"changelog/#03","text":"Refactored StateService to an interface","title":"0.3"},{"location":"changelog/#02","text":"Renamed VaultQueryDsl annotation to VaultaireGenerate Renamed StateService to BasicStateService , added extended StateService type. The annotation processor will now generate a subclass of StateService per annotated PersistentState","title":"0.2"},{"location":"changelog/#01","text":"Initial release","title":"0.1"},{"location":"credits/","text":"Credits The following projects where of great help in creating my first DSL: AutoDsl , SqlDsl and of course the amazing KotlinPoet","title":"Credits"},{"location":"credits/#credits","text":"The following projects where of great help in creating my first DSL: AutoDsl , SqlDsl and of course the amazing KotlinPoet","title":"Credits"},{"location":"faq/","text":"Frequently Asked Questions Answers to common questions. License Vaultaire is distributed under the GNU Lesser General Public License or LGPL. This is the same license adopted by Corda dependencies like Hibernate. It allows Vaultaire to be used as a library with no effect to your project. Use with Corda Enterprise To use Vaultaire with Corda Enterprise, you will have to update your build to use the CE release . After switching to the appropriate corda_release_group and corda_release_version in your ext section, you can instruct your build to substitute transitive Corda OS dependencies with their CE equivalents: allprojects { //... configurations { all { //... resolutionStrategy { // ... eachDependency { DependencyResolveDetails details - // Exclude from substitutions as appropriate, e.g. def exclusions = [ corda-finance-contracts ] // Substitute the rest, assumes `ext.corda_release_group` and `ext.corda_release_version` are set if ( details . requested . group == net.corda ! exclusions . contains ( details . requested . name )) { // Force Corda Enterprise details . useTarget group: corda_release_group , name: details . requested . name , version: corda_release_version } } } } } } Note : The above assumes ext.corda_release_group and ext.corda_release_version are already set, e.g. to com.r3.corda and 4.2 respectively.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"Answers to common questions.","title":"Frequently Asked Questions"},{"location":"faq/#license","text":"Vaultaire is distributed under the GNU Lesser General Public License or LGPL. This is the same license adopted by Corda dependencies like Hibernate. It allows Vaultaire to be used as a library with no effect to your project.","title":"License"},{"location":"faq/#use-with-corda-enterprise","text":"To use Vaultaire with Corda Enterprise, you will have to update your build to use the CE release . After switching to the appropriate corda_release_group and corda_release_version in your ext section, you can instruct your build to substitute transitive Corda OS dependencies with their CE equivalents: allprojects { //... configurations { all { //... resolutionStrategy { // ... eachDependency { DependencyResolveDetails details - // Exclude from substitutions as appropriate, e.g. def exclusions = [ corda-finance-contracts ] // Substitute the rest, assumes `ext.corda_release_group` and `ext.corda_release_version` are set if ( details . requested . group == net.corda ! exclusions . contains ( details . requested . name )) { // Force Corda Enterprise details . useTarget group: corda_release_group , name: details . requested . name , version: corda_release_version } } } } } } Note : The above assumes ext.corda_release_group and ext.corda_release_version are already set, e.g. to com.r3.corda and 4.2 respectively.","title":"Use with Corda Enterprise"},{"location":"installation/","text":"Installation For Cordapps Add to your Cordapp s Gradle dependencies: // apply the kapt plugin apply plugin: kotlin-kapt // Optional: for IntelliJ users, see also sourceSets bellow apply plugin: idea dependencies { // Core dependency cordaCompile com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version // Annotation processing kapt com.github.manosbatsis.vaultaire:vaultaire-processor:$vaultaire_version // Corda dependencies etc. // ... } You may also want to add the generated sources to your build s sourceSets // Define an extra sources variable def generatedSourcesDir = project . file ( build/generated/source/kaptKotlin/main ) // Tell Gradle about the extra source set sourceSets { main { kotlin . srcDirs += generatedSourcesDir } } // Optional: Tell IntelliJ about the extra source set idea { module { sourceDirs += generatedSourcesDir generatedSourceDirs += generatedSourcesDir } } For Client Apps The core module can also be useful outside a cordapp, e.g. in a Spring application interacting with Corda nodes via RPC: // Core dependency compile com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version // Corda dependencies etc. // ...","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#for-cordapps","text":"Add to your Cordapp s Gradle dependencies: // apply the kapt plugin apply plugin: kotlin-kapt // Optional: for IntelliJ users, see also sourceSets bellow apply plugin: idea dependencies { // Core dependency cordaCompile com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version // Annotation processing kapt com.github.manosbatsis.vaultaire:vaultaire-processor:$vaultaire_version // Corda dependencies etc. // ... } You may also want to add the generated sources to your build s sourceSets // Define an extra sources variable def generatedSourcesDir = project . file ( build/generated/source/kaptKotlin/main ) // Tell Gradle about the extra source set sourceSets { main { kotlin . srcDirs += generatedSourcesDir } } // Optional: Tell IntelliJ about the extra source set idea { module { sourceDirs += generatedSourcesDir generatedSourceDirs += generatedSourcesDir } }","title":"For Cordapps"},{"location":"installation/#for-client-apps","text":"The core module can also be useful outside a cordapp, e.g. in a Spring application interacting with Corda nodes via RPC: // Core dependency compile com.github.manosbatsis.vaultaire:vaultaire:$vaultaire_version // Corda dependencies etc. // ...","title":"For Client Apps"},{"location":"other-utils/","text":"Other Utilities Miscellaneous utilities provides by Vaultaire Generated Responders Some times you might want to use the same responding flow with multiple initiating flows. Since @InitiatedBy is not a repeatable annotation, the only option would be to subclass the same responder for each initiating flow, adding the appropriate @InitiatedBy . Vaultaire s annotation processor can help you automate this using a @VaultaireGenerateResponder instead of maintaning such responders manually. Usage example: // or simply: @VaultaireGenerateResponder(BaseBookFlowResponder::class) @VaultaireGenerateResponder ( value = BaseBookFlowResponder :: class , comment = A basic responder to listen for finality ) @InitiatingFlow @StartableByRPC class CreateBookFlow ( input : BookMessage ) : FlowLogic SignedTransaction The above will automatically generate a responder flow: ** * A basic responder to listen for finality */ @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( otherPartySession : FlowSession ) : BaseBookFlowResponder ( otherPartySession ) Generated DTOs Maintaining Data Transfer Objects (e.g. for REST) of your contract states can be a very mundane task. You can have Vaultaire generate those for you either using @VaultaireGenerateDto on the contract state class directly: @VaultaireGenerateDto data class BookState ( val publisher : Party , val author : Party , val price : BigDecimal , val genre : Genre , val editions : Int = 1 , val title : String = Uknown , val published : Date = Date (), val alternativeTitle : String ? = null , override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { /* ... */ } or @VaultaireGenerateDtoForDependency when targetting a contract state within your dependencies e.g. from your contract states module or a third party class: @VaultaireGenerateDtoForDependency ( persistentStateType = PersistentBookState :: class , contractStateType = BookState :: class ) class Dummy // just a placeholder for our annotation In both cases the following DTO will be generated, along with proper implementations of [Dto] s mapping/patching utility methods: /** * A [BookState]-specific [Dto] implementation */ data class BookStateDto ( var publisher : Party ? = null , var author : Party ? = null , var price : BigDecimal ? = null , var genre : BookContract . Genre ? = null , var editions : Int ? = null , var title : String ? = null , var published : Date ? = null , var alternativeTitle : String ? = null , var linearId : UniqueIdentifier ? = null ) : Dto BookState { /** * Alternative constructor, used to map * from the given [BookState] instance. */ constructor ( original : BookState ) : this ( publisher = original . publisher , author = original . author , price = original . price , genre = original . genre , editions = original . editions , title = original . title , published = original . published , alternativeTitle = original . alternativeTitle , linearId = original . linearId ) /** * Create a patched copy of the given [BookState] instance, * updated using this DTO s non-null properties. */ override fun toPatched ( original : BookState ): BookState { val patched = BookState ( publisher = this . publisher ?: original . publisher , author = this . author ?: original . author , price = this . price ?: original . price , genre = this . genre ?: original . genre , editions = this . editions ?: original . editions , title = this . title ?: original . title , published = this . published ?: original . published , alternativeTitle = this . alternativeTitle ?: original . alternativeTitle , linearId = this . linearId ?: original . linearId ) return patched } /** * Create an instance of [BookState], using this DTO s properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ override fun toState (): BookState { try { val state = BookState ( publisher = this . publisher !! , author = this . author !! , price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return state } catch ( e : Exception ) { throw DtoInsufficientStateMappingException ( exception = e ) } } }","title":"Other Utilities"},{"location":"other-utils/#other-utilities","text":"Miscellaneous utilities provides by Vaultaire","title":"Other Utilities"},{"location":"other-utils/#generated-responders","text":"Some times you might want to use the same responding flow with multiple initiating flows. Since @InitiatedBy is not a repeatable annotation, the only option would be to subclass the same responder for each initiating flow, adding the appropriate @InitiatedBy . Vaultaire s annotation processor can help you automate this using a @VaultaireGenerateResponder instead of maintaning such responders manually. Usage example: // or simply: @VaultaireGenerateResponder(BaseBookFlowResponder::class) @VaultaireGenerateResponder ( value = BaseBookFlowResponder :: class , comment = A basic responder to listen for finality ) @InitiatingFlow @StartableByRPC class CreateBookFlow ( input : BookMessage ) : FlowLogic SignedTransaction The above will automatically generate a responder flow: ** * A basic responder to listen for finality */ @InitiatedBy ( value = CreateBookFlow :: class ) class CreateBookFlowResponder ( otherPartySession : FlowSession ) : BaseBookFlowResponder ( otherPartySession )","title":"Generated Responders"},{"location":"other-utils/#generated-dtos","text":"Maintaining Data Transfer Objects (e.g. for REST) of your contract states can be a very mundane task. You can have Vaultaire generate those for you either using @VaultaireGenerateDto on the contract state class directly: @VaultaireGenerateDto data class BookState ( val publisher : Party , val author : Party , val price : BigDecimal , val genre : Genre , val editions : Int = 1 , val title : String = Uknown , val published : Date = Date (), val alternativeTitle : String ? = null , override val linearId : UniqueIdentifier = UniqueIdentifier () ) : LinearState , QueryableState { /* ... */ } or @VaultaireGenerateDtoForDependency when targetting a contract state within your dependencies e.g. from your contract states module or a third party class: @VaultaireGenerateDtoForDependency ( persistentStateType = PersistentBookState :: class , contractStateType = BookState :: class ) class Dummy // just a placeholder for our annotation In both cases the following DTO will be generated, along with proper implementations of [Dto] s mapping/patching utility methods: /** * A [BookState]-specific [Dto] implementation */ data class BookStateDto ( var publisher : Party ? = null , var author : Party ? = null , var price : BigDecimal ? = null , var genre : BookContract . Genre ? = null , var editions : Int ? = null , var title : String ? = null , var published : Date ? = null , var alternativeTitle : String ? = null , var linearId : UniqueIdentifier ? = null ) : Dto BookState { /** * Alternative constructor, used to map * from the given [BookState] instance. */ constructor ( original : BookState ) : this ( publisher = original . publisher , author = original . author , price = original . price , genre = original . genre , editions = original . editions , title = original . title , published = original . published , alternativeTitle = original . alternativeTitle , linearId = original . linearId ) /** * Create a patched copy of the given [BookState] instance, * updated using this DTO s non-null properties. */ override fun toPatched ( original : BookState ): BookState { val patched = BookState ( publisher = this . publisher ?: original . publisher , author = this . author ?: original . author , price = this . price ?: original . price , genre = this . genre ?: original . genre , editions = this . editions ?: original . editions , title = this . title ?: original . title , published = this . published ?: original . published , alternativeTitle = this . alternativeTitle ?: original . alternativeTitle , linearId = this . linearId ?: original . linearId ) return patched } /** * Create an instance of [BookState], using this DTO s properties. * May throw a [DtoInsufficientStateMappingException] * if there is mot enough information to do so. */ override fun toState (): BookState { try { val state = BookState ( publisher = this . publisher !! , author = this . author !! , price = this . price !! , genre = this . genre !! , editions = this . editions !! , title = this . title !! , published = this . published !! , alternativeTitle = this . alternativeTitle , linearId = this . linearId !! ) return state } catch ( e : Exception ) { throw DtoInsufficientStateMappingException ( exception = e ) } } }","title":"Generated DTOs"},{"location":"query-dsl/","text":"Query DSL Vaultaire uses an annotation processor at build-time to create a query DSL for your contract/persistent states. Quick Example Consider the following Contract/Persistent States: /** Book ContractState */ data class BookState ( val publisher : Party , val author : Party , val title : String , val published : Date = Date () ) : ContractState , QueryableState { // ... } // Use Vaultaire s code generation! @VaultaireGenerate ( name = booksQuery , contractStateType = BookState :: class ) @Entity @Table ( name = books ) data class PersistentBookState ( @Column ( name = publisher ) var publisher : String = , @Column ( name = author ) var author : String = , @Column ( name = title ) var title : String = , @Column ( name = published ) var published : Date ) : PersistentState () Before Vaultaire Before Vaultaire, you probably had to create query criteria with something like: val query = VaultQueryCriteria ( contractStateTypes = setOf ( BookState :: class . java ), status = Vault . StateStatus . ALL ) // Check publisher? if ( checkPublisher ) query = query . and ( VaultCustomQueryCriteria ( PersistentBookState :: publisher . equal ( Corda Books Ltd. ))) // Add more criteria query . and ( VaultCustomQueryCriteria ( PersistentBookState :: title . equal ( A book on Corda )) . or ( VaultCustomQueryCriteria ( PersistentBookState :: author . notEqual ( John Doe )))) val sort = Sort ( listOf ( Sort . SortColumn ( SortAttribute . Custom ( PersistentBookState :: class . java , published ), Sort . Direction . DESC ))) // Finally! queryBy ( query , sort ) A bit verbose so get s difficult to read as the query becomes more complex. Let s try to simplify things bellow. With Vaultaire DSL With Vaultaire s @VaultaireGenerate and the generated DSL this becomes: // Use the generated DSL to create query criteria val query = booksQuery { status = Vault . StateStatus . ALL and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` Corda Books Ltd. or { fields . title ` == ` A book on Corda fields . author ` != ` John Doe } } orderBy { fields . title sort DESC } }. toCriteria () queryBy ( query . toCriteria (), query . toSort ()) Create a DSL Project Module States To create a query DSL for your state after installing Vaultaire, annotate the corresponding PersistentState with @VaultaireGenerate : // Use Vaultaire s DSL generation! @VaultaireGenerate ( // If you omit the name, the DSL function will be named by appending Query // to the decapitalized contract state name, e.g. bookStateQuery name = booksQuery , contractStateType = BookState :: class ) @Entity @Table ( name = books ) data class PersistentBookState ( // state properties... ) : PersistentState () Project Dependency States To create a query DSL for a state from your project dependencies, annotate the any class in your project using the special @VaultaireGenerateFor annotation, providing the state s ContractState and PersistentState : @VaultaireGenerateForDependency ( name = fungibleTokenConditions , persistentStateType = PersistentFungibleToken :: class , contractStateType = FungibleToken :: class ) class Fungible Query Settings The generated DSL allows setting QueryCriteria.VaultQueryCriteria members. Here s an example using the defaults: val query = booksQuery { // settings status = Vault . StateStatus . UNCONSUMED stateRefs = null notary = null softLockingCondition = null timeCondition = null relevancyStatus = Vault . RelevancyStatus . ALL constraintTypes = emptySet () constraints = emptySet () participants = null // criteria and sorting... } Adding Criteria Query riteria are defined within the and / or functions. Both functions can be nested and mixed with criteria like: val query = booksQuery { // settings... // criteria or { // Match at least one fields . foo1 ` == ` someValue and { // Match all fields . foo1 . isNull () fields . foo2 ` == ` someOtherValue and { // ... } or { // ... } } } // sorting... } Adding Aggregates Aggregates can be specified within the and / or functions: val bookStateQuery = bookStateQuery { // settings... // criteria and { fields . title `like` %Corda Foundation% fields . genre ` == ` BookContract . BookGenre . SCIENCE_FICTION } // aggregates aggregate { // add some aggregates fields . externalId . count () fields . id . count () fields . editions . sum () fields . price . min () fields . price . avg () fields . price . max () } } Note : Corda paged queries can include either query results or other results based on the above aggregates. For that purpose, the toCriteria functions accepts an optional boolean to ignore aggregates, thus allowing the reuse of the same query to obtain either paged state or aggregate results. Accessing Fields Fields can be accessed via the generated DSL s fields object within and , or , or orderBy functions using dot notation e.g. fields.foo . You can also retrieve fields by name with e.g. fields[\"foo\"] or fields.get(\"foo\") and use non typesafe functions like _equal , _notEqual , _like , _notLike but this may change in a future release. Functions and Operators Name Aliases Examples isNull fields.foo.isNull() notNull fields.foo.notNull() equal `==` fields.foo `==` bar fields.foo equal bar fields.foo.equal(bar) notEqual `!=` fields.foo `!=` bar fields.foo notEqual bar fields.foo.notEqual(bar) lessThan lt fields.foo lt bar fields.foo lessThan bar fields.foo.lessThan(bar) lessThanOrEqual lte fields.foo lte bar fields.foo lessThanOrEqual bar fields.foo.lessThanOrEqual(bar) greaterThan gt fields.foo gt bar fields.foo greaterThan bar fields.foo.greaterThan(bar) greaterThanOrEqual gte fields.foo gte bar fields.foo greaterThanOrEqual bar fields.foo.greaterThanOrEqual(bar) between btw fields.foo btw Pair(bar1, bar2) fields.foo between Pair(bar1, bar2) fields.foo.between(bar1, bar2) like fields.foo like bar fields.foo.like(bar) notLike fields.foo notLike bar fields.foo.notLike(bar) isIn `in` fields.foo `in` bars fields.foo isIn bars fields.foo.isIn(bars) notIn `!in` fields.foo `!in` bars fields.foo notIn bars fields.foo.notIn(bars) Aggregate Functions Name Examples avg fields.foo.avg() fields.foo.avg(groupByColumns) fields.foo.avg(groupByColumns, sortDirection) count fields.foo.count() max fields.foo.max() fields.foo.max(groupByColumns) fields.foo.max(groupByColumns, sortDirection) min fields.foo.min() fields.foo.min(groupByColumns) fields.foo.min(groupByColumns, sortDirection) sum fields.foo.sum() fields.foo.sum(groupByColumns) fields.foo.sum(groupByColumns, sortDirection) Sorting Sorting is defined using the orderBy function: val criteria = bookConditions { // settings and criteria... // sorting orderBy { fields . title sort ASC fields . published sort DESC } }","title":"Query DSL"},{"location":"query-dsl/#query-dsl","text":"Vaultaire uses an annotation processor at build-time to create a query DSL for your contract/persistent states.","title":"Query DSL"},{"location":"query-dsl/#quick-example","text":"Consider the following Contract/Persistent States: /** Book ContractState */ data class BookState ( val publisher : Party , val author : Party , val title : String , val published : Date = Date () ) : ContractState , QueryableState { // ... } // Use Vaultaire s code generation! @VaultaireGenerate ( name = booksQuery , contractStateType = BookState :: class ) @Entity @Table ( name = books ) data class PersistentBookState ( @Column ( name = publisher ) var publisher : String = , @Column ( name = author ) var author : String = , @Column ( name = title ) var title : String = , @Column ( name = published ) var published : Date ) : PersistentState ()","title":"Quick Example"},{"location":"query-dsl/#before-vaultaire","text":"Before Vaultaire, you probably had to create query criteria with something like: val query = VaultQueryCriteria ( contractStateTypes = setOf ( BookState :: class . java ), status = Vault . StateStatus . ALL ) // Check publisher? if ( checkPublisher ) query = query . and ( VaultCustomQueryCriteria ( PersistentBookState :: publisher . equal ( Corda Books Ltd. ))) // Add more criteria query . and ( VaultCustomQueryCriteria ( PersistentBookState :: title . equal ( A book on Corda )) . or ( VaultCustomQueryCriteria ( PersistentBookState :: author . notEqual ( John Doe )))) val sort = Sort ( listOf ( Sort . SortColumn ( SortAttribute . Custom ( PersistentBookState :: class . java , published ), Sort . Direction . DESC ))) // Finally! queryBy ( query , sort ) A bit verbose so get s difficult to read as the query becomes more complex. Let s try to simplify things bellow.","title":"Before Vaultaire"},{"location":"query-dsl/#with-vaultaire-dsl","text":"With Vaultaire s @VaultaireGenerate and the generated DSL this becomes: // Use the generated DSL to create query criteria val query = booksQuery { status = Vault . StateStatus . ALL and { // Check publisher? if ( checkPublisher ) fields . publisher ` == ` Corda Books Ltd. or { fields . title ` == ` A book on Corda fields . author ` != ` John Doe } } orderBy { fields . title sort DESC } }. toCriteria () queryBy ( query . toCriteria (), query . toSort ())","title":"With Vaultaire DSL"},{"location":"query-dsl/#create-a-dsl","text":"","title":"Create a DSL"},{"location":"query-dsl/#project-module-states","text":"To create a query DSL for your state after installing Vaultaire, annotate the corresponding PersistentState with @VaultaireGenerate : // Use Vaultaire s DSL generation! @VaultaireGenerate ( // If you omit the name, the DSL function will be named by appending Query // to the decapitalized contract state name, e.g. bookStateQuery name = booksQuery , contractStateType = BookState :: class ) @Entity @Table ( name = books ) data class PersistentBookState ( // state properties... ) : PersistentState ()","title":"Project Module States"},{"location":"query-dsl/#project-dependency-states","text":"To create a query DSL for a state from your project dependencies, annotate the any class in your project using the special @VaultaireGenerateFor annotation, providing the state s ContractState and PersistentState : @VaultaireGenerateForDependency ( name = fungibleTokenConditions , persistentStateType = PersistentFungibleToken :: class , contractStateType = FungibleToken :: class ) class Fungible","title":"Project Dependency States"},{"location":"query-dsl/#query-settings","text":"The generated DSL allows setting QueryCriteria.VaultQueryCriteria members. Here s an example using the defaults: val query = booksQuery { // settings status = Vault . StateStatus . UNCONSUMED stateRefs = null notary = null softLockingCondition = null timeCondition = null relevancyStatus = Vault . RelevancyStatus . ALL constraintTypes = emptySet () constraints = emptySet () participants = null // criteria and sorting... }","title":"Query Settings"},{"location":"query-dsl/#adding-criteria","text":"Query riteria are defined within the and / or functions. Both functions can be nested and mixed with criteria like: val query = booksQuery { // settings... // criteria or { // Match at least one fields . foo1 ` == ` someValue and { // Match all fields . foo1 . isNull () fields . foo2 ` == ` someOtherValue and { // ... } or { // ... } } } // sorting... }","title":"Adding Criteria"},{"location":"query-dsl/#adding-aggregates","text":"Aggregates can be specified within the and / or functions: val bookStateQuery = bookStateQuery { // settings... // criteria and { fields . title `like` %Corda Foundation% fields . genre ` == ` BookContract . BookGenre . SCIENCE_FICTION } // aggregates aggregate { // add some aggregates fields . externalId . count () fields . id . count () fields . editions . sum () fields . price . min () fields . price . avg () fields . price . max () } } Note : Corda paged queries can include either query results or other results based on the above aggregates. For that purpose, the toCriteria functions accepts an optional boolean to ignore aggregates, thus allowing the reuse of the same query to obtain either paged state or aggregate results.","title":"Adding Aggregates"},{"location":"query-dsl/#accessing-fields","text":"Fields can be accessed via the generated DSL s fields object within and , or , or orderBy functions using dot notation e.g. fields.foo . You can also retrieve fields by name with e.g. fields[\"foo\"] or fields.get(\"foo\") and use non typesafe functions like _equal , _notEqual , _like , _notLike but this may change in a future release.","title":"Accessing Fields"},{"location":"query-dsl/#functions-and-operators","text":"Name Aliases Examples isNull fields.foo.isNull() notNull fields.foo.notNull() equal `==` fields.foo `==` bar fields.foo equal bar fields.foo.equal(bar) notEqual `!=` fields.foo `!=` bar fields.foo notEqual bar fields.foo.notEqual(bar) lessThan lt fields.foo lt bar fields.foo lessThan bar fields.foo.lessThan(bar) lessThanOrEqual lte fields.foo lte bar fields.foo lessThanOrEqual bar fields.foo.lessThanOrEqual(bar) greaterThan gt fields.foo gt bar fields.foo greaterThan bar fields.foo.greaterThan(bar) greaterThanOrEqual gte fields.foo gte bar fields.foo greaterThanOrEqual bar fields.foo.greaterThanOrEqual(bar) between btw fields.foo btw Pair(bar1, bar2) fields.foo between Pair(bar1, bar2) fields.foo.between(bar1, bar2) like fields.foo like bar fields.foo.like(bar) notLike fields.foo notLike bar fields.foo.notLike(bar) isIn `in` fields.foo `in` bars fields.foo isIn bars fields.foo.isIn(bars) notIn `!in` fields.foo `!in` bars fields.foo notIn bars fields.foo.notIn(bars)","title":"Functions and Operators"},{"location":"query-dsl/#aggregate-functions","text":"Name Examples avg fields.foo.avg() fields.foo.avg(groupByColumns) fields.foo.avg(groupByColumns, sortDirection) count fields.foo.count() max fields.foo.max() fields.foo.max(groupByColumns) fields.foo.max(groupByColumns, sortDirection) min fields.foo.min() fields.foo.min(groupByColumns) fields.foo.min(groupByColumns, sortDirection) sum fields.foo.sum() fields.foo.sum(groupByColumns) fields.foo.sum(groupByColumns, sortDirection)","title":"Aggregate Functions"},{"location":"query-dsl/#sorting","text":"Sorting is defined using the orderBy function: val criteria = bookConditions { // settings and criteria... // sorting orderBy { fields . title sort ASC fields . published sort DESC } }","title":"Sorting"},{"location":"state-services/","text":"State Services Vaultaire s state services provide a simple API for DAO-style loading, querying and event tracking of vault states. State services will help you decouple your your components from Corda s ServiceHub and CordaRPCOps and reuse them both in and/or out of a Corda node. Generated State Service Vaultaire s annotation processor will automatically subclass ExtendedStateService to generate an Fields aware state service service per annotated element. The generated service name is ${contractStateTypeName}Service . Usage example: // Create an instance of the generated service type val bookStateService = BookStateService ( serviceHub , // Service hub or RPC ops serviceDefaults ) // Optional: criteria, paging, sort defaults // Load a book bookStateService . getByLinearId ( identifier ) // Try finding one by ISBN bookStateService . findByExternalId ( identifier ) // query the vault for books val searchResults = bookStateService . queryBy ( criteria , paging , Pair ( published , DESC ), Pair ( title , DESC )) You can see the basic state services API for details. Custom Services You can also subclass BasicStateService , ExtendedStateService or even generated service types to create custom components. /** Extend the generated [BookStateService] */ class MyExtendedBookStateService ( delegate : StateServiceDelegate BookState ) : BookStateService ( delegate ){ // Add the appropriate constructors // to initialize per delegate type: /** [CordaRPCOps]-based constructor */ constructor ( rpcOps : CordaRPCOps , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceRpcDelegate ( rpcOps , BookState :: class . java , defaults )) /** [ServiceHub]-based constructor */ constructor ( serviceHub : ServiceHub , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceHubDelegate ( serviceHub , BookState :: class . java , defaults )) // Custom business methods... }","title":"State Services"},{"location":"state-services/#state-services","text":"Vaultaire s state services provide a simple API for DAO-style loading, querying and event tracking of vault states. State services will help you decouple your your components from Corda s ServiceHub and CordaRPCOps and reuse them both in and/or out of a Corda node.","title":"State Services"},{"location":"state-services/#generated-state-service","text":"Vaultaire s annotation processor will automatically subclass ExtendedStateService to generate an Fields aware state service service per annotated element. The generated service name is ${contractStateTypeName}Service . Usage example: // Create an instance of the generated service type val bookStateService = BookStateService ( serviceHub , // Service hub or RPC ops serviceDefaults ) // Optional: criteria, paging, sort defaults // Load a book bookStateService . getByLinearId ( identifier ) // Try finding one by ISBN bookStateService . findByExternalId ( identifier ) // query the vault for books val searchResults = bookStateService . queryBy ( criteria , paging , Pair ( published , DESC ), Pair ( title , DESC )) You can see the basic state services API for details.","title":"Generated State Service"},{"location":"state-services/#custom-services","text":"You can also subclass BasicStateService , ExtendedStateService or even generated service types to create custom components. /** Extend the generated [BookStateService] */ class MyExtendedBookStateService ( delegate : StateServiceDelegate BookState ) : BookStateService ( delegate ){ // Add the appropriate constructors // to initialize per delegate type: /** [CordaRPCOps]-based constructor */ constructor ( rpcOps : CordaRPCOps , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceRpcDelegate ( rpcOps , BookState :: class . java , defaults )) /** [ServiceHub]-based constructor */ constructor ( serviceHub : ServiceHub , defaults : StateServiceDefaults = StateServiceDefaults () ) : this ( StateServiceHubDelegate ( serviceHub , BookState :: class . java , defaults )) // Custom business methods... }","title":"Custom Services"},{"location":"0.x/","text":"Packages Name Summary com.github.manosbatsis.vaultaire.annotation com.github.manosbatsis.vaultaire.dao com.github.manosbatsis.vaultaire.dsl.contract com.github.manosbatsis.vaultaire.dsl.query com.github.manosbatsis.vaultaire.dto com.github.manosbatsis.vaultaire.registry com.github.manosbatsis.vaultaire.util Index All Types","title":"Home"},{"location":"0.x/#packages","text":"Name Summary com.github.manosbatsis.vaultaire.annotation com.github.manosbatsis.vaultaire.dao com.github.manosbatsis.vaultaire.dsl.contract com.github.manosbatsis.vaultaire.dsl.query com.github.manosbatsis.vaultaire.dto com.github.manosbatsis.vaultaire.registry com.github.manosbatsis.vaultaire.util","title":"Packages"},{"location":"0.x/#index","text":"All Types","title":"Index"},{"location":"0.x/alltypes/","text":"All Types Name Summary com.github.manosbatsis.vaultaire.dsl.query.Aggregates Used to define aggregation criteria com.github.manosbatsis.vaultaire.dsl.query.AndCondition Defines a set of conditions where all items must be matched com.github.manosbatsis.vaultaire.dao.BasicStateService Basic StateService implementation, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.dsl.query.CompositeCondition A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. com.github.manosbatsis.vaultaire.dsl.query.Condition Condition interface com.github.manosbatsis.vaultaire.dsl.query.ConditionsCondition A Condition that contains other conditions. Allows for nested and/or condition groups com.github.manosbatsis.vaultaire.dsl.contract.ContractConditions com.github.manosbatsis.vaultaire.dto.Dto com.github.manosbatsis.vaultaire.util.DtoInsufficientStateMappingException Occurs when a DTO has insufficient information for mapping to a state com.github.manosbatsis.vaultaire.dao.ExtendedStateService Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . com.github.manosbatsis.vaultaire.util.Fields Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type com.github.manosbatsis.vaultaire.util.FieldWrapper com.github.manosbatsis.vaultaire.util.GenericFieldWrapper Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.util.NullableGenericFieldWrapper Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.dsl.query.OrCondition Defines a set of conditions where at least a single item must be matched com.github.manosbatsis.vaultaire.registry.Registry com.github.manosbatsis.vaultaire.dsl.query.SortColumns Used to define Sort.SortColumn s com.github.manosbatsis.vaultaire.dao.StateNotFoundException com.github.manosbatsis.vaultaire.dao.StateService Short-lived helper, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.dao.StateServiceDefaults Define option defaults for StateService instances com.github.manosbatsis.vaultaire.dao.StateServiceDelegate StateService delegate for vault operations com.github.manosbatsis.vaultaire.dao.StateServiceHubDelegate ServiceHub -based StateServiceDelegate implementation com.github.manosbatsis.vaultaire.dao.StateServiceRpcDelegate CordaRPCOps -based StateServiceDelegate implementation kotlin.String (extensions in package com.github.manosbatsis.vaultaire.util) com.github.manosbatsis.vaultaire.util.TypedFieldWrapper Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.annotation.VaultaireDependencyAnnotationConvention com.github.manosbatsis.vaultaire.annotation.VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateResponder Generate a responser flow that extends the given type. com.github.manosbatsis.vaultaire.dsl.query.VaultCustomQueryCriteriaWrapperCondition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. com.github.manosbatsis.vaultaire.dsl.query.VaultQueryCriteriaCondition A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort com.github.manosbatsis.vaultaire.dsl.contract.When","title":"Home"},{"location":"0.x/alltypes/#all-types","text":"Name Summary com.github.manosbatsis.vaultaire.dsl.query.Aggregates Used to define aggregation criteria com.github.manosbatsis.vaultaire.dsl.query.AndCondition Defines a set of conditions where all items must be matched com.github.manosbatsis.vaultaire.dao.BasicStateService Basic StateService implementation, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.dsl.query.CompositeCondition A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. com.github.manosbatsis.vaultaire.dsl.query.Condition Condition interface com.github.manosbatsis.vaultaire.dsl.query.ConditionsCondition A Condition that contains other conditions. Allows for nested and/or condition groups com.github.manosbatsis.vaultaire.dsl.contract.ContractConditions com.github.manosbatsis.vaultaire.dto.Dto com.github.manosbatsis.vaultaire.util.DtoInsufficientStateMappingException Occurs when a DTO has insufficient information for mapping to a state com.github.manosbatsis.vaultaire.dao.ExtendedStateService Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . com.github.manosbatsis.vaultaire.util.Fields Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type com.github.manosbatsis.vaultaire.util.FieldWrapper com.github.manosbatsis.vaultaire.util.GenericFieldWrapper Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.util.NullableGenericFieldWrapper Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.dsl.query.OrCondition Defines a set of conditions where at least a single item must be matched com.github.manosbatsis.vaultaire.registry.Registry com.github.manosbatsis.vaultaire.dsl.query.SortColumns Used to define Sort.SortColumn s com.github.manosbatsis.vaultaire.dao.StateNotFoundException com.github.manosbatsis.vaultaire.dao.StateService Short-lived helper, used for vault operations on a specific ContractState type com.github.manosbatsis.vaultaire.dao.StateServiceDefaults Define option defaults for StateService instances com.github.manosbatsis.vaultaire.dao.StateServiceDelegate StateService delegate for vault operations com.github.manosbatsis.vaultaire.dao.StateServiceHubDelegate ServiceHub -based StateServiceDelegate implementation com.github.manosbatsis.vaultaire.dao.StateServiceRpcDelegate CordaRPCOps -based StateServiceDelegate implementation kotlin.String (extensions in package com.github.manosbatsis.vaultaire.util) com.github.manosbatsis.vaultaire.util.TypedFieldWrapper Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder com.github.manosbatsis.vaultaire.annotation.VaultaireDependencyAnnotationConvention com.github.manosbatsis.vaultaire.annotation.VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. com.github.manosbatsis.vaultaire.annotation.VaultaireGenerateResponder Generate a responser flow that extends the given type. com.github.manosbatsis.vaultaire.dsl.query.VaultCustomQueryCriteriaWrapperCondition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. com.github.manosbatsis.vaultaire.dsl.query.VaultQueryCriteriaCondition A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort com.github.manosbatsis.vaultaire.dsl.contract.When","title":"All Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/","text":"com.github.manosbatsis.vaultaire.annotation Package com.github.manosbatsis.vaultaire.annotation Types Name Summary VaultaireDependencyAnnotationConvention interface VaultaireDependencyAnnotationConvention Annotations Name Summary VaultaireGenerate annotation class VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. VaultaireGenerateDto annotation class VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. VaultaireGenerateDtoForDependency annotation class VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. VaultaireGenerateForDependency annotation class VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. VaultaireGenerateResponder annotation class VaultaireGenerateResponder Generate a responser flow that extends the given type.","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/#package-comgithubmanosbatsisvaultaireannotation","text":"","title":"Package com.github.manosbatsis.vaultaire.annotation"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/#types","text":"Name Summary VaultaireDependencyAnnotationConvention interface VaultaireDependencyAnnotationConvention","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/#annotations","text":"Name Summary VaultaireGenerate annotation class VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. VaultaireGenerateDto annotation class VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. VaultaireGenerateDtoForDependency annotation class VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. VaultaireGenerateForDependency annotation class VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. VaultaireGenerateResponder annotation class VaultaireGenerateResponder Generate a responser flow that extends the given type.","title":"Annotations"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDependencyAnnotationConvention VaultaireDependencyAnnotationConvention interface VaultaireDependencyAnnotationConvention Properties Name Summary contractStateType abstract val contractStateType: KClass out ContractState persistentStateType abstract val persistentStateType: KClass out PersistentState","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/#vaultairedependencyannotationconvention","text":"interface VaultaireDependencyAnnotationConvention","title":"VaultaireDependencyAnnotationConvention"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/#properties","text":"Name Summary contractStateType abstract val contractStateType: KClass out ContractState persistentStateType abstract val persistentStateType: KClass out PersistentState","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDependencyAnnotationConvention / contractStateType contractStateType abstract val contractStateType: KClass out ContractState","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/contract-state-type/#contractstatetype","text":"abstract val contractStateType: KClass out ContractState","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/persistent-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireDependencyAnnotationConvention / persistentStateType persistentStateType abstract val persistentStateType: KClass out PersistentState","title":"Persistent state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-dependency-annotation-convention/persistent-state-type/#persistentstatetype","text":"abstract val persistentStateType: KClass out PersistentState","title":"persistentStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerate VaultaireGenerate @Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. Constructors Name Summary init VaultaireGenerate(name: String = \"\", contractStateType: KClass out ContractState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor. Properties Name Summary contractStateType val contractStateType: KClass out ContractState name val name: String","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/#vaultairegenerate","text":"@Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireGenerate Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor.","title":"VaultaireGenerate"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/#constructors","text":"Name Summary init VaultaireGenerate(name: String = \"\", contractStateType: KClass out ContractState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/#properties","text":"Name Summary contractStateType val contractStateType: KClass out ContractState name val name: String","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerate / init init VaultaireGenerate(name: String = \"\", contractStateType: KClass out ContractState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/-init-/#init","text":"VaultaireGenerate(name: String = \"\", contractStateType: KClass out ContractState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the annotated PersistentState class or constructor.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerate / contractStateType contractStateType val contractStateType: KClass out ContractState","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/contract-state-type/#contractstatetype","text":"val contractStateType: KClass out ContractState","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/name/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerate / name name val name: String","title":"Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate/name/#name","text":"val name: String","title":"name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDto VaultaireGenerateDto @Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor. Constructors Name Summary init VaultaireGenerateDto() Generate a DTO for the annotated ContractState class or constructor.","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/#vaultairegeneratedto","text":"@Target([AnnotationTarget.CLASS, AnnotationTarget.CONSTRUCTOR]) annotation class VaultaireGenerateDto Generate a DTO for the annotated ContractState class or constructor.","title":"VaultaireGenerateDto"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/#constructors","text":"Name Summary init VaultaireGenerateDto() Generate a DTO for the annotated ContractState class or constructor.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDto / init init VaultaireGenerateDto() Generate a DTO for the annotated ContractState class or constructor.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto/-init-/#init","text":"VaultaireGenerateDto() Generate a DTO for the annotated ContractState class or constructor.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency VaultaireGenerateDtoForDependency @Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency. Constructors Name Summary init VaultaireGenerateDtoForDependency(contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a DTO for the ContractState of a project dependency. Properties Name Summary contractStateType val contractStateType: KClass out ContractState persistentStateType val persistentStateType: KClass out PersistentState","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/#vaultairegeneratedtofordependency","text":"@Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateDtoForDependency Generate a DTO for the ContractState of a project dependency.","title":"VaultaireGenerateDtoForDependency"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/#constructors","text":"Name Summary init VaultaireGenerateDtoForDependency(contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a DTO for the ContractState of a project dependency.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/#properties","text":"Name Summary contractStateType val contractStateType: KClass out ContractState persistentStateType val persistentStateType: KClass out PersistentState","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / init init VaultaireGenerateDtoForDependency(contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a DTO for the ContractState of a project dependency.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/-init-/#init","text":"VaultaireGenerateDtoForDependency(contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a DTO for the ContractState of a project dependency.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / contractStateType contractStateType val contractStateType: KClass out ContractState","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/contract-state-type/#contractstatetype","text":"val contractStateType: KClass out ContractState","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/persistent-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateDtoForDependency / persistentStateType persistentStateType val persistentStateType: KClass out PersistentState","title":"Persistent state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-dto-for-dependency/persistent-state-type/#persistentstatetype","text":"val persistentStateType: KClass out PersistentState","title":"persistentStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency VaultaireGenerateForDependency @Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. Constructors Name Summary init VaultaireGenerateForDependency(name: String = \"\", contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency. Properties Name Summary contractStateType val contractStateType: KClass out ContractState name val name: String persistentStateType val persistentStateType: KClass out PersistentState","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/#vaultairegeneratefordependency","text":"@Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateForDependency Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency.","title":"VaultaireGenerateForDependency"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/#constructors","text":"Name Summary init VaultaireGenerateForDependency(name: String = \"\", contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/#properties","text":"Name Summary contractStateType val contractStateType: KClass out ContractState name val name: String persistentStateType val persistentStateType: KClass out PersistentState","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency / init init VaultaireGenerateForDependency(name: String = \"\", contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/-init-/#init","text":"VaultaireGenerateForDependency(name: String = \"\", contractStateType: KClass out ContractState , persistentStateType: KClass out PersistentState ) Generate a conditions DSL and a state-specific FieldsAwareStateService for the PersistentState and ContractState of a project dependency.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/contract-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency / contractStateType contractStateType val contractStateType: KClass out ContractState","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/contract-state-type/#contractstatetype","text":"val contractStateType: KClass out ContractState","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/name/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency / name name val name: String","title":"Name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/name/#name","text":"val name: String","title":"name"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/persistent-state-type/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateForDependency / persistentStateType persistentStateType val persistentStateType: KClass out PersistentState","title":"Persistent state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-for-dependency/persistent-state-type/#persistentstatetype","text":"val persistentStateType: KClass out PersistentState","title":"persistentStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateResponder VaultaireGenerateResponder @Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateResponder Generate a responser flow that extends the given type. Constructors Name Summary init VaultaireGenerateResponder(value: KClass out FlowLogic * , comment: String = \"\") Generate a responser flow that extends the given type. Properties Name Summary comment val comment: String value val value: KClass out FlowLogic *","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/#vaultairegenerateresponder","text":"@Target([AnnotationTarget.TYPE, AnnotationTarget.CLASS]) annotation class VaultaireGenerateResponder Generate a responser flow that extends the given type.","title":"VaultaireGenerateResponder"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/#constructors","text":"Name Summary init VaultaireGenerateResponder(value: KClass out FlowLogic * , comment: String = \"\") Generate a responser flow that extends the given type.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/#properties","text":"Name Summary comment val comment: String value val value: KClass out FlowLogic *","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/-init-/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateResponder / init init VaultaireGenerateResponder(value: KClass out FlowLogic * , comment: String = \"\") Generate a responser flow that extends the given type.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/-init-/#init","text":"VaultaireGenerateResponder(value: KClass out FlowLogic * , comment: String = \"\") Generate a responser flow that extends the given type.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/comment/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateResponder / comment comment val comment: String","title":"Comment"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/comment/#comment","text":"val comment: String","title":"comment"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/value/","text":"com.github.manosbatsis.vaultaire.annotation / VaultaireGenerateResponder / value value val value: KClass out FlowLogic *","title":"Value"},{"location":"0.x/com.github.manosbatsis.vaultaire.annotation/-vaultaire-generate-responder/value/#value","text":"val value: KClass out FlowLogic *","title":"value"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/","text":"com.github.manosbatsis.vaultaire.dao Package com.github.manosbatsis.vaultaire.dao Types Name Summary BasicStateService open class BasicStateService T : ContractState : StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type ExtendedStateService abstract class ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . StateService interface StateService T : ContractState : StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type StateServiceDefaults data class StateServiceDefaults Define option defaults for StateService instances StateServiceDelegate interface StateServiceDelegate T : ContractState StateService delegate for vault operations StateServiceHubDelegate class StateServiceHubDelegate T : ContractState : StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation StateServiceRpcDelegate class StateServiceRpcDelegate T : ContractState : StateServiceDelegate T CordaRPCOps -based StateServiceDelegate implementation Exceptions Name Summary StateNotFoundException class StateNotFoundException : RuntimeException","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/#package-comgithubmanosbatsisvaultairedao","text":"","title":"Package com.github.manosbatsis.vaultaire.dao"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/#types","text":"Name Summary BasicStateService open class BasicStateService T : ContractState : StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type ExtendedStateService abstract class ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . StateService interface StateService T : ContractState : StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type StateServiceDefaults data class StateServiceDefaults Define option defaults for StateService instances StateServiceDelegate interface StateServiceDelegate T : ContractState StateService delegate for vault operations StateServiceHubDelegate class StateServiceHubDelegate T : ContractState : StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation StateServiceRpcDelegate class StateServiceRpcDelegate T : ContractState : StateServiceDelegate T CordaRPCOps -based StateServiceDelegate implementation","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/#exceptions","text":"Name Summary StateNotFoundException class StateNotFoundException : RuntimeException","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/","text":"com.github.manosbatsis.vaultaire.dao / BasicStateService BasicStateService open class BasicStateService T : ContractState : StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type Parameters T - the ContractState type Constructors Name Summary init BasicStateService(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) CordaRPCOps -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate T ) Basic StateService implementation, used for vault operations on a specific ContractState type Properties Name Summary ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean Functions Name Summary countBy open fun countBy(criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any queryBy open fun queryBy(criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inherited Functions Name Summary findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise Inheritors Name Summary ExtendedStateService abstract class ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields .","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/#basicstateservice","text":"open class BasicStateService T : ContractState : StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type","title":"BasicStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/#constructors","text":"Name Summary init BasicStateService(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) CordaRPCOps -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate T ) Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/#properties","text":"Name Summary ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/#functions","text":"Name Summary countBy open fun countBy(criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any queryBy open fun queryBy(criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/#inherited-functions","text":"Name Summary findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/#inheritors","text":"Name Summary ExtendedStateService abstract class ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields .","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/-init-/","text":"com.github.manosbatsis.vaultaire.dao / BasicStateService / init init BasicStateService(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) CordaRPCOps -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate T ) Basic StateService implementation, used for vault operations on a specific ContractState type Parameters T - the ContractState type","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/-init-/#init","text":"BasicStateService(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) CordaRPCOps -based constructor BasicStateService(serviceHub: ServiceHub, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) ServiceHub -based constructor BasicStateService(delegate: StateServiceDelegate T ) Basic StateService implementation, used for vault operations on a specific ContractState type","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/-init-/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/count-by/","text":"com.github.manosbatsis.vaultaire.dao / BasicStateService / countBy countBy open fun countBy(criteria: QueryCriteria): Long Overrides StateService.countBy Count states of type T matching stored in the vault and matching any given criteria","title":"Count by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/count-by/#countby","text":"open fun countBy(criteria: QueryCriteria): Long Overrides StateService.countBy Count states of type T matching stored in the vault and matching any given criteria","title":"countBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/find-by-external-id/","text":"com.github.manosbatsis.vaultaire.dao / BasicStateService / findByExternalId findByExternalId open fun findByExternalId(externalId: String): StateAndRef T ? Overrides StateService.findByExternalId Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"Find by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/find-by-external-id/#findbyexternalid","text":"open fun findByExternalId(externalId: String): StateAndRef T ? Overrides StateService.findByExternalId Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"findByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/find-by-linear-id/","text":"com.github.manosbatsis.vaultaire.dao / BasicStateService / findByLinearId findByLinearId open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Overrides StateService.findByLinearId Find the state of type T matching the given UniqueIdentifier if any","title":"Find by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/find-by-linear-id/#findbylinearid","text":"open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Overrides StateService.findByLinearId Find the state of type T matching the given UniqueIdentifier if any","title":"findByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/of-linear-state/","text":"com.github.manosbatsis.vaultaire.dao / BasicStateService / ofLinearState ofLinearState open val ofLinearState: Boolean Overrides StateService.ofLinearState","title":"Of linear state"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/of-linear-state/#oflinearstate","text":"open val ofLinearState: Boolean Overrides StateService.ofLinearState","title":"ofLinearState"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/of-queryable-state/","text":"com.github.manosbatsis.vaultaire.dao / BasicStateService / ofQueryableState ofQueryableState open val ofQueryableState: Boolean Overrides StateService.ofQueryableState","title":"Of queryable state"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/of-queryable-state/#ofqueryablestate","text":"open val ofQueryableState: Boolean Overrides StateService.ofQueryableState","title":"ofQueryableState"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/query-by/","text":"com.github.manosbatsis.vaultaire.dao / BasicStateService / queryBy queryBy open fun queryBy(criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Overrides StateService.queryBy Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/query-by/#queryby","text":"open fun queryBy(criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Overrides StateService.queryBy Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/track-by/","text":"com.github.manosbatsis.vaultaire.dao / BasicStateService / trackBy trackBy open fun trackBy(criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Overrides StateService.trackBy Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-basic-state-service/track-by/#trackby","text":"open fun trackBy(criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Overrides StateService.trackBy Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/","text":"com.github.manosbatsis.vaultaire.dao / ExtendedStateService ExtendedStateService abstract class ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Subclassed by Vaultaire s annotation processing to generate service components. Constructors Name Summary init ExtendedStateService(delegate: StateServiceDelegate T ) Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Properties Name Summary criteriaConditionsType lateinit var criteriaConditionsType: Class Q The fields of the target StatePersistable type P fields abstract val fields: F The fields of the target StatePersistable type P statePersistableType abstract val statePersistableType: Class P The type of the target state s StatePersistable Inherited Properties Name Summary ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean Functions Name Summary buildQuery abstract fun buildQuery(block: Q .() - Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q queryBy fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page T Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): Page T fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any toSort fun toSort(vararg sort: Pair String, Direction ): Sort Build a sort from the given string/direction pairs trackBy fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed Page T , Update T Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates. fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): DataFeed Page T , Update T fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inherited Functions Name Summary countBy open fun countBy(criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any queryBy open fun queryBy(criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/#extendedstateservice","text":"abstract class ExtendedStateService T : ContractState, P : StatePersistable, out F : Fields P , Q : VaultQueryCriteriaCondition P , F : BasicStateService T Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Subclassed by Vaultaire s annotation processing to generate service components.","title":"ExtendedStateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/#constructors","text":"Name Summary init ExtendedStateService(delegate: StateServiceDelegate T ) Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields .","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/#properties","text":"Name Summary criteriaConditionsType lateinit var criteriaConditionsType: Class Q The fields of the target StatePersistable type P fields abstract val fields: F The fields of the target StatePersistable type P statePersistableType abstract val statePersistableType: Class P The type of the target state s StatePersistable","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/#inherited-properties","text":"Name Summary ofLinearState open val ofLinearState: Boolean ofQueryableState open val ofQueryableState: Boolean","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/#functions","text":"Name Summary buildQuery abstract fun buildQuery(block: Q .() - Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q queryBy fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page T Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): Page T fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any toSort fun toSort(vararg sort: Pair String, Direction ): Sort Build a sort from the given string/direction pairs trackBy fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed Page T , Update T Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates. fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): DataFeed Page T , Update T fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/#inherited-functions","text":"Name Summary countBy open fun countBy(criteria: QueryCriteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId open fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any queryBy open fun queryBy(criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy open fun trackBy(criteria: QueryCriteria, pageNumber: Int, pageSize: Int, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/-init-/","text":"com.github.manosbatsis.vaultaire.dao / ExtendedStateService / init init ExtendedStateService(delegate: StateServiceDelegate T ) Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Subclassed by Vaultaire s annotation processing to generate service components.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/-init-/#init","text":"ExtendedStateService(delegate: StateServiceDelegate T ) Extends BasicStateService to provide a StateService aware of the target ContractState type s StatePersistable and Fields . Subclassed by Vaultaire s annotation processing to generate service components.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/build-query/","text":"com.github.manosbatsis.vaultaire.dao / ExtendedStateService / buildQuery buildQuery abstract fun buildQuery(block: Q .() - Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q","title":"Build query"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/build-query/#buildquery","text":"abstract fun buildQuery(block: Q .() - Unit): Q DSL entry point function for a VaultQueryCriteriaCondition of type Q","title":"buildQuery"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/criteria-conditions-type/","text":"com.github.manosbatsis.vaultaire.dao / ExtendedStateService / criteriaConditionsType criteriaConditionsType lateinit var criteriaConditionsType: Class Q The fields of the target StatePersistable type P","title":"Criteria conditions type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/criteria-conditions-type/#criteriaconditionstype","text":"lateinit var criteriaConditionsType: Class Q The fields of the target StatePersistable type P","title":"criteriaConditionsType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/fields/","text":"com.github.manosbatsis.vaultaire.dao / ExtendedStateService / fields fields abstract val fields: F The fields of the target StatePersistable type P","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/fields/#fields","text":"abstract val fields: F The fields of the target StatePersistable type P","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/query-by/","text":"com.github.manosbatsis.vaultaire.dao / ExtendedStateService / queryBy queryBy fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page T Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): Page T fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/query-by/#queryby","text":"fun queryBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, ignoreAggregates: Boolean = false): Page T Query the vault for states of type T matching the given DSL query, applying the given page number, size and aggregates flag fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): Page T fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/state-persistable-type/","text":"com.github.manosbatsis.vaultaire.dao / ExtendedStateService / statePersistableType statePersistableType abstract val statePersistableType: Class P The type of the target state s StatePersistable","title":"State persistable type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/state-persistable-type/#statepersistabletype","text":"abstract val statePersistableType: Class P The type of the target state s StatePersistable","title":"statePersistableType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/to-sort/","text":"com.github.manosbatsis.vaultaire.dao / ExtendedStateService / toSort toSort fun toSort(vararg sort: Pair String, Direction ): Sort Build a sort from the given string/direction pairs","title":"To sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/to-sort/#tosort","text":"fun toSort(vararg sort: Pair String, Direction ): Sort Build a sort from the given string/direction pairs","title":"toSort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/track-by/","text":"com.github.manosbatsis.vaultaire.dao / ExtendedStateService / trackBy trackBy fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed Page T , Update T Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates. fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): DataFeed Page T , Update T fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-extended-state-service/track-by/#trackby","text":"fun trackBy(condition: Q , pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize): DataFeed Page T , Update T Track the vault for states of type T matching the given DSL query, applying the given page number and size, ignoring any aggregates. fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, vararg sort: Pair String, Direction ): DataFeed Page T , Update T fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, vararg sort: Pair String, Direction ): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-not-found-exception/","text":"com.github.manosbatsis.vaultaire.dao / StateNotFoundException StateNotFoundException class StateNotFoundException : RuntimeException Constructors Name Summary init StateNotFoundException(id: String, stateType: Class * )","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-not-found-exception/#statenotfoundexception","text":"class StateNotFoundException : RuntimeException","title":"StateNotFoundException"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-not-found-exception/#constructors","text":"Name Summary init StateNotFoundException(id: String, stateType: Class * )","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-not-found-exception/-init-/","text":"com.github.manosbatsis.vaultaire.dao / StateNotFoundException / init init StateNotFoundException(id: String, stateType: Class * )","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-not-found-exception/-init-/#init","text":"StateNotFoundException(id: String, stateType: Class * )","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/","text":"com.github.manosbatsis.vaultaire.dao / StateService StateService interface StateService T : ContractState : StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type Parameters T - the ContractState type Properties Name Summary ofLinearState abstract val ofLinearState: Boolean ofQueryableState abstract val ofQueryableState: Boolean Inherited Properties Name Summary contractStateType abstract val contractStateType: Class T defaults abstract val defaults: StateServiceDefaults Functions Name Summary countBy abstract fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId abstract fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? abstract fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy abstract fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy abstract fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any Inherited Functions Name Summary queryBy abstract fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy abstract fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any Inheritors Name Summary BasicStateService open class BasicStateService T : ContractState : StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/#stateservice","text":"interface StateService T : ContractState : StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type","title":"StateService"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/#parameters","text":"T - the ContractState type","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/#properties","text":"Name Summary ofLinearState abstract val ofLinearState: Boolean ofQueryableState abstract val ofQueryableState: Boolean","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/#inherited-properties","text":"Name Summary contractStateType abstract val contractStateType: Class T defaults abstract val defaults: StateServiceDefaults","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/#functions","text":"Name Summary countBy abstract fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria findByExternalId abstract fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? abstract fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any getByExternalId open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise queryBy abstract fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any trackBy abstract fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/#inherited-functions","text":"Name Summary queryBy abstract fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy abstract fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/#inheritors","text":"Name Summary BasicStateService open class BasicStateService T : ContractState : StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/count-by/","text":"com.github.manosbatsis.vaultaire.dao / StateService / countBy countBy abstract fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria","title":"Count by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/count-by/#countby","text":"abstract fun countBy(criteria: QueryCriteria = defaults.criteria): Long Count states of type T matching stored in the vault and matching any given criteria","title":"countBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/find-by-external-id/","text":"com.github.manosbatsis.vaultaire.dao / StateService / findByExternalId findByExternalId abstract fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"Find by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/find-by-external-id/#findbyexternalid","text":"abstract fun findByExternalId(externalId: String): StateAndRef T ? Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any","title":"findByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/find-by-linear-id/","text":"com.github.manosbatsis.vaultaire.dao / StateService / findByLinearId findByLinearId open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? abstract fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any","title":"Find by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/find-by-linear-id/#findbylinearid","text":"open fun findByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UUID if any open fun findByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? abstract fun findByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T ? Find the state of type T matching the given UniqueIdentifier if any","title":"findByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/get-by-external-id/","text":"com.github.manosbatsis.vaultaire.dao / StateService / getByExternalId getByExternalId open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise Exceptions StateNotFoundException - if no match is found","title":"Get by external id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/get-by-external-id/#getbyexternalid","text":"open fun getByExternalId(externalId: String): StateAndRef T Find the Vault.StateStatus.UNCONSUMED state of type T matching the given UniqueIdentifier.externalId if any, throw an error otherwise","title":"getByExternalId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/get-by-external-id/#exceptions","text":"StateNotFoundException - if no match is found","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/get-by-linear-id/","text":"com.github.manosbatsis.vaultaire.dao / StateService / getByLinearId getByLinearId open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise Exceptions StateNotFoundException - if no match is found open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise Exceptions StateNotFoundException - if no match is found","title":"Get by linear id"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/get-by-linear-id/#getbylinearid","text":"open fun getByLinearId(linearId: UUID, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UUID if any, throw an error otherwise","title":"getByLinearId"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/get-by-linear-id/#exceptions","text":"StateNotFoundException - if no match is found open fun getByLinearId(linearId: String, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T open fun getByLinearId(linearId: UniqueIdentifier, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL): StateAndRef T Find the state of type T matching the given UniqueIdentifier if any, throw an error otherwise","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/get-by-linear-id/#exceptions_1","text":"StateNotFoundException - if no match is found","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/of-linear-state/","text":"com.github.manosbatsis.vaultaire.dao / StateService / ofLinearState ofLinearState abstract val ofLinearState: Boolean","title":"Of linear state"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/of-linear-state/#oflinearstate","text":"abstract val ofLinearState: Boolean","title":"ofLinearState"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/of-queryable-state/","text":"com.github.manosbatsis.vaultaire.dao / StateService / ofQueryableState ofQueryableState abstract val ofQueryableState: Boolean","title":"Of queryable state"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/of-queryable-state/#ofqueryablestate","text":"abstract val ofQueryableState: Boolean","title":"ofQueryableState"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/query-by/","text":"com.github.manosbatsis.vaultaire.dao / StateService / queryBy queryBy abstract fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/query-by/#queryby","text":"abstract fun queryBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): Page T Query the vault for states of type T matching the given criteria, applying the given page number, size and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/track-by/","text":"com.github.manosbatsis.vaultaire.dao / StateService / trackBy trackBy abstract fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service/track-by/#trackby","text":"abstract fun trackBy(criteria: QueryCriteria = defaults.criteria, pageNumber: Int = defaults.pageNumber, pageSize: Int = defaults.pageSize, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given page number, size and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceDefaults StateServiceDefaults data class StateServiceDefaults Define option defaults for StateService instances Constructors Name Summary init StateServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances Properties Name Summary criteria val criteria: QueryCriteria pageNumber val pageNumber: Int pageSize val pageSize: Int paging val paging: PageSpecification sort val sort: Sort","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/#stateservicedefaults","text":"data class StateServiceDefaults Define option defaults for StateService instances","title":"StateServiceDefaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/#constructors","text":"Name Summary init StateServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/#properties","text":"Name Summary criteria val criteria: QueryCriteria pageNumber val pageNumber: Int pageSize val pageSize: Int paging val paging: PageSpecification sort val sort: Sort","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/-init-/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceDefaults / init init StateServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/-init-/#init","text":"StateServiceDefaults(criteria: QueryCriteria = QueryCriteria.VaultQueryCriteria(Vault.StateStatus.UNCONSUMED), pageNumber: Int = 1, pageSize: Int = 10, sort: Sort = Sort(emptySet())) Define option defaults for StateService instances","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/criteria/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceDefaults / criteria criteria val criteria: QueryCriteria","title":"Criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/criteria/#criteria","text":"val criteria: QueryCriteria","title":"criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/page-number/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceDefaults / pageNumber pageNumber val pageNumber: Int","title":"Page number"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/page-number/#pagenumber","text":"val pageNumber: Int","title":"pageNumber"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/page-size/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceDefaults / pageSize pageSize val pageSize: Int","title":"Page size"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/page-size/#pagesize","text":"val pageSize: Int","title":"pageSize"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/paging/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceDefaults / paging paging val paging: PageSpecification","title":"Paging"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/paging/#paging","text":"val paging: PageSpecification","title":"paging"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/sort/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceDefaults / sort sort val sort: Sort","title":"Sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-defaults/sort/#sort","text":"val sort: Sort","title":"sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-delegate/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceDelegate StateServiceDelegate interface StateServiceDelegate T : ContractState StateService delegate for vault operations Properties Name Summary contractStateType abstract val contractStateType: Class T defaults abstract val defaults: StateServiceDefaults Functions Name Summary queryBy abstract fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy abstract fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any Inheritors Name Summary BasicStateService open class BasicStateService T : ContractState : StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type StateService interface StateService T : ContractState : StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type StateServiceHubDelegate class StateServiceHubDelegate T : ContractState : StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation StateServiceRpcDelegate class StateServiceRpcDelegate T : ContractState : StateServiceDelegate T CordaRPCOps -based StateServiceDelegate implementation","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-delegate/#stateservicedelegate","text":"interface StateServiceDelegate T : ContractState StateService delegate for vault operations","title":"StateServiceDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-delegate/#properties","text":"Name Summary contractStateType abstract val contractStateType: Class T defaults abstract val defaults: StateServiceDefaults","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-delegate/#functions","text":"Name Summary queryBy abstract fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy abstract fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-delegate/#inheritors","text":"Name Summary BasicStateService open class BasicStateService T : ContractState : StateServiceDelegate T , StateService T Basic StateService implementation, used for vault operations on a specific ContractState type StateService interface StateService T : ContractState : StateServiceDelegate T Short-lived helper, used for vault operations on a specific ContractState type StateServiceHubDelegate class StateServiceHubDelegate T : ContractState : StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation StateServiceRpcDelegate class StateServiceRpcDelegate T : ContractState : StateServiceDelegate T CordaRPCOps -based StateServiceDelegate implementation","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceDelegate / contractStateType contractStateType abstract val contractStateType: Class T","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-delegate/contract-state-type/#contractstatetype","text":"abstract val contractStateType: Class T","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-delegate/defaults/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceDelegate / defaults defaults abstract val defaults: StateServiceDefaults","title":"Defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-delegate/defaults/#defaults","text":"abstract val defaults: StateServiceDefaults","title":"defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-delegate/query-by/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceDelegate / queryBy queryBy abstract fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-delegate/query-by/#queryby","text":"abstract fun queryBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-delegate/track-by/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceDelegate / trackBy trackBy abstract fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-delegate/track-by/#trackby","text":"abstract fun trackBy(criteria: QueryCriteria = defaults.criteria, paging: PageSpecification = defaults.paging, sort: Sort = defaults.sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceHubDelegate StateServiceHubDelegate class StateServiceHubDelegate T : ContractState : StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation Constructors Name Summary init StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) ServiceHub -based StateServiceDelegate implementation Properties Name Summary contractStateType val contractStateType: Class T defaults val defaults: StateServiceDefaults Functions Name Summary queryBy fun queryBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy fun trackBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/#stateservicehubdelegate","text":"class StateServiceHubDelegate T : ContractState : StateServiceDelegate T ServiceHub -based StateServiceDelegate implementation","title":"StateServiceHubDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/#constructors","text":"Name Summary init StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) ServiceHub -based StateServiceDelegate implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/#properties","text":"Name Summary contractStateType val contractStateType: Class T defaults val defaults: StateServiceDefaults","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/#functions","text":"Name Summary queryBy fun queryBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy fun trackBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceHubDelegate / init init StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) ServiceHub -based StateServiceDelegate implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/-init-/#init","text":"StateServiceHubDelegate(serviceHub: ServiceHub, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) ServiceHub -based StateServiceDelegate implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceHubDelegate / contractStateType contractStateType val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/contract-state-type/#contractstatetype","text":"val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/defaults/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceHubDelegate / defaults defaults val defaults: StateServiceDefaults Overrides StateServiceDelegate.defaults","title":"Defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/defaults/#defaults","text":"val defaults: StateServiceDefaults Overrides StateServiceDelegate.defaults","title":"defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/query-by/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceHubDelegate / queryBy queryBy fun queryBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Overrides StateServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/query-by/#queryby","text":"fun queryBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Overrides StateServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/track-by/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceHubDelegate / trackBy trackBy fun trackBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Overrides StateServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-hub-delegate/track-by/#trackby","text":"fun trackBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Overrides StateServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceRpcDelegate StateServiceRpcDelegate class StateServiceRpcDelegate T : ContractState : StateServiceDelegate T CordaRPCOps -based StateServiceDelegate implementation Constructors Name Summary init StateServiceRpcDelegate(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) CordaRPCOps -based StateServiceDelegate implementation Properties Name Summary contractStateType val contractStateType: Class T defaults val defaults: StateServiceDefaults Functions Name Summary queryBy fun queryBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy fun trackBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/#stateservicerpcdelegate","text":"class StateServiceRpcDelegate T : ContractState : StateServiceDelegate T CordaRPCOps -based StateServiceDelegate implementation","title":"StateServiceRpcDelegate"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/#constructors","text":"Name Summary init StateServiceRpcDelegate(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) CordaRPCOps -based StateServiceDelegate implementation","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/#properties","text":"Name Summary contractStateType val contractStateType: Class T defaults val defaults: StateServiceDefaults","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/#functions","text":"Name Summary queryBy fun queryBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any trackBy fun trackBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/-init-/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceRpcDelegate / init init StateServiceRpcDelegate(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) CordaRPCOps -based StateServiceDelegate implementation","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/-init-/#init","text":"StateServiceRpcDelegate(rpcOps: CordaRPCOps, contractStateType: Class T , defaults: StateServiceDefaults = StateServiceDefaults()) CordaRPCOps -based StateServiceDelegate implementation","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/contract-state-type/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceRpcDelegate / contractStateType contractStateType val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/contract-state-type/#contractstatetype","text":"val contractStateType: Class T Overrides StateServiceDelegate.contractStateType","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/defaults/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceRpcDelegate / defaults defaults val defaults: StateServiceDefaults Overrides StateServiceDelegate.defaults","title":"Defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/defaults/#defaults","text":"val defaults: StateServiceDefaults Overrides StateServiceDelegate.defaults","title":"defaults"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/query-by/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceRpcDelegate / queryBy queryBy fun queryBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Overrides StateServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"Query by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/query-by/#queryby","text":"fun queryBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): Page T Overrides StateServiceDelegate.queryBy Query the vault for states matching the given criteria, applying the given paging and sorting specifications if any","title":"queryBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/track-by/","text":"com.github.manosbatsis.vaultaire.dao / StateServiceRpcDelegate / trackBy trackBy fun trackBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Overrides StateServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"Track by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dao/-state-service-rpc-delegate/track-by/#trackby","text":"fun trackBy(criteria: QueryCriteria, paging: PageSpecification, sort: Sort): DataFeed Page T , Update T Overrides StateServiceDelegate.trackBy Track the vault for events of T states matching the given criteria, applying the given paging and sorting specifications if any","title":"trackBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/","text":"com.github.manosbatsis.vaultaire.dsl.contract Package com.github.manosbatsis.vaultaire.dsl.contract Types Name Summary ContractConditions abstract class ContractConditions When class When","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/#package-comgithubmanosbatsisvaultairedslcontract","text":"","title":"Package com.github.manosbatsis.vaultaire.dsl.contract"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/#types","text":"Name Summary ContractConditions abstract class ContractConditions When class When","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions ContractConditions abstract class ContractConditions Constructors Name Summary init ContractConditions(tx: LedgerTransaction) Properties Name Summary commandTypes abstract val commandTypes: Any fields abstract val T : ContractState InOutGroup T , * .fields: Fields T groups abstract val groups: Any roles abstract val roles: Any stateTypeFields abstract val stateTypeFields: Any stateTypes abstract val stateTypes: Any tx val tx: LedgerTransaction","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/#contractconditions","text":"abstract class ContractConditions","title":"ContractConditions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/#constructors","text":"Name Summary init ContractConditions(tx: LedgerTransaction)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/#properties","text":"Name Summary commandTypes abstract val commandTypes: Any fields abstract val T : ContractState InOutGroup T , * .fields: Fields T groups abstract val groups: Any roles abstract val roles: Any stateTypeFields abstract val stateTypeFields: Any stateTypes abstract val stateTypes: Any tx val tx: LedgerTransaction","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / init init ContractConditions(tx: LedgerTransaction)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/-init-/#init","text":"ContractConditions(tx: LedgerTransaction)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/command-types/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / commandTypes commandTypes abstract val commandTypes: Any","title":"Command types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/command-types/#commandtypes","text":"abstract val commandTypes: Any","title":"commandTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/fields/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / fields fields abstract val T : ContractState InOutGroup T , * .fields: Fields T","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/fields/#fields","text":"abstract val T : ContractState InOutGroup T , * .fields: Fields T","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/groups/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / groups groups abstract val groups: Any","title":"Groups"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/groups/#groups","text":"abstract val groups: Any","title":"groups"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/roles/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / roles roles abstract val roles: Any","title":"Roles"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/roles/#roles","text":"abstract val roles: Any","title":"roles"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-type-fields/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / stateTypeFields stateTypeFields abstract val stateTypeFields: Any","title":"State type fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-type-fields/#statetypefields","text":"abstract val stateTypeFields: Any","title":"stateTypeFields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-types/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / stateTypes stateTypes abstract val stateTypes: Any","title":"State types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/state-types/#statetypes","text":"abstract val stateTypes: Any","title":"stateTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/tx/","text":"com.github.manosbatsis.vaultaire.dsl.contract / ContractConditions / tx tx val tx: LedgerTransaction","title":"Tx"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-contract-conditions/tx/#tx","text":"val tx: LedgerTransaction","title":"tx"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/","text":"com.github.manosbatsis.vaultaire.dsl.contract / When When class When Constructors Name Summary init When(vararg conditions: Boolean)","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/#when","text":"class When","title":"When"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/#constructors","text":"Name Summary init When(vararg conditions: Boolean)","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.contract / When / init init When(vararg conditions: Boolean)","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.contract/-when/-init-/#init","text":"When(vararg conditions: Boolean)","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/","text":"com.github.manosbatsis.vaultaire.dsl.query Package com.github.manosbatsis.vaultaire.dsl.query Types Name Summary Aggregates class Aggregates P : StatePersistable Used to define aggregation criteria AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Condition interface Condition Condition interface ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched SortColumns class SortColumns P : StatePersistable Used to define Sort.SortColumn s VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/#package-comgithubmanosbatsisvaultairedslquery","text":"","title":"Package com.github.manosbatsis.vaultaire.dsl.query"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/#types","text":"Name Summary Aggregates class Aggregates P : StatePersistable Used to define aggregation criteria AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Condition interface Condition Condition interface ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched SortColumns class SortColumns P : StatePersistable Used to define Sort.SortColumn s VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates Aggregates class Aggregates P : StatePersistable Used to define aggregation criteria Constructors Name Summary init Aggregates(statePersistableType: Class P ) Used to define aggregation criteria Properties Name Summary statePersistableType val statePersistableType: Class P Functions Name Summary avg fun S : Comparable S TypedFieldWrapper P , S .avg(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean count fun FieldWrapper P .count(): Boolean max fun S : Comparable S TypedFieldWrapper P , S .max(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean min fun S : Comparable S TypedFieldWrapper P , S .min(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean sum fun S : Comparable S TypedFieldWrapper P , S .sum(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#aggregates","text":"class Aggregates P : StatePersistable Used to define aggregation criteria","title":"Aggregates"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#constructors","text":"Name Summary init Aggregates(statePersistableType: Class P ) Used to define aggregation criteria","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#properties","text":"Name Summary statePersistableType val statePersistableType: Class P","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/#functions","text":"Name Summary avg fun S : Comparable S TypedFieldWrapper P , S .avg(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean count fun FieldWrapper P .count(): Boolean max fun S : Comparable S TypedFieldWrapper P , S .max(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean min fun S : Comparable S TypedFieldWrapper P , S .min(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean sum fun S : Comparable S TypedFieldWrapper P , S .sum(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / init init Aggregates(statePersistableType: Class P ) Used to define aggregation criteria","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/-init-/#init","text":"Aggregates(statePersistableType: Class P ) Used to define aggregation criteria","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/avg/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / avg avg fun S : Comparable S TypedFieldWrapper P , S .avg(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Avg"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/avg/#avg","text":"fun S : Comparable S TypedFieldWrapper P , S .avg(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"avg"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/count/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / count count fun FieldWrapper P .count(): Boolean","title":"Count"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/count/#count","text":"fun FieldWrapper P .count(): Boolean","title":"count"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/max/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / max max fun S : Comparable S TypedFieldWrapper P , S .max(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Max"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/max/#max","text":"fun S : Comparable S TypedFieldWrapper P , S .max(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"max"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/min/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / min min fun S : Comparable S TypedFieldWrapper P , S .min(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Min"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/min/#min","text":"fun S : Comparable S TypedFieldWrapper P , S .min(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"min"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/state-persistable-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / statePersistableType statePersistableType val statePersistableType: Class P","title":"State persistable type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/state-persistable-type/#statepersistabletype","text":"val statePersistableType: Class P","title":"statePersistableType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/sum/","text":"com.github.manosbatsis.vaultaire.dsl.query / Aggregates / sum sum fun S : Comparable S TypedFieldWrapper P , S .sum(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"Sum"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-aggregates/sum/#sum","text":"fun S : Comparable S TypedFieldWrapper P , S .sum(groupColumns: List FieldWrapper P ? = null, orderBy: Direction? = null): Boolean","title":"sum"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / AndCondition AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched Constructors Name Summary init AndCondition(fields: F ) Defines a set of conditions where all items must be matched Inherited Properties Name Summary fields open val fields: F The fields of the target StatePersistable type P Functions Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inherited Functions Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#andcondition","text":"class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched","title":"AndCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#constructors","text":"Name Summary init AndCondition(fields: F ) Defines a set of conditions where all items must be matched","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#inherited-properties","text":"Name Summary fields open val fields: F The fields of the target StatePersistable type P","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#functions","text":"Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/#inherited-functions","text":"Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / AndCondition / init init AndCondition(fields: F ) Defines a set of conditions where all items must be matched","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/-init-/#init","text":"AndCondition(fields: F ) Defines a set of conditions where all items must be matched","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / AndCondition / toCriteria toCriteria fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-and-condition/to-criteria/#tocriteria","text":"fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Constructors Name Summary init CompositeCondition(fields: F ) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. Properties Name Summary fields open val fields: F The fields of the target StatePersistable type P Functions Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit Inherited Functions Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit Inheritors Name Summary AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#compositecondition","text":"abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":"CompositeCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#constructors","text":"Name Summary init CompositeCondition(fields: F ) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#properties","text":"Name Summary fields open val fields: F The fields of the target StatePersistable type P","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#functions","text":"Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#inherited-functions","text":"Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/#inheritors","text":"Name Summary AndCondition class AndCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where all items must be matched OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/!=/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / != != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit","title":"!="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/!=/#_1","text":"infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit","title":"!="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/!in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / !in !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit","title":"!in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/!in/#in","text":"fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit","title":"!in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / init init CompositeCondition(fields: F ) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/-init-/#init","text":"CompositeCondition(fields: F ) A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/==/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / == == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit","title":"=="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/==/#_1","text":"infix fun S TypedFieldWrapper P , S .==(value: S ): Unit","title":"=="},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _equal _equal infix fun FieldWrapper P ._equal(value: Any): Unit","title":" equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_equal/#_equal","text":"infix fun FieldWrapper P ._equal(value: Any): Unit","title":"_equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _like _like infix fun FieldWrapper P ._like(value: String): Unit","title":" like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_like/#_like","text":"infix fun FieldWrapper P ._like(value: String): Unit","title":"_like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _notEqual _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit","title":" not equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-equal/#_notequal","text":"infix fun FieldWrapper P ._notEqual(value: Any): Unit","title":"_notEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / _notLike _notLike infix fun FieldWrapper P ._notLike(value: String): Unit","title":" not like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/_not-like/#_notlike","text":"infix fun FieldWrapper P ._notLike(value: String): Unit","title":"_notLike"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/as-string-property/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / asStringProperty asStringProperty protected fun FieldWrapper P .asStringProperty(): KProperty1 P , String","title":"As string property"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/as-string-property/#asstringproperty","text":"protected fun FieldWrapper P .asStringProperty(): KProperty1 P , String","title":"asStringProperty"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/between/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / between between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit","title":"Between"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/between/#between","text":"fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit","title":"between"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/btw/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / btw btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit","title":"Btw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/btw/#btw","text":"infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit","title":"btw"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / equal equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit","title":"Equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/equal/#equal","text":"infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit","title":"equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/fields/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / fields fields open val fields: F Overrides ConditionsCondition.fields The fields of the target StatePersistable type P","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/fields/#fields","text":"open val fields: F Overrides ConditionsCondition.fields The fields of the target StatePersistable type P","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than-or-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / greaterThanOrEqual greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit","title":"Greater than or equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than-or-equal/#greaterthanorequal","text":"infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit","title":"greaterThanOrEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / greaterThan greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit","title":"Greater than"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/greater-than/#greaterthan","text":"infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit","title":"greaterThan"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gt/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / gt gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit","title":"Gt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gt/#gt","text":"infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit","title":"gt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gte/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / gte gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit","title":"Gte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/gte/#gte","text":"infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit","title":"gte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / in in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit","title":"In"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/in/#in","text":"infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit","title":"in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / isIn isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit","title":"Is in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-in/#isin","text":"infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit","title":"isIn"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-null/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / isNull isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit","title":"Is null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/is-null/#isnull","text":"fun S NullableGenericFieldWrapper P , S .isNull(): Unit","title":"isNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than-or-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lessThanOrEqual lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit","title":"Less than or equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than-or-equal/#lessthanorequal","text":"infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit","title":"lessThanOrEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lessThan lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit","title":"Less than"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/less-than/#lessthan","text":"infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit","title":"lessThan"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / like like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit","title":"Like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/like/#like","text":"infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit","title":"like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lt/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lt lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit","title":"Lt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lt/#lt","text":"infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit","title":"lt"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lte/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / lte lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit","title":"Lte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/lte/#lte","text":"infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit","title":"lte"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-equal/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notEqual notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit","title":"Not equal"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-equal/#notequal","text":"infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit","title":"notEqual"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-in/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notIn notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit","title":"Not in"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-in/#notin","text":"infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit","title":"notIn"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-like/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notLike notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit","title":"Not like"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-like/#notlike","text":"infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit","title":"notLike"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-null/","text":"com.github.manosbatsis.vaultaire.dsl.query / CompositeCondition / notNull notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Not null"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-composite-condition/not-null/#notnull","text":"fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"notNull"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / Condition Condition interface Condition Condition interface Functions Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inheritors Name Summary ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/#condition","text":"interface Condition Condition interface","title":"Condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/#functions","text":"Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/#inheritors","text":"Name Summary ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / Condition / toCriteria toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-condition/to-criteria/#tocriteria","text":"abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition ConditionsCondition abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups Constructors Name Summary init ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups Properties Name Summary fields abstract val fields: F The fields of the target StatePersistable type P Functions Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit Inherited Functions Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inheritors Name Summary CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#conditionscondition","text":"abstract class ConditionsCondition P : StatePersistable, out F : Fields P : Condition A Condition that contains other conditions. Allows for nested and/or condition groups","title":"ConditionsCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#constructors","text":"Name Summary init ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#properties","text":"Name Summary fields abstract val fields: F The fields of the target StatePersistable type P","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#functions","text":"Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#inherited-functions","text":"Name Summary toCriteria abstract fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/#inheritors","text":"Name Summary CompositeCondition abstract class CompositeCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition , base implementation for and/or condition group containers. Allows for query criteria conditions. VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / init init ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/-init-/#init","text":"ConditionsCondition() A Condition that contains other conditions. Allows for nested and/or condition groups","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/add-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / addCondition addCondition fun addCondition(condition: Condition ): Unit","title":"Add condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/add-condition/#addcondition","text":"fun addCondition(condition: Condition ): Unit","title":"addCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/and/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / and and fun and(initializer: CompositeCondition P , F .() - Unit): Unit","title":"And"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/and/#and","text":"fun and(initializer: CompositeCondition P , F .() - Unit): Unit","title":"and"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/fields/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / fields fields abstract val fields: F The fields of the target StatePersistable type P","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/fields/#fields","text":"abstract val fields: F The fields of the target StatePersistable type P","title":"fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/or/","text":"com.github.manosbatsis.vaultaire.dsl.query / ConditionsCondition / or or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Or"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-conditions-condition/or/#or","text":"fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"or"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / OrCondition OrCondition class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched Constructors Name Summary init OrCondition(fields: F ) Defines a set of conditions where at least a single item must be matched Inherited Properties Name Summary fields open val fields: F The fields of the target StatePersistable type P Functions Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise Inherited Functions Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#orcondition","text":"class OrCondition P : StatePersistable, out F : Fields P : CompositeCondition P , F Defines a set of conditions where at least a single item must be matched","title":"OrCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#constructors","text":"Name Summary init OrCondition(fields: F ) Defines a set of conditions where at least a single item must be matched","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#inherited-properties","text":"Name Summary fields open val fields: F The fields of the target StatePersistable type P","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#functions","text":"Name Summary toCriteria fun toCriteria(): QueryCriteria? Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/#inherited-functions","text":"Name Summary != infix fun S TypedFieldWrapper P , S .!=(value: S ): Unit !in fun S : Comparable S TypedFieldWrapper P , S .!in(value: Collection S ): Unit == infix fun S TypedFieldWrapper P , S .==(value: S ): Unit _equal infix fun FieldWrapper P ._equal(value: Any): Unit _like infix fun FieldWrapper P ._like(value: String): Unit _notEqual infix fun FieldWrapper P ._notEqual(value: Any): Unit _notLike infix fun FieldWrapper P ._notLike(value: String): Unit asStringProperty fun FieldWrapper P .asStringProperty(): KProperty1 P , String between fun S : Comparable S TypedFieldWrapper P , S .between(from: S , to: S ): Unit infix fun S : Comparable S TypedFieldWrapper P , S .between(value: Pair S , S ): Unit btw infix fun S : Comparable S TypedFieldWrapper P , S .btw(value: Pair S , S ): Unit equal infix fun S TypedFieldWrapper P , S .equal(value: S ): Unit greaterThan infix fun S : Comparable S TypedFieldWrapper P , S .greaterThan(value: S ): Unit greaterThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .greaterThanOrEqual(value: S ): Unit gt infix fun S : Comparable S TypedFieldWrapper P , S .gt(value: S ): Unit gte infix fun S : Comparable S TypedFieldWrapper P , S .gte(value: S ): Unit in infix fun S : Comparable S TypedFieldWrapper P , S .in(value: Collection S ): Unit isIn infix fun S : Comparable S TypedFieldWrapper P , S .isIn(value: Collection S ): Unit isNull fun S NullableGenericFieldWrapper P , S .isNull(): Unit lessThan infix fun S : Comparable S TypedFieldWrapper P , S .lessThan(value: S ): Unit lessThanOrEqual infix fun S : Comparable S TypedFieldWrapper P , S .lessThanOrEqual(value: S ): Unit like infix fun T : StatePersistable TypedFieldWrapper T , String .like(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .like(value: String, exactMatch: Boolean = true): Unit lt infix fun S : Comparable S TypedFieldWrapper P , S .lt(value: S ): Unit lte infix fun S : Comparable S TypedFieldWrapper P , S .lte(value: S ): Unit notEqual infix fun S TypedFieldWrapper P , S .notEqual(value: S ): Unit notIn infix fun S : Comparable S TypedFieldWrapper P , S .notIn(value: Collection S ): Unit notLike infix fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String): Unit fun T : StatePersistable TypedFieldWrapper T , String .notLike(value: String, exactMatch: Boolean = true): Unit notNull fun S NullableGenericFieldWrapper P , S .notNull(): Unit","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / OrCondition / init init OrCondition(fields: F ) Defines a set of conditions where at least a single item must be matched","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/-init-/#init","text":"OrCondition(fields: F ) Defines a set of conditions where at least a single item must be matched","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / OrCondition / toCriteria toCriteria fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-or-condition/to-criteria/#tocriteria","text":"fun toCriteria(): QueryCriteria? Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns SortColumns class SortColumns P : StatePersistable Used to define Sort.SortColumn s Constructors Name Summary init SortColumns(statePersistableType: Class P ) Used to define Sort.SortColumn s Properties Name Summary ASC val ASC: Direction DESC val DESC: Direction entries val entries: LinkedHashSet SortColumn statePersistableType val statePersistableType: Class P Functions Name Summary sort infix fun FieldWrapper P .sort(value: Direction): Unit","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#sortcolumns","text":"class SortColumns P : StatePersistable Used to define Sort.SortColumn s","title":"SortColumns"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#constructors","text":"Name Summary init SortColumns(statePersistableType: Class P ) Used to define Sort.SortColumn s","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#properties","text":"Name Summary ASC val ASC: Direction DESC val DESC: Direction entries val entries: LinkedHashSet SortColumn statePersistableType val statePersistableType: Class P","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/#functions","text":"Name Summary sort infix fun FieldWrapper P .sort(value: Direction): Unit","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-a-s-c/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / ASC ASC val ASC: Direction","title":" a s c"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-a-s-c/#asc","text":"val ASC: Direction","title":"ASC"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-d-e-s-c/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / DESC DESC val DESC: Direction","title":" d e s c"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-d-e-s-c/#desc","text":"val DESC: Direction","title":"DESC"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / init init SortColumns(statePersistableType: Class P ) Used to define Sort.SortColumn s","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/-init-/#init","text":"SortColumns(statePersistableType: Class P ) Used to define Sort.SortColumn s","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/entries/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / entries entries val entries: LinkedHashSet SortColumn","title":"Entries"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/entries/#entries","text":"val entries: LinkedHashSet SortColumn","title":"entries"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/sort/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / sort sort infix fun FieldWrapper P .sort(value: Direction): Unit","title":"Sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/sort/#sort","text":"infix fun FieldWrapper P .sort(value: Direction): Unit","title":"sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-persistable-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / SortColumns / statePersistableType statePersistableType val statePersistableType: Class P","title":"State persistable type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-sort-columns/state-persistable-type/#statepersistabletype","text":"val statePersistableType: Class P","title":"statePersistableType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultCustomQueryCriteriaWrapperCondition VaultCustomQueryCriteriaWrapperCondition open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. Constructors Name Summary init VaultCustomQueryCriteriaWrapperCondition(criterion: VaultCustomQueryCriteria * ) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own. Functions Name Summary toCriteria fun toCriteria(): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/#vaultcustomquerycriteriawrappercondition","text":"open class VaultCustomQueryCriteriaWrapperCondition : Condition A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"VaultCustomQueryCriteriaWrapperCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/#constructors","text":"Name Summary init VaultCustomQueryCriteriaWrapperCondition(criterion: VaultCustomQueryCriteria * ) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/#functions","text":"Name Summary toCriteria fun toCriteria(): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultCustomQueryCriteriaWrapperCondition / init init VaultCustomQueryCriteriaWrapperCondition(criterion: VaultCustomQueryCriteria * ) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/-init-/#init","text":"VaultCustomQueryCriteriaWrapperCondition(criterion: VaultCustomQueryCriteria * ) A condition that wraps a VaultCustomQueryCriteria instance. Instances of this type are typically created by FieldWrapper extension functions defined by CompositeCondition as shorthands (infix or regular), i.e. expression-only criteria without a contract state type, vault state status or relevance status of their own.","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultCustomQueryCriteriaWrapperCondition / toCriteria toCriteria fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-custom-query-criteria-wrapper-condition/to-criteria/#tocriteria","text":"fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition VaultQueryCriteriaCondition abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort Constructors Name Summary init VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List StateRef ? = null, notary: List AbstractParty ? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set Type = emptySet(), constraints: Set ConstraintInfo = emptySet(), participants: List AbstractParty ? = null) A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort Properties Name Summary constraints var constraints: Set ConstraintInfo constraintTypes var constraintTypes: Set Type contractStateType abstract val contractStateType: Class out ContractState The target ContractState type notary var notary: List AbstractParty ? participants var participants: List AbstractParty ? relevancyStatus var relevancyStatus: RelevancyStatus softLockingCondition var softLockingCondition: SoftLockingCondition? statePersistableType abstract val statePersistableType: Class P The target StatePersistable type stateRefs var stateRefs: List StateRef ? status var status: StateStatus timeCondition var timeCondition: TimeCondition? Inherited Properties Name Summary fields abstract val fields: F The fields of the target StatePersistable type P Functions Name Summary aggregate fun aggregate(initializer: Aggregates P .() - Unit): Unit orderBy fun orderBy(initializer: SortColumns P .() - Unit): Unit toCriteria open fun toCriteria(): QueryCriteria fun toCriteria(ignoreAggregates: Boolean): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise toSort fun toSort(): Sort Inherited Functions Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#vaultquerycriteriacondition","text":"abstract class VaultQueryCriteriaCondition P : StatePersistable, out F : Fields P : ConditionsCondition P , F A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"VaultQueryCriteriaCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#constructors","text":"Name Summary init VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List StateRef ? = null, notary: List AbstractParty ? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set Type = emptySet(), constraints: Set ConstraintInfo = emptySet(), participants: List AbstractParty ? = null) A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#properties","text":"Name Summary constraints var constraints: Set ConstraintInfo constraintTypes var constraintTypes: Set Type contractStateType abstract val contractStateType: Class out ContractState The target ContractState type notary var notary: List AbstractParty ? participants var participants: List AbstractParty ? relevancyStatus var relevancyStatus: RelevancyStatus softLockingCondition var softLockingCondition: SoftLockingCondition? statePersistableType abstract val statePersistableType: Class P The target StatePersistable type stateRefs var stateRefs: List StateRef ? status var status: StateStatus timeCondition var timeCondition: TimeCondition?","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#inherited-properties","text":"Name Summary fields abstract val fields: F The fields of the target StatePersistable type P","title":"Inherited Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#functions","text":"Name Summary aggregate fun aggregate(initializer: Aggregates P .() - Unit): Unit orderBy fun orderBy(initializer: SortColumns P .() - Unit): Unit toCriteria open fun toCriteria(): QueryCriteria fun toCriteria(ignoreAggregates: Boolean): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise toSort fun toSort(): Sort","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/#inherited-functions","text":"Name Summary addCondition fun addCondition(condition: Condition ): Unit and fun and(initializer: CompositeCondition P , F .() - Unit): Unit or fun or(initializer: CompositeCondition P , F .() - Unit): Unit","title":"Inherited Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/-init-/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / init init VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List StateRef ? = null, notary: List AbstractParty ? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set Type = emptySet(), constraints: Set ConstraintInfo = emptySet(), participants: List AbstractParty ? = null) A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/-init-/#init","text":"VaultQueryCriteriaCondition(status: StateStatus = Vault.StateStatus.UNCONSUMED, stateRefs: List StateRef ? = null, notary: List AbstractParty ? = null, softLockingCondition: SoftLockingCondition? = null, timeCondition: TimeCondition? = null, relevancyStatus: RelevancyStatus = Vault.RelevancyStatus.ALL, constraintTypes: Set Type = emptySet(), constraints: Set ConstraintInfo = emptySet(), participants: List AbstractParty ? = null) A ConditionsCondition extended by Vaultaire s annotation processing to create a condition DSL specific to a ContractState type. Defines a root QueryCriteria.VaultQueryCriteria . Allows for defining and / or condition groups, as well as a Sort","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/aggregate/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / aggregate aggregate fun aggregate(initializer: Aggregates P .() - Unit): Unit","title":"Aggregate"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/aggregate/#aggregate","text":"fun aggregate(initializer: Aggregates P .() - Unit): Unit","title":"aggregate"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraint-types/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / constraintTypes constraintTypes var constraintTypes: Set Type","title":"Constraint types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraint-types/#constrainttypes","text":"var constraintTypes: Set Type","title":"constraintTypes"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraints/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / constraints constraints var constraints: Set ConstraintInfo","title":"Constraints"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/constraints/#constraints","text":"var constraints: Set ConstraintInfo","title":"constraints"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/contract-state-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / contractStateType contractStateType abstract val contractStateType: Class out ContractState The target ContractState type","title":"Contract state type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/contract-state-type/#contractstatetype","text":"abstract val contractStateType: Class out ContractState The target ContractState type","title":"contractStateType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/notary/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / notary notary var notary: List AbstractParty ?","title":"Notary"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/notary/#notary","text":"var notary: List AbstractParty ?","title":"notary"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/order-by/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / orderBy orderBy fun orderBy(initializer: SortColumns P .() - Unit): Unit","title":"Order by"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/order-by/#orderby","text":"fun orderBy(initializer: SortColumns P .() - Unit): Unit","title":"orderBy"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/participants/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / participants participants var participants: List AbstractParty ?","title":"Participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/participants/#participants","text":"var participants: List AbstractParty ?","title":"participants"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/relevancy-status/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / relevancyStatus relevancyStatus var relevancyStatus: RelevancyStatus","title":"Relevancy status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/relevancy-status/#relevancystatus","text":"var relevancyStatus: RelevancyStatus","title":"relevancyStatus"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/soft-locking-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / softLockingCondition softLockingCondition var softLockingCondition: SoftLockingCondition?","title":"Soft locking condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/soft-locking-condition/#softlockingcondition","text":"var softLockingCondition: SoftLockingCondition?","title":"softLockingCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-persistable-type/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / statePersistableType statePersistableType abstract val statePersistableType: Class P The target StatePersistable type","title":"State persistable type"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-persistable-type/#statepersistabletype","text":"abstract val statePersistableType: Class P The target StatePersistable type","title":"statePersistableType"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-refs/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / stateRefs stateRefs var stateRefs: List StateRef ?","title":"State refs"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/state-refs/#staterefs","text":"var stateRefs: List StateRef ?","title":"stateRefs"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/status/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / status status var status: StateStatus","title":"Status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/status/#status","text":"var status: StateStatus","title":"status"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-condition/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / timeCondition timeCondition var timeCondition: TimeCondition?","title":"Time condition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/time-condition/#timecondition","text":"var timeCondition: TimeCondition?","title":"timeCondition"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-criteria/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / toCriteria toCriteria open fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise fun toCriteria(ignoreAggregates: Boolean): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise Parameters ignoreAggregates - whether to ignore aggregate functions. Corda paged queries can have either state or aggregate results, but not both.","title":"To criteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-criteria/#tocriteria","text":"open fun toCriteria(): QueryCriteria Overrides Condition.toCriteria Obtain the internal state as QueryCriteria if any, null otherwise fun toCriteria(ignoreAggregates: Boolean): QueryCriteria Obtain the internal state as QueryCriteria if any, null otherwise","title":"toCriteria"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-criteria/#parameters","text":"ignoreAggregates - whether to ignore aggregate functions. Corda paged queries can have either state or aggregate results, but not both.","title":"Parameters"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-sort/","text":"com.github.manosbatsis.vaultaire.dsl.query / VaultQueryCriteriaCondition / toSort toSort fun toSort(): Sort","title":"To sort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dsl.query/-vault-query-criteria-condition/to-sort/#tosort","text":"fun toSort(): Sort","title":"toSort"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/","text":"com.github.manosbatsis.vaultaire.dto Package com.github.manosbatsis.vaultaire.dto Types Name Summary Dto interface Dto T : ContractState","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/#package-comgithubmanosbatsisvaultairedto","text":"","title":"Package com.github.manosbatsis.vaultaire.dto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/#types","text":"Name Summary Dto interface Dto T : ContractState","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-dto/","text":"com.github.manosbatsis.vaultaire.dto / Dto Dto interface Dto T : ContractState Functions Name Summary toPatched abstract fun toPatched(original: T ): T Create a patched copy of the given T instance, updated using this DTO s non-null properties toState abstract fun toState(): T Create an instance of T , using this DTO s properties. May throw a DtoInsufficientStateMappingException if there is mot enough information to do so.","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-dto/#dto","text":"interface Dto T : ContractState","title":"Dto"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-dto/#functions","text":"Name Summary toPatched abstract fun toPatched(original: T ): T Create a patched copy of the given T instance, updated using this DTO s non-null properties toState abstract fun toState(): T Create an instance of T , using this DTO s properties. May throw a DtoInsufficientStateMappingException if there is mot enough information to do so.","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-dto/to-patched/","text":"com.github.manosbatsis.vaultaire.dto / Dto / toPatched toPatched abstract fun toPatched(original: T ): T Create a patched copy of the given T instance, updated using this DTO s non-null properties","title":"To patched"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-dto/to-patched/#topatched","text":"abstract fun toPatched(original: T ): T Create a patched copy of the given T instance, updated using this DTO s non-null properties","title":"toPatched"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-dto/to-state/","text":"com.github.manosbatsis.vaultaire.dto / Dto / toState toState abstract fun toState(): T Create an instance of T , using this DTO s properties. May throw a DtoInsufficientStateMappingException if there is mot enough information to do so.","title":"To state"},{"location":"0.x/com.github.manosbatsis.vaultaire.dto/-dto/to-state/#tostate","text":"abstract fun toState(): T Create an instance of T , using this DTO s properties. May throw a DtoInsufficientStateMappingException if there is mot enough information to do so.","title":"toState"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/","text":"com.github.manosbatsis.vaultaire.registry Package com.github.manosbatsis.vaultaire.registry Types Name Summary Registry object Registry","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/#package-comgithubmanosbatsisvaultaireregistry","text":"","title":"Package com.github.manosbatsis.vaultaire.registry"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/#types","text":"Name Summary Registry object Registry","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/","text":"com.github.manosbatsis.vaultaire.registry / Registry Registry object Registry Functions Name Summary registerQueryDsl fun P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F registerQueryDsl(keyType: KClass P , queryCriteriaType: KClass Q ): KClass * ? registerService fun T : ContractState, P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F , S : ExtendedStateService T , P , F , Q registerService(keyType: KClass T , serviceType: KClass S ): KClass * ?","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/#registry","text":"object Registry","title":"Registry"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/#functions","text":"Name Summary registerQueryDsl fun P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F registerQueryDsl(keyType: KClass P , queryCriteriaType: KClass Q ): KClass * ? registerService fun T : ContractState, P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F , S : ExtendedStateService T , P , F , Q registerService(keyType: KClass T , serviceType: KClass S ): KClass * ?","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-query-dsl/","text":"com.github.manosbatsis.vaultaire.registry / Registry / registerQueryDsl registerQueryDsl fun P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F registerQueryDsl(keyType: KClass P , queryCriteriaType: KClass Q ): KClass * ?","title":"Register query dsl"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-query-dsl/#registerquerydsl","text":"fun P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F registerQueryDsl(keyType: KClass P , queryCriteriaType: KClass Q ): KClass * ?","title":"registerQueryDsl"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-service/","text":"com.github.manosbatsis.vaultaire.registry / Registry / registerService registerService fun T : ContractState, P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F , S : ExtendedStateService T , P , F , Q registerService(keyType: KClass T , serviceType: KClass S ): KClass * ?","title":"Register service"},{"location":"0.x/com.github.manosbatsis.vaultaire.registry/-registry/register-service/#registerservice","text":"fun T : ContractState, P : StatePersistable, F : Fields P , Q : VaultQueryCriteriaCondition P , F , S : ExtendedStateService T , P , F , Q registerService(keyType: KClass T , serviceType: KClass S ): KClass * ?","title":"registerService"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/","text":"com.github.manosbatsis.vaultaire.util Package com.github.manosbatsis.vaultaire.util Types Name Summary Fields interface Fields T Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type FieldWrapper interface FieldWrapper T GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Exceptions Name Summary DtoInsufficientStateMappingException class DtoInsufficientStateMappingException : RuntimeException Occurs when a DTO has insufficient information for mapping to a state Extensions for External Classes Name Summary kotlin.String","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/#package-comgithubmanosbatsisvaultaireutil","text":"","title":"Package com.github.manosbatsis.vaultaire.util"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/#types","text":"Name Summary Fields interface Fields T Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type FieldWrapper interface FieldWrapper T GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Types"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/#exceptions","text":"Name Summary DtoInsufficientStateMappingException class DtoInsufficientStateMappingException : RuntimeException Occurs when a DTO has insufficient information for mapping to a state","title":"Exceptions"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/#extensions-for-external-classes","text":"Name Summary kotlin.String","title":"Extensions for External Classes"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dto-insufficient-state-mapping-exception/","text":"com.github.manosbatsis.vaultaire.util / DtoInsufficientStateMappingException DtoInsufficientStateMappingException class DtoInsufficientStateMappingException : RuntimeException Occurs when a DTO has insufficient information for mapping to a state Constructors Name Summary init DtoInsufficientStateMappingException(message: String = \"Insufficient information while mapping DTO to state\", exception: Exception? = null) Occurs when a DTO has insufficient information for mapping to a state","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dto-insufficient-state-mapping-exception/#dtoinsufficientstatemappingexception","text":"class DtoInsufficientStateMappingException : RuntimeException Occurs when a DTO has insufficient information for mapping to a state","title":"DtoInsufficientStateMappingException"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dto-insufficient-state-mapping-exception/#constructors","text":"Name Summary init DtoInsufficientStateMappingException(message: String = \"Insufficient information while mapping DTO to state\", exception: Exception? = null) Occurs when a DTO has insufficient information for mapping to a state","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dto-insufficient-state-mapping-exception/-init-/","text":"com.github.manosbatsis.vaultaire.util / DtoInsufficientStateMappingException / init init DtoInsufficientStateMappingException(message: String = \"Insufficient information while mapping DTO to state\", exception: Exception? = null) Occurs when a DTO has insufficient information for mapping to a state","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-dto-insufficient-state-mapping-exception/-init-/#init","text":"DtoInsufficientStateMappingException(message: String = \"Insufficient information while mapping DTO to state\", exception: Exception? = null) Occurs when a DTO has insufficient information for mapping to a state","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / FieldWrapper FieldWrapper interface FieldWrapper T Properties Name Summary property abstract val property: KProperty1 T , * Inheritors Name Summary TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/#fieldwrapper","text":"interface FieldWrapper T","title":"FieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/#properties","text":"Name Summary property abstract val property: KProperty1 T , *","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/#inheritors","text":"Name Summary TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / FieldWrapper / property property abstract val property: KProperty1 T , *","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-field-wrapper/property/#property","text":"abstract val property: KProperty1 T , *","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/","text":"com.github.manosbatsis.vaultaire.util / Fields Fields interface Fields T Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type Properties Name Summary fieldsByName abstract val fieldsByName: Map String, FieldWrapper T Functions Name Summary contains open fun contains(name: String): Boolean get open operator fun get(name: String): FieldWrapper T","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/#fields","text":"interface Fields T Extended by Vaultaire s annotation processing to provide easy access to fields of a StatePersistable type","title":"Fields"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/#properties","text":"Name Summary fieldsByName abstract val fieldsByName: Map String, FieldWrapper T","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/#functions","text":"Name Summary contains open fun contains(name: String): Boolean get open operator fun get(name: String): FieldWrapper T","title":"Functions"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/contains/","text":"com.github.manosbatsis.vaultaire.util / Fields / contains contains open fun contains(name: String): Boolean","title":"Contains"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/contains/#contains","text":"open fun contains(name: String): Boolean","title":"contains"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/fields-by-name/","text":"com.github.manosbatsis.vaultaire.util / Fields / fieldsByName fieldsByName abstract val fieldsByName: Map String, FieldWrapper T","title":"Fields by name"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/fields-by-name/#fieldsbyname","text":"abstract val fieldsByName: Map String, FieldWrapper T","title":"fieldsByName"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/get/","text":"com.github.manosbatsis.vaultaire.util / Fields / get get open operator fun get(name: String): FieldWrapper T","title":"Get"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-fields/get/#get","text":"open operator fun get(name: String): FieldWrapper T","title":"get"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / GenericFieldWrapper GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Constructors Name Summary init GenericFieldWrapper(property: KProperty1 T , S ) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Properties Name Summary property val property: KProperty1 T , S","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/#genericfieldwrapper","text":"class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"GenericFieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/#constructors","text":"Name Summary init GenericFieldWrapper(property: KProperty1 T , S ) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/#properties","text":"Name Summary property val property: KProperty1 T , S","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/-init-/","text":"com.github.manosbatsis.vaultaire.util / GenericFieldWrapper / init init GenericFieldWrapper(property: KProperty1 T , S ) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/-init-/#init","text":"GenericFieldWrapper(property: KProperty1 T , S ) Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / GenericFieldWrapper / property property val property: KProperty1 T , S Overrides TypedFieldWrapper.property","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-generic-field-wrapper/property/#property","text":"val property: KProperty1 T , S Overrides TypedFieldWrapper.property","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / NullableGenericFieldWrapper NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Constructors Name Summary init NullableGenericFieldWrapper(property: KProperty1 T , S ? ) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Properties Name Summary property val property: KProperty1 T , S ?","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/#nullablegenericfieldwrapper","text":"class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"NullableGenericFieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/#constructors","text":"Name Summary init NullableGenericFieldWrapper(property: KProperty1 T , S ? ) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Constructors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/#properties","text":"Name Summary property val property: KProperty1 T , S ?","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/-init-/","text":"com.github.manosbatsis.vaultaire.util / NullableGenericFieldWrapper / init init NullableGenericFieldWrapper(property: KProperty1 T , S ? ) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":" init "},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/-init-/#init","text":"NullableGenericFieldWrapper(property: KProperty1 T , S ? ) Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"&lt;init&gt;"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / NullableGenericFieldWrapper / property property val property: KProperty1 T , S ? Overrides TypedFieldWrapper.property","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-nullable-generic-field-wrapper/property/#property","text":"val property: KProperty1 T , S ? Overrides TypedFieldWrapper.property","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/","text":"com.github.manosbatsis.vaultaire.util / TypedFieldWrapper TypedFieldWrapper interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder Properties Name Summary property abstract val property: KProperty1 T , S Inheritors Name Summary GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/#typedfieldwrapper","text":"interface TypedFieldWrapper T, S : FieldWrapper T Wraps a KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"TypedFieldWrapper"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/#properties","text":"Name Summary property abstract val property: KProperty1 T , S","title":"Properties"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/#inheritors","text":"Name Summary GenericFieldWrapper class GenericFieldWrapper T, S : TypedFieldWrapper T , S Wraps a non-nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder NullableGenericFieldWrapper class NullableGenericFieldWrapper T, S : TypedFieldWrapper T , S ? Wraps a nullable KProperty1 of a class to provide for cleaner operators, i.e. without conflicting net.corda.core.node.services.vault.Builder","title":"Inheritors"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/property/","text":"com.github.manosbatsis.vaultaire.util / TypedFieldWrapper / property property abstract val property: KProperty1 T , S Overrides FieldWrapper.property","title":"Property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/-typed-field-wrapper/property/#property","text":"abstract val property: KProperty1 T , S Overrides FieldWrapper.property","title":"property"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/","text":"com.github.manosbatsis.vaultaire.util / kotlin.String Extensions for kotlin.String Name Summary asUniqueIdentifier fun String.asUniqueIdentifier(): UniqueIdentifier","title":"Home"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/#extensions-for-kotlinstring","text":"Name Summary asUniqueIdentifier fun String.asUniqueIdentifier(): UniqueIdentifier","title":"Extensions for kotlin.String"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/as-unique-identifier/","text":"com.github.manosbatsis.vaultaire.util / kotlin.String / asUniqueIdentifier asUniqueIdentifier fun String.asUniqueIdentifier(): UniqueIdentifier","title":"As unique identifier"},{"location":"0.x/com.github.manosbatsis.vaultaire.util/kotlin.-string/as-unique-identifier/#asuniqueidentifier","text":"fun String.asUniqueIdentifier(): UniqueIdentifier","title":"asUniqueIdentifier"}]}